# Generated from grammar/wfl/WFL.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,451,4178,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,2,202,7,202,
        2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,2,208,
        7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
        2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,
        7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
        2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
        7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,
        2,236,7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,
        7,241,2,242,7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,
        2,247,7,247,2,248,7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,
        7,252,2,253,7,253,2,254,7,254,2,255,7,255,2,256,7,256,2,257,7,257,
        2,258,7,258,2,259,7,259,2,260,7,260,2,261,7,261,2,262,7,262,2,263,
        7,263,2,264,7,264,2,265,7,265,2,266,7,266,2,267,7,267,2,268,7,268,
        2,269,7,269,2,270,7,270,2,271,7,271,2,272,7,272,2,273,7,273,2,274,
        7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,7,278,2,279,7,279,
        2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,7,284,2,285,
        7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,7,290,
        2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
        7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,
        2,302,7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,
        7,307,2,308,7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,
        2,313,7,313,2,314,7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,
        7,318,2,319,7,319,2,320,7,320,2,321,7,321,2,322,7,322,2,323,7,323,
        2,324,7,324,2,325,7,325,2,326,7,326,2,327,7,327,2,328,7,328,2,329,
        7,329,1,0,1,0,3,0,663,8,0,1,0,1,0,1,1,1,1,3,1,669,8,1,1,1,3,1,672,
        8,1,1,1,1,1,1,1,1,2,3,2,678,8,2,1,2,1,2,3,2,682,8,2,1,2,1,2,1,2,
        1,2,3,2,688,8,2,1,2,3,2,691,8,2,1,2,1,2,1,3,1,3,1,4,1,4,3,4,699,
        8,4,1,4,1,4,1,5,1,5,1,5,5,5,706,8,5,10,5,12,5,709,9,5,1,6,1,6,1,
        6,3,6,714,8,6,1,6,3,6,717,8,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,726,
        8,7,1,8,1,8,1,9,3,9,731,8,9,1,9,1,9,1,9,3,9,736,8,9,1,9,3,9,739,
        8,9,1,10,1,10,1,10,1,10,3,10,745,8,10,1,10,1,10,3,10,749,8,10,1,
        10,1,10,1,10,1,10,3,10,755,8,10,1,10,1,10,3,10,759,8,10,5,10,761,
        8,10,10,10,12,10,764,9,10,1,10,1,10,1,10,1,10,5,10,770,8,10,10,10,
        12,10,773,9,10,3,10,775,8,10,1,10,3,10,778,8,10,1,10,1,10,1,10,1,
        10,3,10,784,8,10,5,10,786,8,10,10,10,12,10,789,9,10,3,10,791,8,10,
        1,11,1,11,1,12,4,12,796,8,12,11,12,12,12,797,1,13,1,13,1,13,1,13,
        1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,814,8,13,
        1,14,4,14,817,8,14,11,14,12,14,818,1,15,1,15,1,15,1,15,1,15,1,15,
        1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,838,
        8,15,1,16,1,16,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,17,1,17,1,17,
        1,18,1,18,1,18,5,18,855,8,18,10,18,12,18,858,9,18,1,19,1,19,1,20,
        1,20,1,20,1,20,1,20,1,21,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,
        1,22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
        1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
        1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,912,8,23,
        1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,1,26,
        1,26,3,26,928,8,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
        1,26,1,26,3,26,941,8,26,3,26,943,8,26,3,26,945,8,26,1,27,1,27,1,
        28,1,28,1,29,1,29,1,30,1,30,1,31,1,31,1,32,1,32,1,33,1,33,1,34,1,
        34,1,35,1,35,1,35,1,36,1,36,1,36,1,36,1,36,1,37,1,37,1,37,1,37,1,
        37,1,38,1,38,1,38,1,38,1,38,1,39,1,39,1,39,1,39,1,39,1,40,1,40,1,
        40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,1,42,3,
        42,1001,8,42,1,42,3,42,1004,8,42,1,42,1,42,1,42,3,42,1009,8,42,3,
        42,1011,8,42,1,42,1,42,1,43,1,43,1,44,1,44,1,44,1,44,1,44,1,45,1,
        45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,47,1,47,1,47,1,47,1,
        47,1,48,1,48,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,1,50,4,50,1048,
        8,50,11,50,12,50,1049,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,
        51,1,51,3,51,1062,8,51,1,52,3,52,1065,8,52,1,52,1,52,3,52,1069,8,
        52,1,52,3,52,1072,8,52,1,52,1,52,1,52,1,52,1,52,3,52,1079,8,52,1,
        52,3,52,1082,8,52,1,52,5,52,1085,8,52,10,52,12,52,1088,9,52,1,52,
        3,52,1091,8,52,1,52,4,52,1094,8,52,11,52,12,52,1095,1,52,1,52,1,
        52,1,52,4,52,1102,8,52,11,52,12,52,1103,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,3,52,1115,8,52,1,52,1,52,1,53,1,53,1,53,4,53,
        1122,8,53,11,53,12,53,1123,1,54,1,54,1,54,3,54,1129,8,54,1,54,1,
        54,1,54,1,54,1,54,1,54,1,55,1,55,1,55,3,55,1140,8,55,1,55,1,55,1,
        55,3,55,1145,8,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,1153,8,55,4,
        55,1155,8,55,11,55,12,55,1156,1,56,1,56,1,56,4,56,1162,8,56,11,56,
        12,56,1163,1,57,1,57,1,57,1,57,1,57,5,57,1171,8,57,10,57,12,57,1174,
        9,57,1,57,1,57,1,58,1,58,3,58,1180,8,58,1,58,1,58,1,58,4,58,1185,
        8,58,11,58,12,58,1186,1,59,1,59,1,59,1,59,1,59,1,59,1,59,4,59,1196,
        8,59,11,59,12,59,1197,1,60,1,60,1,61,1,61,1,61,1,61,1,61,1,61,5,
        61,1208,8,61,10,61,12,61,1211,9,61,1,61,3,61,1214,8,61,3,61,1216,
        8,61,1,62,1,62,3,62,1220,8,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
        1,63,1,63,1,63,3,63,1232,8,63,1,64,4,64,1235,8,64,11,64,12,64,1236,
        1,64,1,64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,
        3,65,1252,8,65,1,66,1,66,3,66,1256,8,66,1,66,1,66,1,67,1,67,1,67,
        1,67,1,67,1,68,1,68,3,68,1267,8,68,1,68,1,68,1,68,1,69,1,69,3,69,
        1274,8,69,1,69,1,69,1,69,1,70,1,70,1,70,1,70,1,70,1,70,5,70,1285,
        8,70,10,70,12,70,1288,9,70,1,71,1,71,1,71,1,71,1,71,1,72,3,72,1296,
        8,72,1,72,1,72,1,72,1,72,3,72,1302,8,72,1,73,1,73,4,73,1306,8,73,
        11,73,12,73,1307,1,73,1,73,3,73,1312,8,73,1,74,1,74,1,75,1,75,1,
        75,1,75,1,76,1,76,1,76,1,76,1,76,5,76,1325,8,76,10,76,12,76,1328,
        9,76,1,76,3,76,1331,8,76,1,77,1,77,1,77,1,77,3,77,1337,8,77,1,78,
        1,78,1,78,1,78,1,78,5,78,1344,8,78,10,78,12,78,1347,9,78,1,78,3,
        78,1350,8,78,1,78,3,78,1353,8,78,1,79,1,79,1,79,1,79,1,79,3,79,1360,
        8,79,1,80,1,80,1,80,1,80,5,80,1366,8,80,10,80,12,80,1369,9,80,1,
        81,1,81,1,82,1,82,1,82,1,82,5,82,1377,8,82,10,82,12,82,1380,9,82,
        1,82,5,82,1383,8,82,10,82,12,82,1386,9,82,1,82,3,82,1389,8,82,1,
        83,1,83,1,84,1,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,
        86,1,86,1,86,1,86,1,87,1,87,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,
        88,1,88,3,88,1419,8,88,1,88,1,88,1,89,1,89,1,89,1,89,1,90,1,90,1,
        90,1,90,1,91,1,91,1,91,1,92,1,92,1,92,1,92,3,92,1438,8,92,1,92,1,
        92,1,92,1,92,1,92,1,93,1,93,1,93,1,93,1,93,1,94,1,94,1,94,1,94,1,
        94,1,94,1,95,1,95,1,95,1,96,1,96,1,96,1,96,1,97,1,97,1,97,1,97,1,
        97,3,97,1468,8,97,1,97,1,97,1,98,1,98,1,99,1,99,1,99,1,99,3,99,1478,
        8,99,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,101,1,101,
        1,101,1,101,1,102,1,102,1,102,1,102,1,102,1,103,1,103,1,103,1,103,
        1,104,1,104,1,104,1,104,1,105,1,105,1,105,3,105,1508,8,105,1,106,
        1,106,1,106,5,106,1513,8,106,10,106,12,106,1516,9,106,1,107,1,107,
        3,107,1520,8,107,1,108,1,108,1,108,5,108,1525,8,108,10,108,12,108,
        1528,9,108,1,108,1,108,1,108,1,108,1,108,1,108,1,109,1,109,3,109,
        1538,8,109,1,110,1,110,1,110,1,110,1,111,1,111,1,111,1,111,1,111,
        3,111,1549,8,111,1,111,1,111,1,111,1,111,1,111,3,111,1556,8,111,
        1,111,3,111,1559,8,111,1,112,1,112,1,112,5,112,1564,8,112,10,112,
        12,112,1567,9,112,1,113,1,113,1,113,1,113,1,113,3,113,1574,8,113,
        1,114,3,114,1577,8,114,1,114,1,114,1,114,1,114,1,114,1,114,3,114,
        1585,8,114,1,114,1,114,1,114,1,114,3,114,1591,8,114,1,114,3,114,
        1594,8,114,1,115,1,115,1,115,5,115,1599,8,115,10,115,12,115,1602,
        9,115,1,116,1,116,1,116,3,116,1607,8,116,1,116,1,116,1,116,3,116,
        1612,8,116,1,116,1,116,1,116,1,116,5,116,1618,8,116,10,116,12,116,
        1621,9,116,1,117,1,117,1,117,1,117,1,118,1,118,1,118,1,118,5,118,
        1631,8,118,10,118,12,118,1634,9,118,1,118,1,118,1,119,1,119,1,119,
        1,119,1,119,3,119,1643,8,119,1,119,1,119,3,119,1647,8,119,1,120,
        1,120,1,120,1,120,1,120,1,120,1,120,3,120,1656,8,120,1,120,3,120,
        1659,8,120,1,120,1,120,3,120,1663,8,120,1,121,1,121,1,121,1,121,
        1,121,1,121,3,121,1671,8,121,1,121,1,121,1,121,1,121,3,121,1677,
        8,121,1,121,1,121,1,121,3,121,1682,8,121,1,121,1,121,1,121,3,121,
        1687,8,121,1,121,1,121,3,121,1691,8,121,1,122,1,122,1,123,1,123,
        1,123,5,123,1698,8,123,10,123,12,123,1701,9,123,1,124,1,124,3,124,
        1705,8,124,1,125,1,125,1,125,1,125,3,125,1711,8,125,1,125,1,125,
        1,125,1,125,5,125,1717,8,125,10,125,12,125,1720,9,125,1,125,1,125,
        3,125,1724,8,125,1,125,3,125,1727,8,125,1,125,1,125,1,125,3,125,
        1732,8,125,1,125,1,125,1,125,1,125,3,125,1738,8,125,1,125,3,125,
        1741,8,125,1,125,1,125,1,125,3,125,1746,8,125,1,125,1,125,1,125,
        1,125,5,125,1752,8,125,10,125,12,125,1755,9,125,1,125,1,125,3,125,
        1759,8,125,3,125,1761,8,125,1,126,1,126,1,126,3,126,1766,8,126,1,
        127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
        1,127,3,127,1780,8,127,1,128,1,128,1,129,1,129,1,130,1,130,1,131,
        1,131,1,132,1,132,1,133,1,133,1,134,1,134,1,135,1,135,1,136,1,136,
        1,137,1,137,1,138,1,138,1,139,1,139,1,139,1,139,1,139,1,139,1,139,
        1,139,1,139,1,139,3,139,1814,8,139,3,139,1816,8,139,1,139,1,139,
        1,139,1,139,1,139,3,139,1823,8,139,3,139,1825,8,139,1,139,1,139,
        1,139,1,139,5,139,1831,8,139,10,139,12,139,1834,9,139,1,139,3,139,
        1837,8,139,1,140,1,140,1,140,1,140,1,140,1,140,1,140,1,140,5,140,
        1847,8,140,10,140,12,140,1850,9,140,1,140,1,140,3,140,1854,8,140,
        3,140,1856,8,140,1,140,1,140,3,140,1860,8,140,1,140,3,140,1863,8,
        140,1,141,1,141,1,142,1,142,1,142,1,142,1,142,1,142,3,142,1873,8,
        142,1,143,1,143,1,143,1,143,5,143,1879,8,143,10,143,12,143,1882,
        9,143,1,143,1,143,1,144,1,144,1,144,1,144,1,144,5,144,1891,8,144,
        10,144,12,144,1894,9,144,1,144,1,144,3,144,1898,8,144,1,145,1,145,
        1,145,1,145,5,145,1904,8,145,10,145,12,145,1907,9,145,1,145,1,145,
        1,146,1,146,1,146,3,146,1914,8,146,1,147,1,147,1,148,1,148,1,148,
        1,148,5,148,1922,8,148,10,148,12,148,1925,9,148,1,148,1,148,1,149,
        1,149,1,149,3,149,1932,8,149,1,150,1,150,1,150,3,150,1937,8,150,
        1,151,1,151,1,151,1,151,5,151,1943,8,151,10,151,12,151,1946,9,151,
        1,151,1,151,1,152,1,152,1,152,3,152,1953,8,152,1,153,1,153,1,153,
        3,153,1958,8,153,1,153,1,153,3,153,1962,8,153,1,154,1,154,1,154,
        1,154,5,154,1968,8,154,10,154,12,154,1971,9,154,1,154,1,154,1,155,
        1,155,3,155,1977,8,155,1,155,1,155,3,155,1981,8,155,1,156,1,156,
        1,156,5,156,1986,8,156,10,156,12,156,1989,9,156,1,157,1,157,1,157,
        1,157,1,157,3,157,1996,8,157,1,158,1,158,1,158,1,158,1,158,3,158,
        2003,8,158,1,158,1,158,1,159,1,159,1,160,1,160,1,160,1,160,5,160,
        2013,8,160,10,160,12,160,2016,9,160,1,160,1,160,1,161,1,161,1,161,
        1,161,3,161,2024,8,161,1,162,1,162,1,162,1,162,1,163,1,163,1,163,
        1,163,1,164,1,164,1,164,1,164,1,165,1,165,1,165,1,165,1,166,1,166,
        1,166,3,166,2045,8,166,1,166,1,166,1,166,3,166,2050,8,166,1,167,
        1,167,1,167,3,167,2055,8,167,1,168,1,168,1,168,1,168,1,169,1,169,
        1,169,5,169,2064,8,169,10,169,12,169,2067,9,169,1,170,1,170,1,170,
        1,170,1,170,1,170,3,170,2075,8,170,1,171,1,171,1,171,3,171,2080,
        8,171,1,172,1,172,1,172,3,172,2085,8,172,1,173,1,173,1,173,3,173,
        2090,8,173,1,174,1,174,1,174,3,174,2095,8,174,1,174,3,174,2098,8,
        174,1,175,1,175,1,175,1,176,1,176,1,176,1,177,1,177,3,177,2108,8,
        177,1,177,3,177,2111,8,177,1,177,1,177,3,177,2115,8,177,1,177,1,
        177,1,178,1,178,3,178,2121,8,178,1,178,1,178,3,178,2125,8,178,1,
        178,3,178,2128,8,178,1,179,1,179,1,179,1,180,4,180,2134,8,180,11,
        180,12,180,2135,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,
        1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,
        1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,
        1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,3,181,2176,8,181,
        1,182,1,182,1,182,1,182,1,182,1,182,1,182,1,183,1,183,1,183,1,183,
        1,183,1,183,5,183,2191,8,183,10,183,12,183,2194,9,183,1,183,1,183,
        3,183,2198,8,183,1,183,3,183,2201,8,183,1,183,1,183,1,183,1,183,
        3,183,2207,8,183,1,183,1,183,1,184,1,184,1,184,3,184,2214,8,184,
        1,184,1,184,1,184,1,184,3,184,2220,8,184,5,184,2222,8,184,10,184,
        12,184,2225,9,184,1,184,3,184,2228,8,184,1,184,3,184,2231,8,184,
        1,185,1,185,1,185,1,185,1,185,1,185,1,186,1,186,3,186,2241,8,186,
        1,186,1,186,1,186,3,186,2246,8,186,5,186,2248,8,186,10,186,12,186,
        2251,9,186,1,186,1,186,1,186,1,186,3,186,2257,8,186,1,187,1,187,
        1,187,1,187,1,187,1,187,3,187,2265,8,187,1,188,1,188,1,188,5,188,
        2270,8,188,10,188,12,188,2273,9,188,3,188,2275,8,188,1,189,1,189,
        1,189,1,189,1,189,5,189,2282,8,189,10,189,12,189,2285,9,189,1,190,
        1,190,1,190,1,190,1,190,1,190,1,190,1,190,3,190,2295,8,190,1,191,
        1,191,1,192,1,192,1,192,1,192,1,192,1,192,3,192,2305,8,192,1,192,
        1,192,1,192,3,192,2310,8,192,5,192,2312,8,192,10,192,12,192,2315,
        9,192,1,192,3,192,2318,8,192,1,192,3,192,2321,8,192,1,192,1,192,
        1,192,1,192,3,192,2327,8,192,1,192,1,192,1,193,1,193,1,193,1,193,
        1,193,1,193,3,193,2337,8,193,1,193,1,193,1,193,3,193,2342,8,193,
        5,193,2344,8,193,10,193,12,193,2347,9,193,1,193,3,193,2350,8,193,
        1,193,3,193,2353,8,193,1,193,1,193,1,193,1,193,3,193,2359,8,193,
        1,193,1,193,1,194,3,194,2364,8,194,1,194,1,194,3,194,2368,8,194,
        1,194,1,194,1,194,5,194,2373,8,194,10,194,12,194,2376,9,194,1,194,
        3,194,2379,8,194,1,194,1,194,1,194,1,194,3,194,2385,8,194,1,194,
        3,194,2388,8,194,1,195,1,195,1,195,1,195,1,196,1,196,1,196,3,196,
        2397,8,196,1,196,1,196,5,196,2401,8,196,10,196,12,196,2404,9,196,
        1,196,3,196,2407,8,196,1,196,3,196,2410,8,196,1,197,1,197,1,197,
        1,197,3,197,2416,8,197,1,197,1,197,1,197,1,197,1,197,3,197,2423,
        8,197,1,198,1,198,1,198,3,198,2428,8,198,1,198,1,198,3,198,2432,
        8,198,1,198,1,198,1,198,1,198,3,198,2438,8,198,1,198,1,198,3,198,
        2442,8,198,1,198,1,198,1,198,1,198,3,198,2448,8,198,1,198,1,198,
        1,198,1,198,3,198,2454,8,198,1,198,1,198,1,198,1,198,1,198,3,198,
        2461,8,198,1,198,3,198,2464,8,198,1,198,3,198,2467,8,198,1,198,3,
        198,2470,8,198,1,199,1,199,1,199,1,199,1,199,1,199,3,199,2478,8,
        199,4,199,2480,8,199,11,199,12,199,2481,1,200,1,200,1,200,1,200,
        1,200,1,200,5,200,2490,8,200,10,200,12,200,2493,9,200,1,200,1,200,
        3,200,2497,8,200,1,201,1,201,1,201,1,201,1,201,1,201,5,201,2505,
        8,201,10,201,12,201,2508,9,201,1,201,1,201,3,201,2512,8,201,1,202,
        1,202,1,203,1,203,1,204,1,204,1,205,1,205,1,205,3,205,2523,8,205,
        1,205,1,205,1,205,3,205,2528,8,205,3,205,2530,8,205,1,205,3,205,
        2533,8,205,1,205,1,205,1,205,1,205,3,205,2539,8,205,1,205,3,205,
        2542,8,205,1,205,1,205,1,205,1,205,3,205,2548,8,205,1,205,1,205,
        3,205,2552,8,205,1,205,3,205,2555,8,205,1,206,1,206,1,206,1,206,
        1,206,3,206,2562,8,206,1,206,3,206,2565,8,206,1,206,1,206,1,206,
        1,206,3,206,2571,8,206,1,206,1,206,1,206,1,206,1,206,1,206,1,206,
        1,206,1,206,5,206,2582,8,206,10,206,12,206,2585,9,206,1,206,1,206,
        5,206,2589,8,206,10,206,12,206,2592,9,206,1,206,5,206,2595,8,206,
        10,206,12,206,2598,9,206,1,206,1,206,1,206,1,206,1,206,3,206,2605,
        8,206,1,206,1,206,1,206,1,206,1,206,1,206,3,206,2613,8,206,1,206,
        1,206,1,206,3,206,2618,8,206,1,207,1,207,3,207,2622,8,207,1,207,
        1,207,1,207,1,207,1,207,1,207,3,207,2630,8,207,3,207,2632,8,207,
        1,207,1,207,1,207,1,207,1,207,1,207,3,207,2640,8,207,3,207,2642,
        8,207,5,207,2644,8,207,10,207,12,207,2647,9,207,1,207,1,207,1,208,
        1,208,1,208,1,208,5,208,2655,8,208,10,208,12,208,2658,9,208,3,208,
        2660,8,208,1,208,1,208,1,209,1,209,1,209,1,209,1,209,1,209,1,209,
        1,209,1,209,1,209,1,209,3,209,2675,8,209,1,210,1,210,1,210,3,210,
        2680,8,210,1,211,1,211,1,211,1,211,1,211,1,211,1,211,3,211,2689,
        8,211,1,211,1,211,1,211,3,211,2694,8,211,1,212,1,212,1,212,1,212,
        3,212,2700,8,212,1,213,1,213,1,213,1,213,3,213,2706,8,213,1,213,
        1,213,1,214,1,214,1,214,1,214,1,214,1,214,1,214,1,214,1,214,1,214,
        3,214,2720,8,214,1,215,3,215,2723,8,215,1,215,1,215,1,215,5,215,
        2728,8,215,10,215,12,215,2731,9,215,1,215,3,215,2734,8,215,1,216,
        1,216,1,216,5,216,2739,8,216,10,216,12,216,2742,9,216,1,217,1,217,
        1,217,1,217,1,217,1,217,1,217,1,217,1,217,1,217,1,217,1,217,3,217,
        2756,8,217,1,218,1,218,1,218,1,218,3,218,2762,8,218,1,219,1,219,
        1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,3,219,2775,
        8,219,1,220,1,220,1,220,1,220,1,220,3,220,2782,8,220,1,220,1,220,
        1,221,1,221,1,221,1,221,1,221,1,222,1,222,1,222,1,222,1,222,1,223,
        1,223,1,224,1,224,1,224,1,224,1,224,1,224,3,224,2804,8,224,1,224,
        1,224,1,225,1,225,1,225,1,225,1,225,1,225,3,225,2814,8,225,1,225,
        1,225,1,226,1,226,1,226,3,226,2821,8,226,1,226,1,226,3,226,2825,
        8,226,1,226,1,226,1,226,1,226,1,227,1,227,1,227,1,227,1,227,1,227,
        1,227,1,228,1,228,3,228,2840,8,228,1,228,1,228,1,228,1,228,3,228,
        2846,8,228,1,228,1,228,1,229,1,229,1,229,1,229,3,229,2854,8,229,
        1,229,1,229,1,229,3,229,2859,8,229,1,229,1,229,1,230,1,230,1,230,
        1,230,1,230,5,230,2868,8,230,10,230,12,230,2871,9,230,1,230,1,230,
        1,231,1,231,3,231,2877,8,231,1,231,3,231,2880,8,231,1,232,1,232,
        1,232,1,232,1,232,5,232,2887,8,232,10,232,12,232,2890,9,232,1,232,
        1,232,1,233,1,233,3,233,2896,8,233,1,233,3,233,2899,8,233,1,234,
        1,234,1,234,1,234,1,234,1,234,1,234,3,234,2908,8,234,1,234,1,234,
        4,234,2912,8,234,11,234,12,234,2913,1,235,1,235,1,235,1,235,4,235,
        2920,8,235,11,235,12,235,2921,1,236,1,236,3,236,2926,8,236,1,236,
        1,236,3,236,2930,8,236,1,236,3,236,2933,8,236,1,237,1,237,1,237,
        1,237,1,237,1,237,1,238,1,238,1,238,1,238,3,238,2945,8,238,1,238,
        3,238,2948,8,238,1,238,3,238,2951,8,238,1,238,3,238,2954,8,238,1,
        238,3,238,2957,8,238,1,238,3,238,2960,8,238,1,239,1,239,1,239,1,
        239,1,239,3,239,2967,8,239,1,239,3,239,2970,8,239,1,240,1,240,1,
        240,3,240,2975,8,240,1,240,3,240,2978,8,240,1,241,1,241,1,241,1,
        241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,
        1,241,1,241,1,241,1,241,3,241,2998,8,241,1,241,1,241,3,241,3002,
        8,241,1,241,1,241,1,241,3,241,3007,8,241,1,242,1,242,1,242,1,242,
        3,242,3013,8,242,1,242,1,242,1,242,1,242,1,243,1,243,1,243,1,243,
        1,243,1,243,1,243,1,244,1,244,1,245,1,245,1,246,1,246,1,247,1,247,
        1,248,1,248,1,249,1,249,1,250,1,250,3,250,3040,8,250,1,250,1,250,
        1,250,1,250,1,250,3,250,3047,8,250,1,250,3,250,3050,8,250,1,250,
        1,250,1,250,1,250,1,250,1,250,1,250,1,250,1,250,1,250,5,250,3062,
        8,250,10,250,12,250,3065,9,250,1,250,3,250,3068,8,250,1,250,3,250,
        3071,8,250,1,250,1,250,1,250,1,250,3,250,3077,8,250,1,250,3,250,
        3080,8,250,3,250,3082,8,250,1,251,3,251,3085,8,251,1,251,1,251,1,
        251,5,251,3090,8,251,10,251,12,251,3093,9,251,1,252,1,252,1,253,
        1,253,1,253,3,253,3100,8,253,1,253,1,253,5,253,3104,8,253,10,253,
        12,253,3107,9,253,1,253,3,253,3110,8,253,1,253,3,253,3113,8,253,
        1,253,3,253,3116,8,253,1,254,1,254,1,254,1,254,1,254,1,254,1,254,
        1,254,3,254,3126,8,254,1,254,1,254,1,254,1,254,3,254,3132,8,254,
        1,254,3,254,3135,8,254,1,254,3,254,3138,8,254,1,255,1,255,1,255,
        1,255,1,255,1,255,3,255,3146,8,255,1,256,1,256,1,256,1,256,1,256,
        1,257,1,257,1,258,1,258,1,258,1,258,3,258,3159,8,258,1,259,1,259,
        1,260,1,260,1,260,1,260,1,260,1,261,1,261,1,262,1,262,1,262,3,262,
        3173,8,262,1,262,3,262,3176,8,262,1,263,1,263,3,263,3180,8,263,1,
        264,1,264,1,264,1,264,1,264,5,264,3187,8,264,10,264,12,264,3190,
        9,264,1,264,1,264,1,264,1,265,1,265,1,266,1,266,1,266,1,266,3,266,
        3201,8,266,1,266,1,266,1,266,3,266,3206,8,266,5,266,3208,8,266,10,
        266,12,266,3211,9,266,1,266,1,266,1,266,1,267,1,267,1,267,1,267,
        3,267,3220,8,267,1,267,1,267,1,267,1,267,3,267,3226,8,267,1,267,
        1,267,1,267,1,267,3,267,3232,8,267,1,267,1,267,3,267,3236,8,267,
        1,267,1,267,1,267,1,267,1,267,3,267,3243,8,267,1,268,1,268,1,268,
        1,268,3,268,3249,8,268,3,268,3251,8,268,1,269,1,269,1,269,5,269,
        3256,8,269,10,269,12,269,3259,9,269,1,270,1,270,1,270,1,270,1,270,
        1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,1,270,
        3,270,3277,8,270,1,271,1,271,1,272,1,272,1,273,1,273,1,274,1,274,
        1,275,1,275,1,275,5,275,3290,8,275,10,275,12,275,3293,9,275,1,276,
        1,276,1,276,1,276,3,276,3299,8,276,1,277,1,277,1,277,1,277,1,277,
        3,277,3306,8,277,1,277,1,277,1,278,1,278,1,278,1,278,3,278,3314,
        8,278,1,278,1,278,1,278,1,278,1,278,3,278,3321,8,278,1,278,1,278,
        1,278,3,278,3326,8,278,1,279,1,279,3,279,3330,8,279,1,280,3,280,
        3333,8,280,1,280,3,280,3336,8,280,1,280,1,280,3,280,3340,8,280,1,
        280,1,280,3,280,3344,8,280,1,280,3,280,3347,8,280,1,280,1,280,3,
        280,3351,8,280,5,280,3353,8,280,10,280,12,280,3356,9,280,1,281,1,
        281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,
        1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,281,1,282,
        1,282,1,282,3,282,3383,8,282,1,283,1,283,1,283,1,283,1,283,3,283,
        3390,8,283,1,283,4,283,3393,8,283,11,283,12,283,3394,1,283,1,283,
        3,283,3399,8,283,3,283,3401,8,283,1,284,1,284,1,284,1,284,1,284,
        3,284,3408,8,284,1,284,4,284,3411,8,284,11,284,12,284,3412,1,284,
        1,284,3,284,3417,8,284,3,284,3419,8,284,1,285,1,285,1,285,1,285,
        3,285,3425,8,285,1,285,1,285,3,285,3429,8,285,1,285,1,285,3,285,
        3433,8,285,1,285,1,285,1,285,3,285,3438,8,285,1,285,1,285,1,285,
        3,285,3443,8,285,1,285,1,285,3,285,3447,8,285,3,285,3449,8,285,1,
        285,3,285,3452,8,285,1,285,1,285,1,285,1,285,3,285,3458,8,285,1,
        286,1,286,1,286,1,286,1,286,1,286,1,286,1,286,1,286,1,286,1,286,
        3,286,3471,8,286,1,286,1,286,1,286,1,286,1,286,3,286,3478,8,286,
        1,286,1,286,3,286,3482,8,286,1,286,1,286,3,286,3486,8,286,3,286,
        3488,8,286,1,286,1,286,1,286,1,286,1,286,1,286,1,286,3,286,3497,
        8,286,1,286,1,286,3,286,3501,8,286,1,286,1,286,1,286,1,286,1,286,
        1,286,1,286,3,286,3510,8,286,1,286,1,286,3,286,3514,8,286,1,286,
        1,286,1,286,3,286,3519,8,286,1,286,1,286,3,286,3523,8,286,1,286,
        1,286,3,286,3527,8,286,1,286,1,286,1,286,1,286,1,286,1,286,1,286,
        1,286,1,286,1,286,1,286,1,286,3,286,3541,8,286,1,286,1,286,1,286,
        3,286,3546,8,286,1,286,1,286,3,286,3550,8,286,3,286,3552,8,286,1,
        286,3,286,3555,8,286,1,286,1,286,3,286,3559,8,286,1,286,1,286,3,
        286,3563,8,286,1,286,1,286,1,286,3,286,3568,8,286,1,286,1,286,3,
        286,3572,8,286,3,286,3574,8,286,3,286,3576,8,286,1,287,1,287,1,288,
        1,288,3,288,3582,8,288,1,288,1,288,3,288,3586,8,288,1,288,3,288,
        3589,8,288,1,288,1,288,1,288,1,288,1,289,1,289,1,289,1,289,1,289,
        4,289,3600,8,289,11,289,12,289,3601,1,289,1,289,1,289,3,289,3607,
        8,289,1,289,1,289,1,290,1,290,1,290,1,290,1,290,1,290,1,290,3,290,
        3618,8,290,1,290,3,290,3621,8,290,1,290,5,290,3624,8,290,10,290,
        12,290,3627,9,290,1,290,3,290,3630,8,290,1,290,3,290,3633,8,290,
        3,290,3635,8,290,1,290,1,290,1,290,1,291,1,291,1,291,3,291,3643,
        8,291,1,292,4,292,3646,8,292,11,292,12,292,3647,1,293,1,293,1,293,
        1,293,1,293,1,293,4,293,3656,8,293,11,293,12,293,3657,1,293,1,293,
        1,293,3,293,3663,8,293,1,293,3,293,3666,8,293,1,294,1,294,1,294,
        1,294,5,294,3672,8,294,10,294,12,294,3675,9,294,3,294,3677,8,294,
        1,295,1,295,1,295,3,295,3682,8,295,1,295,1,295,3,295,3686,8,295,
        1,295,1,295,1,295,1,295,1,295,1,296,1,296,1,297,1,297,1,298,1,298,
        1,298,5,298,3700,8,298,10,298,12,298,3703,9,298,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,3,299,3782,8,299,
        1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,1,299,
        1,299,3,299,3796,8,299,1,300,1,300,1,300,1,300,3,300,3802,8,300,
        1,301,1,301,1,301,1,301,1,301,1,301,3,301,3810,8,301,1,301,1,301,
        1,301,1,301,1,301,1,301,3,301,3818,8,301,1,301,1,301,1,301,1,301,
        1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,
        1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,
        1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,
        1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,1,301,
        3,301,3868,8,301,1,302,1,302,1,303,1,303,1,304,1,304,1,305,1,305,
        1,306,1,306,1,306,1,306,3,306,3882,8,306,1,306,1,306,1,306,3,306,
        3887,8,306,1,306,1,306,1,307,1,307,3,307,3893,8,307,1,308,1,308,
        1,308,1,308,1,308,1,308,1,309,1,309,3,309,3903,8,309,1,309,1,309,
        1,309,1,310,1,310,1,311,1,311,1,311,3,311,3913,8,311,1,311,1,311,
        1,311,3,311,3918,8,311,3,311,3920,8,311,1,311,3,311,3923,8,311,1,
        311,1,311,1,311,1,311,3,311,3929,8,311,1,311,3,311,3932,8,311,1,
        311,1,311,1,311,1,311,3,311,3938,8,311,1,311,1,311,3,311,3942,8,
        311,1,311,1,311,1,311,3,311,3947,8,311,1,312,1,312,1,312,1,313,1,
        313,1,313,1,313,5,313,3956,8,313,10,313,12,313,3959,9,313,1,313,
        1,313,3,313,3963,8,313,1,313,3,313,3966,8,313,1,314,1,314,1,314,
        1,314,3,314,3972,8,314,1,314,1,314,1,314,1,314,5,314,3978,8,314,
        10,314,12,314,3981,9,314,1,314,1,314,3,314,3985,8,314,1,315,1,315,
        1,315,1,315,3,315,3991,8,315,1,315,1,315,1,315,1,315,1,315,1,315,
        3,315,3999,8,315,3,315,4001,8,315,1,316,1,316,1,316,1,316,1,316,
        1,316,3,316,4009,8,316,1,316,1,316,1,316,1,316,5,316,4015,8,316,
        10,316,12,316,4018,9,316,1,316,1,316,3,316,4022,8,316,1,317,1,317,
        1,317,1,317,3,317,4028,8,317,1,317,1,317,1,317,1,317,1,317,1,317,
        1,317,1,317,1,317,1,317,1,317,1,317,1,317,3,317,4043,8,317,1,317,
        1,317,5,317,4047,8,317,10,317,12,317,4050,9,317,1,317,1,317,1,317,
        3,317,4055,8,317,3,317,4057,8,317,1,318,1,318,1,318,1,318,1,318,
        4,318,4064,8,318,11,318,12,318,4065,1,318,1,318,3,318,4070,8,318,
        1,318,3,318,4073,8,318,3,318,4075,8,318,1,319,1,319,1,319,3,319,
        4080,8,319,1,319,1,319,1,319,3,319,4085,8,319,1,319,1,319,1,319,
        1,319,3,319,4091,8,319,3,319,4093,8,319,1,319,3,319,4096,8,319,1,
        320,1,320,1,320,1,320,1,320,1,320,1,321,1,321,1,321,1,321,1,321,
        1,321,1,322,1,322,1,322,1,322,1,322,1,322,1,323,1,323,3,323,4118,
        8,323,1,323,1,323,1,323,1,323,1,323,3,323,4125,8,323,1,323,1,323,
        3,323,4129,8,323,1,323,1,323,1,324,3,324,4134,8,324,1,324,1,324,
        1,324,5,324,4139,8,324,10,324,12,324,4142,9,324,1,325,1,325,1,325,
        3,325,4147,8,325,1,325,3,325,4150,8,325,1,325,1,325,1,326,1,326,
        1,326,3,326,4157,8,326,1,327,1,327,1,327,5,327,4162,8,327,10,327,
        12,327,4165,9,327,1,328,1,328,1,328,1,328,1,328,1,328,1,328,3,328,
        4174,8,328,1,329,1,329,1,329,0,0,330,0,2,4,6,8,10,12,14,16,18,20,
        22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,
        66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
        108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
        140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,
        172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,
        204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,
        236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,
        268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,
        300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,
        332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,
        364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,
        396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,
        428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,
        460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,
        492,494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,
        524,526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,
        556,558,560,562,564,566,568,570,572,574,576,578,580,582,584,586,
        588,590,592,594,596,598,600,602,604,606,608,610,612,614,616,618,
        620,622,624,626,628,630,632,634,636,638,640,642,644,646,648,650,
        652,654,656,658,0,55,3,0,230,232,235,235,238,238,1,0,446,447,1,0,
        295,301,2,0,302,311,313,314,4,0,201,201,209,209,211,211,219,219,
        1,0,69,70,2,0,56,56,446,446,2,0,55,55,446,446,1,0,447,448,2,0,351,
        351,446,446,1,0,233,234,2,0,364,364,446,446,2,0,75,75,446,446,2,
        0,63,63,92,92,1,0,25,26,2,0,93,94,446,446,1,0,93,94,2,0,446,447,
        449,449,1,0,446,449,3,0,68,68,433,434,444,444,1,0,397,398,2,0,99,
        99,418,425,1,0,403,406,5,0,133,133,249,249,283,283,409,417,442,442,
        3,0,104,104,209,209,443,443,11,0,32,39,187,187,192,192,207,208,210,
        210,220,223,228,228,315,342,346,389,438,438,442,442,3,0,239,239,
        245,245,446,446,3,0,113,113,419,419,422,422,2,0,195,195,291,291,
        2,0,40,44,177,186,2,0,190,190,213,213,2,0,52,52,446,446,2,0,53,53,
        418,418,3,0,27,28,47,47,312,312,3,0,123,128,130,130,449,449,2,0,
        1,1,27,27,1,0,270,271,3,0,120,120,165,165,437,437,2,0,58,58,166,
        170,3,0,32,39,342,342,349,349,3,0,286,286,363,363,397,398,3,0,364,
        364,366,366,368,368,2,0,342,342,349,349,2,0,23,24,171,176,2,0,1,
        1,163,163,3,0,153,155,157,162,282,282,1,0,278,279,2,0,122,122,163,
        163,4,0,120,120,165,165,247,247,437,437,2,0,67,67,71,71,1,0,148,
        152,2,0,446,446,449,449,2,0,48,48,377,377,5,0,46,46,153,155,157,
        157,160,161,282,282,56,0,46,47,52,54,56,59,61,66,69,70,72,72,75,
        77,79,81,83,83,86,87,89,89,91,96,101,103,105,105,113,117,119,119,
        124,124,130,131,156,156,177,177,182,182,189,189,195,195,200,200,
        202,202,205,205,209,209,217,217,226,226,228,228,233,234,236,236,
        240,240,244,244,249,250,254,256,258,258,260,260,262,268,275,275,
        278,278,283,284,287,290,293,293,295,295,305,305,312,312,339,339,
        343,345,350,350,360,360,391,391,394,394,398,398,418,418,444,444,
        4676,0,662,1,0,0,0,2,666,1,0,0,0,4,677,1,0,0,0,6,694,1,0,0,0,8,696,
        1,0,0,0,10,702,1,0,0,0,12,710,1,0,0,0,14,718,1,0,0,0,16,727,1,0,
        0,0,18,730,1,0,0,0,20,790,1,0,0,0,22,792,1,0,0,0,24,795,1,0,0,0,
        26,813,1,0,0,0,28,816,1,0,0,0,30,837,1,0,0,0,32,839,1,0,0,0,34,844,
        1,0,0,0,36,851,1,0,0,0,38,859,1,0,0,0,40,861,1,0,0,0,42,866,1,0,
        0,0,44,871,1,0,0,0,46,911,1,0,0,0,48,913,1,0,0,0,50,917,1,0,0,0,
        52,944,1,0,0,0,54,946,1,0,0,0,56,948,1,0,0,0,58,950,1,0,0,0,60,952,
        1,0,0,0,62,954,1,0,0,0,64,956,1,0,0,0,66,958,1,0,0,0,68,960,1,0,
        0,0,70,962,1,0,0,0,72,965,1,0,0,0,74,970,1,0,0,0,76,975,1,0,0,0,
        78,980,1,0,0,0,80,985,1,0,0,0,82,990,1,0,0,0,84,995,1,0,0,0,86,1014,
        1,0,0,0,88,1016,1,0,0,0,90,1021,1,0,0,0,92,1026,1,0,0,0,94,1031,
        1,0,0,0,96,1036,1,0,0,0,98,1041,1,0,0,0,100,1047,1,0,0,0,102,1061,
        1,0,0,0,104,1064,1,0,0,0,106,1121,1,0,0,0,108,1125,1,0,0,0,110,1154,
        1,0,0,0,112,1158,1,0,0,0,114,1165,1,0,0,0,116,1177,1,0,0,0,118,1188,
        1,0,0,0,120,1199,1,0,0,0,122,1215,1,0,0,0,124,1219,1,0,0,0,126,1231,
        1,0,0,0,128,1234,1,0,0,0,130,1251,1,0,0,0,132,1253,1,0,0,0,134,1259,
        1,0,0,0,136,1264,1,0,0,0,138,1271,1,0,0,0,140,1278,1,0,0,0,142,1289,
        1,0,0,0,144,1295,1,0,0,0,146,1303,1,0,0,0,148,1313,1,0,0,0,150,1315,
        1,0,0,0,152,1319,1,0,0,0,154,1336,1,0,0,0,156,1338,1,0,0,0,158,1359,
        1,0,0,0,160,1361,1,0,0,0,162,1370,1,0,0,0,164,1372,1,0,0,0,166,1390,
        1,0,0,0,168,1392,1,0,0,0,170,1396,1,0,0,0,172,1403,1,0,0,0,174,1407,
        1,0,0,0,176,1411,1,0,0,0,178,1422,1,0,0,0,180,1426,1,0,0,0,182,1430,
        1,0,0,0,184,1433,1,0,0,0,186,1444,1,0,0,0,188,1449,1,0,0,0,190,1455,
        1,0,0,0,192,1458,1,0,0,0,194,1467,1,0,0,0,196,1471,1,0,0,0,198,1473,
        1,0,0,0,200,1479,1,0,0,0,202,1487,1,0,0,0,204,1491,1,0,0,0,206,1496,
        1,0,0,0,208,1500,1,0,0,0,210,1504,1,0,0,0,212,1509,1,0,0,0,214,1517,
        1,0,0,0,216,1521,1,0,0,0,218,1535,1,0,0,0,220,1539,1,0,0,0,222,1543,
        1,0,0,0,224,1560,1,0,0,0,226,1573,1,0,0,0,228,1576,1,0,0,0,230,1595,
        1,0,0,0,232,1606,1,0,0,0,234,1622,1,0,0,0,236,1626,1,0,0,0,238,1646,
        1,0,0,0,240,1648,1,0,0,0,242,1664,1,0,0,0,244,1692,1,0,0,0,246,1694,
        1,0,0,0,248,1704,1,0,0,0,250,1760,1,0,0,0,252,1762,1,0,0,0,254,1779,
        1,0,0,0,256,1781,1,0,0,0,258,1783,1,0,0,0,260,1785,1,0,0,0,262,1787,
        1,0,0,0,264,1789,1,0,0,0,266,1791,1,0,0,0,268,1793,1,0,0,0,270,1795,
        1,0,0,0,272,1797,1,0,0,0,274,1799,1,0,0,0,276,1801,1,0,0,0,278,1836,
        1,0,0,0,280,1838,1,0,0,0,282,1864,1,0,0,0,284,1872,1,0,0,0,286,1874,
        1,0,0,0,288,1885,1,0,0,0,290,1899,1,0,0,0,292,1910,1,0,0,0,294,1915,
        1,0,0,0,296,1917,1,0,0,0,298,1928,1,0,0,0,300,1936,1,0,0,0,302,1938,
        1,0,0,0,304,1949,1,0,0,0,306,1961,1,0,0,0,308,1963,1,0,0,0,310,1976,
        1,0,0,0,312,1982,1,0,0,0,314,1995,1,0,0,0,316,1997,1,0,0,0,318,2006,
        1,0,0,0,320,2008,1,0,0,0,322,2023,1,0,0,0,324,2025,1,0,0,0,326,2029,
        1,0,0,0,328,2033,1,0,0,0,330,2037,1,0,0,0,332,2041,1,0,0,0,334,2054,
        1,0,0,0,336,2056,1,0,0,0,338,2060,1,0,0,0,340,2074,1,0,0,0,342,2076,
        1,0,0,0,344,2081,1,0,0,0,346,2086,1,0,0,0,348,2091,1,0,0,0,350,2099,
        1,0,0,0,352,2102,1,0,0,0,354,2105,1,0,0,0,356,2118,1,0,0,0,358,2129,
        1,0,0,0,360,2133,1,0,0,0,362,2175,1,0,0,0,364,2177,1,0,0,0,366,2184,
        1,0,0,0,368,2213,1,0,0,0,370,2232,1,0,0,0,372,2240,1,0,0,0,374,2258,
        1,0,0,0,376,2274,1,0,0,0,378,2276,1,0,0,0,380,2294,1,0,0,0,382,2296,
        1,0,0,0,384,2298,1,0,0,0,386,2330,1,0,0,0,388,2363,1,0,0,0,390,2389,
        1,0,0,0,392,2396,1,0,0,0,394,2411,1,0,0,0,396,2424,1,0,0,0,398,2479,
        1,0,0,0,400,2483,1,0,0,0,402,2498,1,0,0,0,404,2513,1,0,0,0,406,2515,
        1,0,0,0,408,2517,1,0,0,0,410,2519,1,0,0,0,412,2617,1,0,0,0,414,2619,
        1,0,0,0,416,2650,1,0,0,0,418,2674,1,0,0,0,420,2676,1,0,0,0,422,2693,
        1,0,0,0,424,2699,1,0,0,0,426,2701,1,0,0,0,428,2719,1,0,0,0,430,2722,
        1,0,0,0,432,2735,1,0,0,0,434,2755,1,0,0,0,436,2761,1,0,0,0,438,2774,
        1,0,0,0,440,2776,1,0,0,0,442,2785,1,0,0,0,444,2790,1,0,0,0,446,2795,
        1,0,0,0,448,2797,1,0,0,0,450,2807,1,0,0,0,452,2817,1,0,0,0,454,2830,
        1,0,0,0,456,2839,1,0,0,0,458,2849,1,0,0,0,460,2862,1,0,0,0,462,2879,
        1,0,0,0,464,2881,1,0,0,0,466,2898,1,0,0,0,468,2907,1,0,0,0,470,2919,
        1,0,0,0,472,2923,1,0,0,0,474,2934,1,0,0,0,476,2940,1,0,0,0,478,2961,
        1,0,0,0,480,2977,1,0,0,0,482,3006,1,0,0,0,484,3008,1,0,0,0,486,3018,
        1,0,0,0,488,3025,1,0,0,0,490,3027,1,0,0,0,492,3029,1,0,0,0,494,3031,
        1,0,0,0,496,3033,1,0,0,0,498,3035,1,0,0,0,500,3081,1,0,0,0,502,3084,
        1,0,0,0,504,3094,1,0,0,0,506,3099,1,0,0,0,508,3117,1,0,0,0,510,3145,
        1,0,0,0,512,3147,1,0,0,0,514,3152,1,0,0,0,516,3154,1,0,0,0,518,3160,
        1,0,0,0,520,3162,1,0,0,0,522,3167,1,0,0,0,524,3169,1,0,0,0,526,3179,
        1,0,0,0,528,3181,1,0,0,0,530,3194,1,0,0,0,532,3196,1,0,0,0,534,3215,
        1,0,0,0,536,3250,1,0,0,0,538,3252,1,0,0,0,540,3276,1,0,0,0,542,3278,
        1,0,0,0,544,3280,1,0,0,0,546,3282,1,0,0,0,548,3284,1,0,0,0,550,3286,
        1,0,0,0,552,3298,1,0,0,0,554,3300,1,0,0,0,556,3325,1,0,0,0,558,3329,
        1,0,0,0,560,3332,1,0,0,0,562,3357,1,0,0,0,564,3379,1,0,0,0,566,3400,
        1,0,0,0,568,3418,1,0,0,0,570,3457,1,0,0,0,572,3575,1,0,0,0,574,3577,
        1,0,0,0,576,3579,1,0,0,0,578,3594,1,0,0,0,580,3610,1,0,0,0,582,3642,
        1,0,0,0,584,3645,1,0,0,0,586,3649,1,0,0,0,588,3676,1,0,0,0,590,3678,
        1,0,0,0,592,3692,1,0,0,0,594,3694,1,0,0,0,596,3696,1,0,0,0,598,3795,
        1,0,0,0,600,3801,1,0,0,0,602,3867,1,0,0,0,604,3869,1,0,0,0,606,3871,
        1,0,0,0,608,3873,1,0,0,0,610,3875,1,0,0,0,612,3877,1,0,0,0,614,3892,
        1,0,0,0,616,3894,1,0,0,0,618,3900,1,0,0,0,620,3907,1,0,0,0,622,3909,
        1,0,0,0,624,3948,1,0,0,0,626,3951,1,0,0,0,628,3967,1,0,0,0,630,3990,
        1,0,0,0,632,4002,1,0,0,0,634,4027,1,0,0,0,636,4058,1,0,0,0,638,4076,
        1,0,0,0,640,4097,1,0,0,0,642,4103,1,0,0,0,644,4109,1,0,0,0,646,4115,
        1,0,0,0,648,4133,1,0,0,0,650,4143,1,0,0,0,652,4156,1,0,0,0,654,4158,
        1,0,0,0,656,4173,1,0,0,0,658,4175,1,0,0,0,660,663,3,2,1,0,661,663,
        3,360,180,0,662,660,1,0,0,0,662,661,1,0,0,0,663,664,1,0,0,0,664,
        665,5,0,0,1,665,1,1,0,0,0,666,668,3,4,2,0,667,669,3,28,14,0,668,
        667,1,0,0,0,668,669,1,0,0,0,669,671,1,0,0,0,670,672,3,100,50,0,671,
        670,1,0,0,0,671,672,1,0,0,0,672,673,1,0,0,0,673,674,3,360,180,0,
        674,675,3,18,9,0,675,3,1,0,0,0,676,678,5,22,0,0,677,676,1,0,0,0,
        677,678,1,0,0,0,678,681,1,0,0,0,679,680,5,188,0,0,680,682,3,6,3,
        0,681,679,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,683,684,5,193,
        0,0,684,687,5,217,0,0,685,688,3,20,10,0,686,688,5,262,0,0,687,685,
        1,0,0,0,687,686,1,0,0,0,687,688,1,0,0,0,688,690,1,0,0,0,689,691,
        3,8,4,0,690,689,1,0,0,0,690,691,1,0,0,0,691,692,1,0,0,0,692,693,
        5,20,0,0,693,5,1,0,0,0,694,695,5,446,0,0,695,7,1,0,0,0,696,698,5,
        12,0,0,697,699,3,10,5,0,698,697,1,0,0,0,698,699,1,0,0,0,699,700,
        1,0,0,0,700,701,5,13,0,0,701,9,1,0,0,0,702,707,3,12,6,0,703,704,
        5,4,0,0,704,706,3,12,6,0,705,703,1,0,0,0,706,709,1,0,0,0,707,705,
        1,0,0,0,707,708,1,0,0,0,708,11,1,0,0,0,709,707,1,0,0,0,710,713,3,
        16,8,0,711,714,5,446,0,0,712,714,3,658,329,0,713,711,1,0,0,0,713,
        712,1,0,0,0,714,716,1,0,0,0,715,717,3,14,7,0,716,715,1,0,0,0,716,
        717,1,0,0,0,717,13,1,0,0,0,718,719,5,121,0,0,719,720,5,390,0,0,720,
        725,5,29,0,0,721,726,3,436,218,0,722,726,3,420,210,0,723,726,3,422,
        211,0,724,726,3,294,147,0,725,721,1,0,0,0,725,722,1,0,0,0,725,723,
        1,0,0,0,725,724,1,0,0,0,726,15,1,0,0,0,727,728,7,0,0,0,728,17,1,
        0,0,0,729,731,5,22,0,0,730,729,1,0,0,0,730,731,1,0,0,0,731,732,1,
        0,0,0,732,733,5,204,0,0,733,735,5,217,0,0,734,736,5,19,0,0,735,734,
        1,0,0,0,735,736,1,0,0,0,736,738,1,0,0,0,737,739,5,20,0,0,738,737,
        1,0,0,0,738,739,1,0,0,0,739,19,1,0,0,0,740,741,5,12,0,0,741,742,
        3,24,12,0,742,743,5,13,0,0,743,745,1,0,0,0,744,740,1,0,0,0,744,745,
        1,0,0,0,745,748,1,0,0,0,746,749,3,24,12,0,747,749,5,29,0,0,748,746,
        1,0,0,0,748,747,1,0,0,0,749,755,1,0,0,0,750,751,5,12,0,0,751,752,
        3,24,12,0,752,753,5,13,0,0,753,755,1,0,0,0,754,744,1,0,0,0,754,750,
        1,0,0,0,755,762,1,0,0,0,756,758,5,27,0,0,757,759,3,24,12,0,758,757,
        1,0,0,0,758,759,1,0,0,0,759,761,1,0,0,0,760,756,1,0,0,0,761,764,
        1,0,0,0,762,760,1,0,0,0,762,763,1,0,0,0,763,774,1,0,0,0,764,762,
        1,0,0,0,765,766,5,12,0,0,766,767,5,446,0,0,767,771,5,4,0,0,768,770,
        7,1,0,0,769,768,1,0,0,0,770,773,1,0,0,0,771,769,1,0,0,0,771,772,
        1,0,0,0,772,775,1,0,0,0,773,771,1,0,0,0,774,765,1,0,0,0,774,775,
        1,0,0,0,775,777,1,0,0,0,776,778,3,22,11,0,777,776,1,0,0,0,777,778,
        1,0,0,0,778,791,1,0,0,0,779,780,5,27,0,0,780,787,3,24,12,0,781,783,
        5,27,0,0,782,784,3,24,12,0,783,782,1,0,0,0,783,784,1,0,0,0,784,786,
        1,0,0,0,785,781,1,0,0,0,786,789,1,0,0,0,787,785,1,0,0,0,787,788,
        1,0,0,0,788,791,1,0,0,0,789,787,1,0,0,0,790,754,1,0,0,0,790,779,
        1,0,0,0,791,21,1,0,0,0,792,793,5,29,0,0,793,23,1,0,0,0,794,796,3,
        26,13,0,795,794,1,0,0,0,796,797,1,0,0,0,797,795,1,0,0,0,797,798,
        1,0,0,0,798,25,1,0,0,0,799,814,5,446,0,0,800,814,3,658,329,0,801,
        814,5,447,0,0,802,814,5,3,0,0,803,814,3,86,43,0,804,814,5,448,0,
        0,805,814,3,282,141,0,806,814,5,26,0,0,807,814,3,504,252,0,808,814,
        5,28,0,0,809,814,5,449,0,0,810,814,3,498,249,0,811,814,3,356,178,
        0,812,814,5,16,0,0,813,799,1,0,0,0,813,800,1,0,0,0,813,801,1,0,0,
        0,813,802,1,0,0,0,813,803,1,0,0,0,813,804,1,0,0,0,813,805,1,0,0,
        0,813,806,1,0,0,0,813,807,1,0,0,0,813,808,1,0,0,0,813,809,1,0,0,
        0,813,810,1,0,0,0,813,811,1,0,0,0,813,812,1,0,0,0,814,27,1,0,0,0,
        815,817,3,30,15,0,816,815,1,0,0,0,817,818,1,0,0,0,818,816,1,0,0,
        0,818,819,1,0,0,0,819,29,1,0,0,0,820,838,3,96,48,0,821,838,3,90,
        45,0,822,838,3,92,46,0,823,838,3,98,49,0,824,838,3,94,47,0,825,838,
        3,72,36,0,826,838,3,88,44,0,827,838,3,84,42,0,828,838,3,82,41,0,
        829,838,3,74,37,0,830,838,3,76,38,0,831,838,3,78,39,0,832,838,3,
        80,40,0,833,838,3,44,22,0,834,838,3,42,21,0,835,838,3,40,20,0,836,
        838,3,34,17,0,837,820,1,0,0,0,837,821,1,0,0,0,837,822,1,0,0,0,837,
        823,1,0,0,0,837,824,1,0,0,0,837,825,1,0,0,0,837,826,1,0,0,0,837,
        827,1,0,0,0,837,828,1,0,0,0,837,829,1,0,0,0,837,830,1,0,0,0,837,
        831,1,0,0,0,837,832,1,0,0,0,837,833,1,0,0,0,837,834,1,0,0,0,837,
        835,1,0,0,0,837,836,1,0,0,0,838,31,1,0,0,0,839,840,5,357,0,0,840,
        841,5,29,0,0,841,842,5,447,0,0,842,843,5,20,0,0,843,33,1,0,0,0,844,
        845,5,91,0,0,845,846,5,29,0,0,846,847,5,12,0,0,847,848,3,36,18,0,
        848,849,5,13,0,0,849,850,5,20,0,0,850,35,1,0,0,0,851,856,3,38,19,
        0,852,853,5,4,0,0,853,855,3,38,19,0,854,852,1,0,0,0,855,858,1,0,
        0,0,856,854,1,0,0,0,856,857,1,0,0,0,857,37,1,0,0,0,858,856,1,0,0,
        0,859,860,5,446,0,0,860,39,1,0,0,0,861,862,5,319,0,0,862,863,5,29,
        0,0,863,864,5,446,0,0,864,865,5,20,0,0,865,41,1,0,0,0,866,867,5,
        360,0,0,867,868,5,29,0,0,868,869,3,20,10,0,869,870,5,20,0,0,870,
        43,1,0,0,0,871,872,5,280,0,0,872,873,5,29,0,0,873,874,3,46,23,0,
        874,875,5,20,0,0,875,45,1,0,0,0,876,912,3,48,24,0,877,878,3,48,24,
        0,878,879,5,25,0,0,879,880,3,50,25,0,880,912,1,0,0,0,881,912,5,293,
        0,0,882,912,5,294,0,0,883,884,5,253,0,0,884,912,3,52,26,0,885,886,
        5,253,0,0,886,887,3,52,26,0,887,888,5,25,0,0,888,889,3,70,35,0,889,
        912,1,0,0,0,890,891,3,52,26,0,891,892,5,188,0,0,892,893,3,48,24,
        0,893,912,1,0,0,0,894,895,3,52,26,0,895,896,5,188,0,0,896,897,3,
        48,24,0,897,898,5,25,0,0,898,899,3,50,25,0,899,912,1,0,0,0,900,901,
        5,25,0,0,901,912,3,70,35,0,902,903,3,48,24,0,903,904,5,253,0,0,904,
        905,3,52,26,0,905,912,1,0,0,0,906,907,3,48,24,0,907,908,5,253,0,
        0,908,909,3,70,35,0,909,912,1,0,0,0,910,912,3,356,178,0,911,876,
        1,0,0,0,911,877,1,0,0,0,911,881,1,0,0,0,911,882,1,0,0,0,911,883,
        1,0,0,0,911,885,1,0,0,0,911,890,1,0,0,0,911,894,1,0,0,0,911,900,
        1,0,0,0,911,902,1,0,0,0,911,906,1,0,0,0,911,910,1,0,0,0,912,47,1,
        0,0,0,913,914,5,447,0,0,914,915,5,15,0,0,915,916,5,447,0,0,916,49,
        1,0,0,0,917,918,5,447,0,0,918,919,5,15,0,0,919,920,5,447,0,0,920,
        51,1,0,0,0,921,922,3,58,29,0,922,923,5,27,0,0,923,924,3,60,30,0,
        924,927,5,27,0,0,925,928,3,62,31,0,926,928,3,64,32,0,927,925,1,0,
        0,0,927,926,1,0,0,0,928,945,1,0,0,0,929,945,3,66,33,0,930,945,3,
        68,34,0,931,945,5,293,0,0,932,945,5,294,0,0,933,945,3,54,27,0,934,
        935,3,56,28,0,935,936,5,4,0,0,936,942,5,447,0,0,937,940,5,4,0,0,
        938,941,3,62,31,0,939,941,3,64,32,0,940,938,1,0,0,0,940,939,1,0,
        0,0,941,943,1,0,0,0,942,937,1,0,0,0,942,943,1,0,0,0,943,945,1,0,
        0,0,944,921,1,0,0,0,944,929,1,0,0,0,944,930,1,0,0,0,944,931,1,0,
        0,0,944,932,1,0,0,0,944,933,1,0,0,0,944,934,1,0,0,0,945,53,1,0,0,
        0,946,947,7,2,0,0,947,55,1,0,0,0,948,949,7,3,0,0,949,57,1,0,0,0,
        950,951,5,447,0,0,951,59,1,0,0,0,952,953,5,447,0,0,953,61,1,0,0,
        0,954,955,5,447,0,0,955,63,1,0,0,0,956,957,5,447,0,0,957,65,1,0,
        0,0,958,959,5,447,0,0,959,67,1,0,0,0,960,961,5,447,0,0,961,69,1,
        0,0,0,962,963,5,25,0,0,963,964,5,447,0,0,964,71,1,0,0,0,965,966,
        5,273,0,0,966,967,5,29,0,0,967,968,5,449,0,0,968,969,5,20,0,0,969,
        73,1,0,0,0,970,971,5,221,0,0,971,972,5,29,0,0,972,973,5,447,0,0,
        973,974,5,20,0,0,974,75,1,0,0,0,975,976,5,222,0,0,976,977,5,29,0,
        0,977,978,5,447,0,0,978,979,5,20,0,0,979,77,1,0,0,0,980,981,5,220,
        0,0,981,982,5,29,0,0,982,983,5,447,0,0,983,984,5,20,0,0,984,79,1,
        0,0,0,985,986,5,223,0,0,986,987,5,29,0,0,987,988,5,447,0,0,988,989,
        5,20,0,0,989,81,1,0,0,0,990,991,5,207,0,0,991,992,5,29,0,0,992,993,
        5,447,0,0,993,994,5,20,0,0,994,83,1,0,0,0,995,996,5,208,0,0,996,
        997,3,86,43,0,997,1000,5,29,0,0,998,1001,3,86,43,0,999,1001,3,574,
        287,0,1000,998,1,0,0,0,1000,999,1,0,0,0,1001,1003,1,0,0,0,1002,1004,
        5,394,0,0,1003,1002,1,0,0,0,1003,1004,1,0,0,0,1004,1010,1,0,0,0,
        1005,1008,5,218,0,0,1006,1009,3,86,43,0,1007,1009,3,574,287,0,1008,
        1006,1,0,0,0,1008,1007,1,0,0,0,1009,1011,1,0,0,0,1010,1005,1,0,0,
        0,1010,1011,1,0,0,0,1011,1012,1,0,0,0,1012,1013,5,20,0,0,1013,85,
        1,0,0,0,1014,1015,7,4,0,0,1015,87,1,0,0,0,1016,1017,5,192,0,0,1017,
        1018,5,29,0,0,1018,1019,3,20,10,0,1019,1020,5,20,0,0,1020,89,1,0,
        0,0,1021,1022,5,225,0,0,1022,1023,5,29,0,0,1023,1024,3,20,10,0,1024,
        1025,5,20,0,0,1025,91,1,0,0,0,1026,1027,5,228,0,0,1027,1028,5,29,
        0,0,1028,1029,3,20,10,0,1029,1030,5,20,0,0,1030,93,1,0,0,0,1031,
        1032,5,198,0,0,1032,1033,5,29,0,0,1033,1034,5,447,0,0,1034,1035,
        5,20,0,0,1035,95,1,0,0,0,1036,1037,5,187,0,0,1037,1038,5,29,0,0,
        1038,1039,5,447,0,0,1039,1040,5,20,0,0,1040,97,1,0,0,0,1041,1042,
        5,199,0,0,1042,1043,5,29,0,0,1043,1044,5,446,0,0,1044,1045,5,20,
        0,0,1045,99,1,0,0,0,1046,1048,3,102,51,0,1047,1046,1,0,0,0,1048,
        1049,1,0,0,0,1049,1047,1,0,0,0,1049,1050,1,0,0,0,1050,101,1,0,0,
        0,1051,1062,3,320,160,0,1052,1062,3,290,145,0,1053,1062,3,296,148,
        0,1054,1062,3,302,151,0,1055,1062,3,308,154,0,1056,1062,3,286,143,
        0,1057,1062,3,236,118,0,1058,1062,3,332,166,0,1059,1062,3,234,117,
        0,1060,1062,3,104,52,0,1061,1051,1,0,0,0,1061,1052,1,0,0,0,1061,
        1053,1,0,0,0,1061,1054,1,0,0,0,1061,1055,1,0,0,0,1061,1056,1,0,0,
        0,1061,1057,1,0,0,0,1061,1058,1,0,0,0,1061,1059,1,0,0,0,1061,1060,
        1,0,0,0,1062,103,1,0,0,0,1063,1065,5,22,0,0,1064,1063,1,0,0,0,1064,
        1065,1,0,0,0,1065,1066,1,0,0,0,1066,1068,5,200,0,0,1067,1069,5,81,
        0,0,1068,1067,1,0,0,0,1068,1069,1,0,0,0,1069,1071,1,0,0,0,1070,1072,
        5,20,0,0,1071,1070,1,0,0,0,1071,1072,1,0,0,0,1072,1114,1,0,0,0,1073,
        1074,3,222,111,0,1074,1075,3,228,114,0,1075,1115,1,0,0,0,1076,1079,
        3,204,102,0,1077,1079,3,192,96,0,1078,1076,1,0,0,0,1078,1077,1,0,
        0,0,1078,1079,1,0,0,0,1079,1081,1,0,0,0,1080,1082,3,190,95,0,1081,
        1080,1,0,0,0,1081,1082,1,0,0,0,1082,1086,1,0,0,0,1083,1085,3,208,
        104,0,1084,1083,1,0,0,0,1085,1088,1,0,0,0,1086,1084,1,0,0,0,1086,
        1087,1,0,0,0,1087,1090,1,0,0,0,1088,1086,1,0,0,0,1089,1091,5,20,
        0,0,1090,1089,1,0,0,0,1090,1091,1,0,0,0,1091,1093,1,0,0,0,1092,1094,
        3,194,97,0,1093,1092,1,0,0,0,1094,1095,1,0,0,0,1095,1093,1,0,0,0,
        1095,1096,1,0,0,0,1096,1115,1,0,0,0,1097,1115,3,188,94,0,1098,1115,
        3,186,93,0,1099,1115,3,206,103,0,1100,1102,3,184,92,0,1101,1100,
        1,0,0,0,1102,1103,1,0,0,0,1103,1101,1,0,0,0,1103,1104,1,0,0,0,1104,
        1115,1,0,0,0,1105,1106,3,192,96,0,1106,1107,3,190,95,0,1107,1115,
        1,0,0,0,1108,1115,3,164,82,0,1109,1115,3,128,64,0,1110,1115,3,112,
        56,0,1111,1115,3,110,55,0,1112,1115,3,108,54,0,1113,1115,3,106,53,
        0,1114,1073,1,0,0,0,1114,1078,1,0,0,0,1114,1097,1,0,0,0,1114,1098,
        1,0,0,0,1114,1099,1,0,0,0,1114,1101,1,0,0,0,1114,1105,1,0,0,0,1114,
        1108,1,0,0,0,1114,1109,1,0,0,0,1114,1110,1,0,0,0,1114,1111,1,0,0,
        0,1114,1112,1,0,0,0,1114,1113,1,0,0,0,1115,1116,1,0,0,0,1116,1117,
        5,22,0,0,1117,105,1,0,0,0,1118,1119,3,20,10,0,1119,1120,5,19,0,0,
        1120,1122,1,0,0,0,1121,1118,1,0,0,0,1122,1123,1,0,0,0,1123,1121,
        1,0,0,0,1123,1124,1,0,0,0,1124,107,1,0,0,0,1125,1128,3,20,10,0,1126,
        1127,5,253,0,0,1127,1129,3,574,287,0,1128,1126,1,0,0,0,1128,1129,
        1,0,0,0,1129,1130,1,0,0,0,1130,1131,5,446,0,0,1131,1132,5,336,0,
        0,1132,1133,5,15,0,0,1133,1134,5,237,0,0,1134,1135,3,20,10,0,1135,
        109,1,0,0,0,1136,1139,3,20,10,0,1137,1138,5,253,0,0,1138,1140,3,
        574,287,0,1139,1137,1,0,0,0,1139,1140,1,0,0,0,1140,1141,1,0,0,0,
        1141,1144,5,15,0,0,1142,1145,5,446,0,0,1143,1145,3,282,141,0,1144,
        1142,1,0,0,0,1144,1143,1,0,0,0,1145,1146,1,0,0,0,1146,1152,5,15,
        0,0,1147,1148,7,5,0,0,1148,1149,7,6,0,0,1149,1153,5,446,0,0,1150,
        1151,5,54,0,0,1151,1153,5,446,0,0,1152,1147,1,0,0,0,1152,1150,1,
        0,0,0,1153,1155,1,0,0,0,1154,1136,1,0,0,0,1155,1156,1,0,0,0,1156,
        1154,1,0,0,0,1156,1157,1,0,0,0,1157,111,1,0,0,0,1158,1161,5,83,0,
        0,1159,1162,3,114,57,0,1160,1162,3,116,58,0,1161,1159,1,0,0,0,1161,
        1160,1,0,0,0,1162,1163,1,0,0,0,1163,1161,1,0,0,0,1163,1164,1,0,0,
        0,1164,113,1,0,0,0,1165,1166,3,124,62,0,1166,1167,5,29,0,0,1167,
        1172,3,126,63,0,1168,1169,5,4,0,0,1169,1171,3,126,63,0,1170,1168,
        1,0,0,0,1171,1174,1,0,0,0,1172,1170,1,0,0,0,1172,1173,1,0,0,0,1173,
        1175,1,0,0,0,1174,1172,1,0,0,0,1175,1176,5,19,0,0,1176,115,1,0,0,
        0,1177,1179,3,120,60,0,1178,1180,3,122,61,0,1179,1178,1,0,0,0,1179,
        1180,1,0,0,0,1180,1181,1,0,0,0,1181,1184,5,15,0,0,1182,1185,3,114,
        57,0,1183,1185,3,118,59,0,1184,1182,1,0,0,0,1184,1183,1,0,0,0,1185,
        1186,1,0,0,0,1186,1184,1,0,0,0,1186,1187,1,0,0,0,1187,117,1,0,0,
        0,1188,1189,5,117,0,0,1189,1190,5,447,0,0,1190,1191,5,12,0,0,1191,
        1192,5,446,0,0,1192,1193,5,13,0,0,1193,1195,5,15,0,0,1194,1196,3,
        114,57,0,1195,1194,1,0,0,0,1196,1197,1,0,0,0,1197,1195,1,0,0,0,1197,
        1198,1,0,0,0,1198,119,1,0,0,0,1199,1200,7,7,0,0,1200,121,1,0,0,0,
        1201,1216,5,446,0,0,1202,1213,3,20,10,0,1203,1204,5,12,0,0,1204,
        1209,5,447,0,0,1205,1206,5,4,0,0,1206,1208,5,447,0,0,1207,1205,1,
        0,0,0,1208,1211,1,0,0,0,1209,1207,1,0,0,0,1209,1210,1,0,0,0,1210,
        1212,1,0,0,0,1211,1209,1,0,0,0,1212,1214,5,13,0,0,1213,1203,1,0,
        0,0,1213,1214,1,0,0,0,1214,1216,1,0,0,0,1215,1201,1,0,0,0,1215,1202,
        1,0,0,0,1216,123,1,0,0,0,1217,1220,5,446,0,0,1218,1220,3,282,141,
        0,1219,1217,1,0,0,0,1219,1218,1,0,0,0,1220,125,1,0,0,0,1221,1232,
        3,20,10,0,1222,1232,5,446,0,0,1223,1232,5,447,0,0,1224,1232,5,448,
        0,0,1225,1226,5,12,0,0,1226,1227,7,8,0,0,1227,1228,5,4,0,0,1228,
        1229,7,8,0,0,1229,1232,5,13,0,0,1230,1232,3,294,147,0,1231,1221,
        1,0,0,0,1231,1222,1,0,0,0,1231,1223,1,0,0,0,1231,1224,1,0,0,0,1231,
        1225,1,0,0,0,1231,1230,1,0,0,0,1232,127,1,0,0,0,1233,1235,3,130,
        65,0,1234,1233,1,0,0,0,1235,1236,1,0,0,0,1236,1234,1,0,0,0,1236,
        1237,1,0,0,0,1237,1238,1,0,0,0,1238,1239,5,204,0,0,1239,129,1,0,
        0,0,1240,1252,3,146,73,0,1241,1252,3,148,74,0,1242,1252,3,150,75,
        0,1243,1252,3,152,76,0,1244,1252,3,156,78,0,1245,1252,3,136,68,0,
        1246,1252,3,138,69,0,1247,1252,3,140,70,0,1248,1252,3,142,71,0,1249,
        1252,3,134,67,0,1250,1252,3,132,66,0,1251,1240,1,0,0,0,1251,1241,
        1,0,0,0,1251,1242,1,0,0,0,1251,1243,1,0,0,0,1251,1244,1,0,0,0,1251,
        1245,1,0,0,0,1251,1246,1,0,0,0,1251,1247,1,0,0,0,1251,1248,1,0,0,
        0,1251,1249,1,0,0,0,1251,1250,1,0,0,0,1252,131,1,0,0,0,1253,1255,
        5,86,0,0,1254,1256,5,270,0,0,1255,1254,1,0,0,0,1255,1256,1,0,0,0,
        1256,1257,1,0,0,0,1257,1258,5,449,0,0,1258,133,1,0,0,0,1259,1260,
        5,87,0,0,1260,1261,5,446,0,0,1261,1262,5,270,0,0,1262,1263,5,447,
        0,0,1263,135,1,0,0,0,1264,1266,5,112,0,0,1265,1267,5,57,0,0,1266,
        1265,1,0,0,0,1266,1267,1,0,0,0,1267,1268,1,0,0,0,1268,1269,5,269,
        0,0,1269,1270,3,558,279,0,1270,137,1,0,0,0,1271,1273,5,244,0,0,1272,
        1274,5,57,0,0,1273,1272,1,0,0,0,1273,1274,1,0,0,0,1274,1275,1,0,
        0,0,1275,1276,5,269,0,0,1276,1277,3,558,279,0,1277,139,1,0,0,0,1278,
        1279,5,343,0,0,1279,1280,5,344,0,0,1280,1281,5,345,0,0,1281,1286,
        3,144,72,0,1282,1283,5,4,0,0,1283,1285,3,144,72,0,1284,1282,1,0,
        0,0,1285,1288,1,0,0,0,1286,1284,1,0,0,0,1286,1287,1,0,0,0,1287,141,
        1,0,0,0,1288,1286,1,0,0,0,1289,1290,5,156,0,0,1290,1291,5,345,0,
        0,1291,1292,5,446,0,0,1292,1293,5,447,0,0,1293,143,1,0,0,0,1294,
        1296,5,26,0,0,1295,1294,1,0,0,0,1295,1296,1,0,0,0,1296,1301,1,0,
        0,0,1297,1302,3,282,141,0,1298,1302,5,228,0,0,1299,1302,5,446,0,
        0,1300,1302,5,280,0,0,1301,1297,1,0,0,0,1301,1298,1,0,0,0,1301,1299,
        1,0,0,0,1301,1300,1,0,0,0,1302,145,1,0,0,0,1303,1305,5,59,0,0,1304,
        1306,7,1,0,0,1305,1304,1,0,0,0,1306,1307,1,0,0,0,1307,1305,1,0,0,
        0,1307,1308,1,0,0,0,1308,1311,1,0,0,0,1309,1310,5,253,0,0,1310,1312,
        3,574,287,0,1311,1309,1,0,0,0,1311,1312,1,0,0,0,1312,147,1,0,0,0,
        1313,1314,5,157,0,0,1314,149,1,0,0,0,1315,1316,5,61,0,0,1316,1317,
        5,270,0,0,1317,1318,7,9,0,0,1318,151,1,0,0,0,1319,1320,5,178,0,0,
        1320,1321,5,66,0,0,1321,1326,3,154,77,0,1322,1323,5,4,0,0,1323,1325,
        3,154,77,0,1324,1322,1,0,0,0,1325,1328,1,0,0,0,1326,1324,1,0,0,0,
        1326,1327,1,0,0,0,1327,1330,1,0,0,0,1328,1326,1,0,0,0,1329,1331,
        7,10,0,0,1330,1329,1,0,0,0,1330,1331,1,0,0,0,1331,153,1,0,0,0,1332,
        1337,3,282,141,0,1333,1337,5,228,0,0,1334,1337,5,280,0,0,1335,1337,
        5,446,0,0,1336,1332,1,0,0,0,1336,1333,1,0,0,0,1336,1334,1,0,0,0,
        1336,1335,1,0,0,0,1337,155,1,0,0,0,1338,1339,5,62,0,0,1339,1340,
        5,253,0,0,1340,1345,3,158,79,0,1341,1342,5,4,0,0,1342,1344,3,158,
        79,0,1343,1341,1,0,0,0,1344,1347,1,0,0,0,1345,1343,1,0,0,0,1345,
        1346,1,0,0,0,1346,1349,1,0,0,0,1347,1345,1,0,0,0,1348,1350,5,26,
        0,0,1349,1348,1,0,0,0,1349,1350,1,0,0,0,1350,1352,1,0,0,0,1351,1353,
        3,160,80,0,1352,1351,1,0,0,0,1352,1353,1,0,0,0,1353,157,1,0,0,0,
        1354,1360,3,282,141,0,1355,1360,5,228,0,0,1356,1360,5,350,0,0,1357,
        1360,5,192,0,0,1358,1360,5,446,0,0,1359,1354,1,0,0,0,1359,1355,1,
        0,0,0,1359,1356,1,0,0,0,1359,1357,1,0,0,0,1359,1358,1,0,0,0,1360,
        159,1,0,0,0,1361,1362,5,60,0,0,1362,1367,3,162,81,0,1363,1364,5,
        4,0,0,1364,1366,3,162,81,0,1365,1363,1,0,0,0,1366,1369,1,0,0,0,1367,
        1365,1,0,0,0,1367,1368,1,0,0,0,1368,161,1,0,0,0,1369,1367,1,0,0,
        0,1370,1371,7,11,0,0,1371,163,1,0,0,0,1372,1373,5,330,0,0,1373,1374,
        5,15,0,0,1374,1378,5,446,0,0,1375,1377,3,168,84,0,1376,1375,1,0,
        0,0,1377,1380,1,0,0,0,1378,1376,1,0,0,0,1378,1379,1,0,0,0,1379,1384,
        1,0,0,0,1380,1378,1,0,0,0,1381,1383,3,166,83,0,1382,1381,1,0,0,0,
        1383,1386,1,0,0,0,1384,1382,1,0,0,0,1384,1385,1,0,0,0,1385,1388,
        1,0,0,0,1386,1384,1,0,0,0,1387,1389,5,20,0,0,1388,1387,1,0,0,0,1388,
        1389,1,0,0,0,1389,165,1,0,0,0,1390,1391,7,12,0,0,1391,167,1,0,0,
        0,1392,1393,5,446,0,0,1393,1394,5,15,0,0,1394,1395,5,446,0,0,1395,
        169,1,0,0,0,1396,1397,3,172,86,0,1397,1398,3,174,87,0,1398,1399,
        3,176,88,0,1399,1400,3,178,89,0,1400,1401,3,180,90,0,1401,1402,3,
        182,91,0,1402,171,1,0,0,0,1403,1404,5,79,0,0,1404,1405,5,446,0,0,
        1405,1406,5,20,0,0,1406,173,1,0,0,0,1407,1408,5,55,0,0,1408,1409,
        5,446,0,0,1409,1410,5,20,0,0,1410,175,1,0,0,0,1411,1412,5,237,0,
        0,1412,1413,5,446,0,0,1413,1414,3,254,127,0,1414,1415,5,29,0,0,1415,
        1418,3,20,10,0,1416,1417,5,253,0,0,1417,1419,3,574,287,0,1418,1416,
        1,0,0,0,1418,1419,1,0,0,0,1419,1420,1,0,0,0,1420,1421,5,20,0,0,1421,
        177,1,0,0,0,1422,1423,5,57,0,0,1423,1424,5,446,0,0,1424,1425,5,20,
        0,0,1425,179,1,0,0,0,1426,1427,5,61,0,0,1427,1428,5,55,0,0,1428,
        1429,5,20,0,0,1429,181,1,0,0,0,1430,1431,7,13,0,0,1431,1432,5,20,
        0,0,1432,183,1,0,0,0,1433,1434,5,225,0,0,1434,1437,5,29,0,0,1435,
        1438,5,446,0,0,1436,1438,3,658,329,0,1437,1435,1,0,0,0,1437,1436,
        1,0,0,0,1438,1439,1,0,0,0,1439,1440,5,191,0,0,1440,1441,7,14,0,0,
        1441,1442,3,20,10,0,1442,1443,5,20,0,0,1443,185,1,0,0,0,1444,1445,
        5,16,0,0,1445,1446,5,89,0,0,1446,1447,5,446,0,0,1447,1448,5,164,
        0,0,1448,187,1,0,0,0,1449,1450,5,16,0,0,1450,1451,5,89,0,0,1451,
        1452,5,446,0,0,1452,1453,5,77,0,0,1453,1454,5,446,0,0,1454,189,1,
        0,0,0,1455,1456,5,75,0,0,1456,1457,5,20,0,0,1457,191,1,0,0,0,1458,
        1459,5,16,0,0,1459,1460,5,77,0,0,1460,1461,5,446,0,0,1461,193,1,
        0,0,0,1462,1468,3,198,99,0,1463,1468,3,200,100,0,1464,1468,3,202,
        101,0,1465,1468,3,280,140,0,1466,1468,3,196,98,0,1467,1462,1,0,0,
        0,1467,1463,1,0,0,0,1467,1464,1,0,0,0,1467,1465,1,0,0,0,1467,1466,
        1,0,0,0,1468,1469,1,0,0,0,1469,1470,5,20,0,0,1470,195,1,0,0,0,1471,
        1472,5,76,0,0,1472,197,1,0,0,0,1473,1474,5,101,0,0,1474,1477,7,15,
        0,0,1475,1476,5,20,0,0,1476,1478,7,16,0,0,1477,1475,1,0,0,0,1477,
        1478,1,0,0,0,1478,199,1,0,0,0,1479,1480,5,102,0,0,1480,1481,5,236,
        0,0,1481,1482,5,12,0,0,1482,1483,5,417,0,0,1483,1484,5,29,0,0,1484,
        1485,5,446,0,0,1485,1486,5,13,0,0,1486,201,1,0,0,0,1487,1488,5,103,
        0,0,1488,1489,5,29,0,0,1489,1490,5,447,0,0,1490,203,1,0,0,0,1491,
        1492,5,16,0,0,1492,1493,5,89,0,0,1493,1494,5,446,0,0,1494,1495,5,
        446,0,0,1495,205,1,0,0,0,1496,1497,5,16,0,0,1497,1498,5,89,0,0,1498,
        1499,5,446,0,0,1499,207,1,0,0,0,1500,1501,5,205,0,0,1501,1502,3,
        210,105,0,1502,1503,5,20,0,0,1503,209,1,0,0,0,1504,1507,3,212,106,
        0,1505,1506,5,20,0,0,1506,1508,3,216,108,0,1507,1505,1,0,0,0,1507,
        1508,1,0,0,0,1508,211,1,0,0,0,1509,1514,3,214,107,0,1510,1511,5,
        4,0,0,1511,1513,3,214,107,0,1512,1510,1,0,0,0,1513,1516,1,0,0,0,
        1514,1512,1,0,0,0,1514,1515,1,0,0,0,1515,213,1,0,0,0,1516,1514,1,
        0,0,0,1517,1519,5,446,0,0,1518,1520,3,220,110,0,1519,1518,1,0,0,
        0,1519,1520,1,0,0,0,1520,215,1,0,0,0,1521,1526,3,218,109,0,1522,
        1523,5,4,0,0,1523,1525,3,218,109,0,1524,1522,1,0,0,0,1525,1528,1,
        0,0,0,1526,1524,1,0,0,0,1526,1527,1,0,0,0,1527,1529,1,0,0,0,1528,
        1526,1,0,0,0,1529,1530,5,12,0,0,1530,1531,5,262,0,0,1531,1532,5,
        268,0,0,1532,1533,3,574,287,0,1533,1534,5,13,0,0,1534,217,1,0,0,
        0,1535,1537,5,446,0,0,1536,1538,3,220,110,0,1537,1536,1,0,0,0,1537,
        1538,1,0,0,0,1538,219,1,0,0,0,1539,1540,5,65,0,0,1540,1541,5,66,
        0,0,1541,1542,5,446,0,0,1542,221,1,0,0,0,1543,1544,5,79,0,0,1544,
        1545,5,29,0,0,1545,1548,3,20,10,0,1546,1547,5,253,0,0,1547,1549,
        3,574,287,0,1548,1546,1,0,0,0,1548,1549,1,0,0,0,1549,1555,1,0,0,
        0,1550,1551,5,91,0,0,1551,1552,5,12,0,0,1552,1553,3,224,112,0,1553,
        1554,5,13,0,0,1554,1556,1,0,0,0,1555,1550,1,0,0,0,1555,1556,1,0,
        0,0,1556,1558,1,0,0,0,1557,1559,7,16,0,0,1558,1557,1,0,0,0,1558,
        1559,1,0,0,0,1559,223,1,0,0,0,1560,1565,3,226,113,0,1561,1562,5,
        4,0,0,1562,1564,3,226,113,0,1563,1561,1,0,0,0,1564,1567,1,0,0,0,
        1565,1563,1,0,0,0,1565,1566,1,0,0,0,1566,225,1,0,0,0,1567,1565,1,
        0,0,0,1568,1569,5,446,0,0,1569,1570,5,29,0,0,1570,1574,7,17,0,0,
        1571,1572,5,446,0,0,1572,1574,3,504,252,0,1573,1568,1,0,0,0,1573,
        1571,1,0,0,0,1574,227,1,0,0,0,1575,1577,7,16,0,0,1576,1575,1,0,0,
        0,1576,1577,1,0,0,0,1577,1578,1,0,0,0,1578,1579,5,92,0,0,1579,1580,
        5,29,0,0,1580,1581,5,268,0,0,1581,1584,3,20,10,0,1582,1583,5,253,
        0,0,1583,1585,3,574,287,0,1584,1582,1,0,0,0,1584,1585,1,0,0,0,1585,
        1590,1,0,0,0,1586,1587,5,12,0,0,1587,1588,3,230,115,0,1588,1589,
        5,13,0,0,1589,1591,1,0,0,0,1590,1586,1,0,0,0,1590,1591,1,0,0,0,1591,
        1593,1,0,0,0,1592,1594,5,20,0,0,1593,1592,1,0,0,0,1593,1594,1,0,
        0,0,1594,229,1,0,0,0,1595,1600,3,232,116,0,1596,1597,5,4,0,0,1597,
        1599,3,232,116,0,1598,1596,1,0,0,0,1599,1602,1,0,0,0,1600,1598,1,
        0,0,0,1600,1601,1,0,0,0,1601,231,1,0,0,0,1602,1600,1,0,0,0,1603,
        1607,3,254,127,0,1604,1607,5,446,0,0,1605,1607,3,658,329,0,1606,
        1603,1,0,0,0,1606,1604,1,0,0,0,1606,1605,1,0,0,0,1607,1611,1,0,0,
        0,1608,1609,5,12,0,0,1609,1610,5,447,0,0,1610,1612,5,13,0,0,1611,
        1608,1,0,0,0,1611,1612,1,0,0,0,1612,1613,1,0,0,0,1613,1614,5,29,
        0,0,1614,1619,7,18,0,0,1615,1616,5,4,0,0,1616,1618,7,18,0,0,1617,
        1615,1,0,0,0,1618,1621,1,0,0,0,1619,1617,1,0,0,0,1619,1620,1,0,0,
        0,1620,233,1,0,0,0,1621,1619,1,0,0,0,1622,1623,5,16,0,0,1623,1624,
        5,112,0,0,1624,1625,3,20,10,0,1625,235,1,0,0,0,1626,1627,5,238,0,
        0,1627,1632,3,238,119,0,1628,1629,5,4,0,0,1629,1631,3,238,119,0,
        1630,1628,1,0,0,0,1631,1634,1,0,0,0,1632,1630,1,0,0,0,1632,1633,
        1,0,0,0,1633,1635,1,0,0,0,1634,1632,1,0,0,0,1635,1636,5,20,0,0,1636,
        237,1,0,0,0,1637,1642,3,244,122,0,1638,1639,5,12,0,0,1639,1640,3,
        246,123,0,1640,1641,5,13,0,0,1641,1643,1,0,0,0,1642,1638,1,0,0,0,
        1642,1643,1,0,0,0,1643,1647,1,0,0,0,1644,1647,3,240,120,0,1645,1647,
        3,242,121,0,1646,1637,1,0,0,0,1646,1644,1,0,0,0,1646,1645,1,0,0,
        0,1647,239,1,0,0,0,1648,1649,5,396,0,0,1649,1650,5,12,0,0,1650,1651,
        5,208,0,0,1651,1652,3,86,43,0,1652,1655,5,29,0,0,1653,1656,3,86,
        43,0,1654,1656,3,574,287,0,1655,1653,1,0,0,0,1655,1654,1,0,0,0,1656,
        1658,1,0,0,0,1657,1659,5,394,0,0,1658,1657,1,0,0,0,1658,1659,1,0,
        0,0,1659,1660,1,0,0,0,1660,1662,5,13,0,0,1661,1663,5,20,0,0,1662,
        1661,1,0,0,0,1662,1663,1,0,0,0,1663,241,1,0,0,0,1664,1665,5,395,
        0,0,1665,1686,5,12,0,0,1666,1667,5,208,0,0,1667,1671,3,86,43,0,1668,
        1671,5,192,0,0,1669,1671,5,334,0,0,1670,1666,1,0,0,0,1670,1668,1,
        0,0,0,1670,1669,1,0,0,0,1671,1672,1,0,0,0,1672,1676,5,29,0,0,1673,
        1677,3,86,43,0,1674,1677,3,574,287,0,1675,1677,3,20,10,0,1676,1673,
        1,0,0,0,1676,1674,1,0,0,0,1676,1675,1,0,0,0,1677,1681,1,0,0,0,1678,
        1682,5,394,0,0,1679,1680,5,218,0,0,1680,1682,3,86,43,0,1681,1678,
        1,0,0,0,1681,1679,1,0,0,0,1681,1682,1,0,0,0,1682,1687,1,0,0,0,1683,
        1684,5,351,0,0,1684,1685,5,29,0,0,1685,1687,5,446,0,0,1686,1670,
        1,0,0,0,1686,1683,1,0,0,0,1687,1688,1,0,0,0,1688,1690,5,13,0,0,1689,
        1691,5,20,0,0,1690,1689,1,0,0,0,1690,1691,1,0,0,0,1691,243,1,0,0,
        0,1692,1693,5,446,0,0,1693,245,1,0,0,0,1694,1699,3,248,124,0,1695,
        1696,5,4,0,0,1696,1698,3,248,124,0,1697,1695,1,0,0,0,1698,1701,1,
        0,0,0,1699,1697,1,0,0,0,1699,1700,1,0,0,0,1700,247,1,0,0,0,1701,
        1699,1,0,0,0,1702,1705,3,280,140,0,1703,1705,3,250,125,0,1704,1702,
        1,0,0,0,1704,1703,1,0,0,0,1705,249,1,0,0,0,1706,1710,5,237,0,0,1707,
        1711,5,446,0,0,1708,1711,3,658,329,0,1709,1711,3,20,10,0,1710,1707,
        1,0,0,0,1710,1708,1,0,0,0,1710,1709,1,0,0,0,1711,1723,1,0,0,0,1712,
        1713,5,12,0,0,1713,1718,3,252,126,0,1714,1715,5,4,0,0,1715,1717,
        3,252,126,0,1716,1714,1,0,0,0,1717,1720,1,0,0,0,1718,1716,1,0,0,
        0,1718,1719,1,0,0,0,1719,1721,1,0,0,0,1720,1718,1,0,0,0,1721,1722,
        5,13,0,0,1722,1724,1,0,0,0,1723,1712,1,0,0,0,1723,1724,1,0,0,0,1724,
        1726,1,0,0,0,1725,1727,5,20,0,0,1726,1725,1,0,0,0,1726,1727,1,0,
        0,0,1727,1761,1,0,0,0,1728,1731,5,237,0,0,1729,1732,5,446,0,0,1730,
        1732,3,658,329,0,1731,1729,1,0,0,0,1731,1730,1,0,0,0,1732,1733,1,
        0,0,0,1733,1734,5,29,0,0,1734,1737,3,20,10,0,1735,1736,5,253,0,0,
        1736,1738,3,574,287,0,1737,1735,1,0,0,0,1737,1738,1,0,0,0,1738,1740,
        1,0,0,0,1739,1741,5,20,0,0,1740,1739,1,0,0,0,1740,1741,1,0,0,0,1741,
        1761,1,0,0,0,1742,1745,5,237,0,0,1743,1746,3,530,265,0,1744,1746,
        3,658,329,0,1745,1743,1,0,0,0,1745,1744,1,0,0,0,1746,1747,1,0,0,
        0,1747,1748,5,12,0,0,1748,1753,3,252,126,0,1749,1750,5,4,0,0,1750,
        1752,3,252,126,0,1751,1749,1,0,0,0,1752,1755,1,0,0,0,1753,1751,1,
        0,0,0,1753,1754,1,0,0,0,1754,1756,1,0,0,0,1755,1753,1,0,0,0,1756,
        1758,5,13,0,0,1757,1759,5,20,0,0,1758,1757,1,0,0,0,1758,1759,1,0,
        0,0,1759,1761,1,0,0,0,1760,1706,1,0,0,0,1760,1728,1,0,0,0,1760,1742,
        1,0,0,0,1761,251,1,0,0,0,1762,1765,3,254,127,0,1763,1764,5,29,0,
        0,1764,1766,3,278,139,0,1765,1763,1,0,0,0,1765,1766,1,0,0,0,1766,
        253,1,0,0,0,1767,1780,3,256,128,0,1768,1780,3,258,129,0,1769,1780,
        3,260,130,0,1770,1780,3,262,131,0,1771,1780,3,264,132,0,1772,1780,
        3,266,133,0,1773,1780,3,268,134,0,1774,1780,3,270,135,0,1775,1780,
        3,272,136,0,1776,1780,3,274,137,0,1777,1780,3,276,138,0,1778,1780,
        5,84,0,0,1779,1767,1,0,0,0,1779,1768,1,0,0,0,1779,1769,1,0,0,0,1779,
        1770,1,0,0,0,1779,1771,1,0,0,0,1779,1772,1,0,0,0,1779,1773,1,0,0,
        0,1779,1774,1,0,0,0,1779,1775,1,0,0,0,1779,1776,1,0,0,0,1779,1777,
        1,0,0,0,1779,1778,1,0,0,0,1780,255,1,0,0,0,1781,1782,7,19,0,0,1782,
        257,1,0,0,0,1783,1784,7,20,0,0,1784,259,1,0,0,0,1785,1786,7,21,0,
        0,1786,261,1,0,0,0,1787,1788,5,211,0,0,1788,263,1,0,0,0,1789,1790,
        5,445,0,0,1790,265,1,0,0,0,1791,1792,7,22,0,0,1792,267,1,0,0,0,1793,
        1794,5,407,0,0,1794,269,1,0,0,0,1795,1796,5,408,0,0,1796,271,1,0,
        0,0,1797,1798,7,23,0,0,1798,273,1,0,0,0,1799,1800,7,24,0,0,1800,
        275,1,0,0,0,1801,1802,5,398,0,0,1802,277,1,0,0,0,1803,1837,5,447,
        0,0,1804,1837,5,449,0,0,1805,1837,5,446,0,0,1806,1837,3,294,147,
        0,1807,1837,3,306,153,0,1808,1837,3,312,156,0,1809,1815,3,20,10,
        0,1810,1813,5,253,0,0,1811,1814,3,574,287,0,1812,1814,3,86,43,0,
        1813,1811,1,0,0,0,1813,1812,1,0,0,0,1814,1816,1,0,0,0,1815,1810,
        1,0,0,0,1815,1816,1,0,0,0,1816,1837,1,0,0,0,1817,1837,3,86,43,0,
        1818,1824,3,356,178,0,1819,1822,5,253,0,0,1820,1823,3,574,287,0,
        1821,1823,3,356,178,0,1822,1820,1,0,0,0,1822,1821,1,0,0,0,1823,1825,
        1,0,0,0,1824,1819,1,0,0,0,1824,1825,1,0,0,0,1825,1837,1,0,0,0,1826,
        1827,5,12,0,0,1827,1832,5,449,0,0,1828,1829,5,4,0,0,1829,1831,5,
        449,0,0,1830,1828,1,0,0,0,1831,1834,1,0,0,0,1832,1830,1,0,0,0,1832,
        1833,1,0,0,0,1833,1835,1,0,0,0,1834,1832,1,0,0,0,1835,1837,5,13,
        0,0,1836,1803,1,0,0,0,1836,1804,1,0,0,0,1836,1805,1,0,0,0,1836,1806,
        1,0,0,0,1836,1807,1,0,0,0,1836,1808,1,0,0,0,1836,1809,1,0,0,0,1836,
        1817,1,0,0,0,1836,1818,1,0,0,0,1836,1826,1,0,0,0,1837,279,1,0,0,
        0,1838,1855,3,282,141,0,1839,1853,5,29,0,0,1840,1854,3,284,142,0,
        1841,1854,5,2,0,0,1842,1843,5,12,0,0,1843,1848,5,446,0,0,1844,1845,
        5,4,0,0,1845,1847,5,446,0,0,1846,1844,1,0,0,0,1847,1850,1,0,0,0,
        1848,1846,1,0,0,0,1848,1849,1,0,0,0,1849,1851,1,0,0,0,1850,1848,
        1,0,0,0,1851,1854,5,13,0,0,1852,1854,3,448,224,0,1853,1840,1,0,0,
        0,1853,1841,1,0,0,0,1853,1842,1,0,0,0,1853,1852,1,0,0,0,1854,1856,
        1,0,0,0,1855,1839,1,0,0,0,1855,1856,1,0,0,0,1856,1859,1,0,0,0,1857,
        1858,5,218,0,0,1858,1860,3,86,43,0,1859,1857,1,0,0,0,1859,1860,1,
        0,0,0,1860,1862,1,0,0,0,1861,1863,5,20,0,0,1862,1861,1,0,0,0,1862,
        1863,1,0,0,0,1863,281,1,0,0,0,1864,1865,7,25,0,0,1865,283,1,0,0,
        0,1866,1873,5,447,0,0,1867,1873,5,449,0,0,1868,1873,5,446,0,0,1869,
        1873,3,294,147,0,1870,1873,3,306,153,0,1871,1873,3,312,156,0,1872,
        1866,1,0,0,0,1872,1867,1,0,0,0,1872,1868,1,0,0,0,1872,1869,1,0,0,
        0,1872,1870,1,0,0,0,1872,1871,1,0,0,0,1873,285,1,0,0,0,1874,1875,
        5,237,0,0,1875,1880,3,288,144,0,1876,1877,5,4,0,0,1877,1879,3,288,
        144,0,1878,1876,1,0,0,0,1879,1882,1,0,0,0,1880,1878,1,0,0,0,1880,
        1881,1,0,0,0,1881,1883,1,0,0,0,1882,1880,1,0,0,0,1883,1884,5,20,
        0,0,1884,287,1,0,0,0,1885,1897,5,446,0,0,1886,1887,5,12,0,0,1887,
        1892,3,252,126,0,1888,1889,5,4,0,0,1889,1891,3,252,126,0,1890,1888,
        1,0,0,0,1891,1894,1,0,0,0,1892,1890,1,0,0,0,1892,1893,1,0,0,0,1893,
        1895,1,0,0,0,1894,1892,1,0,0,0,1895,1896,5,13,0,0,1896,1898,1,0,
        0,0,1897,1886,1,0,0,0,1897,1898,1,0,0,0,1898,289,1,0,0,0,1899,1900,
        5,230,0,0,1900,1905,3,292,146,0,1901,1902,5,4,0,0,1902,1904,3,292,
        146,0,1903,1901,1,0,0,0,1904,1907,1,0,0,0,1905,1903,1,0,0,0,1905,
        1906,1,0,0,0,1906,1908,1,0,0,0,1907,1905,1,0,0,0,1908,1909,5,20,
        0,0,1909,291,1,0,0,0,1910,1913,5,446,0,0,1911,1912,5,30,0,0,1912,
        1914,3,294,147,0,1913,1911,1,0,0,0,1913,1914,1,0,0,0,1914,293,1,
        0,0,0,1915,1916,7,26,0,0,1916,295,1,0,0,0,1917,1918,5,232,0,0,1918,
        1923,3,298,149,0,1919,1920,5,4,0,0,1920,1922,3,298,149,0,1921,1919,
        1,0,0,0,1922,1925,1,0,0,0,1923,1921,1,0,0,0,1923,1924,1,0,0,0,1924,
        1926,1,0,0,0,1925,1923,1,0,0,0,1926,1927,5,20,0,0,1927,297,1,0,0,
        0,1928,1931,5,446,0,0,1929,1930,5,30,0,0,1930,1932,3,300,150,0,1931,
        1929,1,0,0,0,1931,1932,1,0,0,0,1932,299,1,0,0,0,1933,1937,5,447,
        0,0,1934,1937,5,446,0,0,1935,1937,3,318,159,0,1936,1933,1,0,0,0,
        1936,1934,1,0,0,0,1936,1935,1,0,0,0,1937,301,1,0,0,0,1938,1939,5,
        231,0,0,1939,1944,3,304,152,0,1940,1941,5,4,0,0,1941,1943,3,304,
        152,0,1942,1940,1,0,0,0,1943,1946,1,0,0,0,1944,1942,1,0,0,0,1944,
        1945,1,0,0,0,1945,1947,1,0,0,0,1946,1944,1,0,0,0,1947,1948,5,20,
        0,0,1948,303,1,0,0,0,1949,1952,5,446,0,0,1950,1951,5,30,0,0,1951,
        1953,3,306,153,0,1952,1950,1,0,0,0,1952,1953,1,0,0,0,1953,305,1,
        0,0,0,1954,1957,5,447,0,0,1955,1956,5,19,0,0,1956,1958,5,447,0,0,
        1957,1955,1,0,0,0,1957,1958,1,0,0,0,1958,1962,1,0,0,0,1959,1962,
        5,446,0,0,1960,1962,3,318,159,0,1961,1954,1,0,0,0,1961,1959,1,0,
        0,0,1961,1960,1,0,0,0,1962,307,1,0,0,0,1963,1964,5,235,0,0,1964,
        1969,3,310,155,0,1965,1966,5,4,0,0,1966,1968,3,310,155,0,1967,1965,
        1,0,0,0,1968,1971,1,0,0,0,1969,1967,1,0,0,0,1969,1970,1,0,0,0,1970,
        1972,1,0,0,0,1971,1969,1,0,0,0,1972,1973,5,20,0,0,1973,309,1,0,0,
        0,1974,1977,5,446,0,0,1975,1977,3,658,329,0,1976,1974,1,0,0,0,1976,
        1975,1,0,0,0,1977,1980,1,0,0,0,1978,1979,5,30,0,0,1979,1981,3,312,
        156,0,1980,1978,1,0,0,0,1980,1981,1,0,0,0,1981,311,1,0,0,0,1982,
        1987,3,314,157,0,1983,1984,5,1,0,0,1984,1986,3,314,157,0,1985,1983,
        1,0,0,0,1986,1989,1,0,0,0,1987,1985,1,0,0,0,1987,1988,1,0,0,0,1988,
        313,1,0,0,0,1989,1987,1,0,0,0,1990,1996,5,449,0,0,1991,1996,5,446,
        0,0,1992,1996,3,318,159,0,1993,1996,3,316,158,0,1994,1996,3,436,
        218,0,1995,1990,1,0,0,0,1995,1991,1,0,0,0,1995,1992,1,0,0,0,1995,
        1993,1,0,0,0,1995,1994,1,0,0,0,1996,315,1,0,0,0,1997,1998,5,235,
        0,0,1998,1999,5,12,0,0,1999,2002,7,1,0,0,2000,2001,5,4,0,0,2001,
        2003,5,28,0,0,2002,2000,1,0,0,0,2002,2003,1,0,0,0,2003,2004,1,0,
        0,0,2004,2005,5,13,0,0,2005,317,1,0,0,0,2006,2007,5,446,0,0,2007,
        319,1,0,0,0,2008,2009,5,229,0,0,2009,2014,3,322,161,0,2010,2011,
        5,4,0,0,2011,2013,3,322,161,0,2012,2010,1,0,0,0,2013,2016,1,0,0,
        0,2014,2012,1,0,0,0,2014,2015,1,0,0,0,2015,2017,1,0,0,0,2016,2014,
        1,0,0,0,2017,2018,5,20,0,0,2018,321,1,0,0,0,2019,2024,3,324,162,
        0,2020,2024,3,326,163,0,2021,2024,3,328,164,0,2022,2024,3,330,165,
        0,2023,2019,1,0,0,0,2023,2020,1,0,0,0,2023,2021,1,0,0,0,2023,2022,
        1,0,0,0,2024,323,1,0,0,0,2025,2026,5,446,0,0,2026,2027,5,29,0,0,
        2027,2028,3,294,147,0,2028,325,1,0,0,0,2029,2030,5,446,0,0,2030,
        2031,5,29,0,0,2031,2032,3,300,150,0,2032,327,1,0,0,0,2033,2034,5,
        446,0,0,2034,2035,5,29,0,0,2035,2036,3,306,153,0,2036,329,1,0,0,
        0,2037,2038,5,446,0,0,2038,2039,5,29,0,0,2039,2040,3,312,156,0,2040,
        331,1,0,0,0,2041,2042,5,246,0,0,2042,2044,3,334,167,0,2043,2045,
        3,336,168,0,2044,2043,1,0,0,0,2044,2045,1,0,0,0,2045,2046,1,0,0,
        0,2046,2049,5,20,0,0,2047,2050,3,362,181,0,2048,2050,3,354,177,0,
        2049,2047,1,0,0,0,2049,2048,1,0,0,0,2050,333,1,0,0,0,2051,2055,5,
        446,0,0,2052,2055,3,404,202,0,2053,2055,3,658,329,0,2054,2051,1,
        0,0,0,2054,2052,1,0,0,0,2054,2053,1,0,0,0,2055,335,1,0,0,0,2056,
        2057,5,12,0,0,2057,2058,3,338,169,0,2058,2059,5,13,0,0,2059,337,
        1,0,0,0,2060,2065,3,340,170,0,2061,2062,5,4,0,0,2062,2064,3,340,
        170,0,2063,2061,1,0,0,0,2064,2067,1,0,0,0,2065,2063,1,0,0,0,2065,
        2066,1,0,0,0,2066,339,1,0,0,0,2067,2065,1,0,0,0,2068,2075,3,342,
        171,0,2069,2075,3,344,172,0,2070,2075,3,346,173,0,2071,2075,3,348,
        174,0,2072,2075,3,350,175,0,2073,2075,3,352,176,0,2074,2068,1,0,
        0,0,2074,2069,1,0,0,0,2074,2070,1,0,0,0,2074,2071,1,0,0,0,2074,2072,
        1,0,0,0,2074,2073,1,0,0,0,2075,341,1,0,0,0,2076,2077,5,230,0,0,2077,
        2079,5,446,0,0,2078,2080,5,286,0,0,2079,2078,1,0,0,0,2079,2080,1,
        0,0,0,2080,343,1,0,0,0,2081,2082,5,232,0,0,2082,2084,5,446,0,0,2083,
        2085,5,286,0,0,2084,2083,1,0,0,0,2084,2085,1,0,0,0,2085,345,1,0,
        0,0,2086,2087,5,231,0,0,2087,2089,5,446,0,0,2088,2090,5,286,0,0,
        2089,2088,1,0,0,0,2089,2090,1,0,0,0,2090,347,1,0,0,0,2091,2094,5,
        235,0,0,2092,2095,5,446,0,0,2093,2095,3,658,329,0,2094,2092,1,0,
        0,0,2094,2093,1,0,0,0,2095,2097,1,0,0,0,2096,2098,5,286,0,0,2097,
        2096,1,0,0,0,2097,2098,1,0,0,0,2098,349,1,0,0,0,2099,2100,5,237,
        0,0,2100,2101,5,446,0,0,2101,351,1,0,0,0,2102,2103,5,238,0,0,2103,
        2104,5,446,0,0,2104,353,1,0,0,0,2105,2107,5,193,0,0,2106,2108,3,
        100,50,0,2107,2106,1,0,0,0,2107,2108,1,0,0,0,2108,2110,1,0,0,0,2109,
        2111,3,360,180,0,2110,2109,1,0,0,0,2110,2111,1,0,0,0,2111,2112,1,
        0,0,0,2112,2114,5,204,0,0,2113,2115,3,334,167,0,2114,2113,1,0,0,
        0,2114,2115,1,0,0,0,2115,2116,1,0,0,0,2116,2117,5,20,0,0,2117,355,
        1,0,0,0,2118,2120,5,18,0,0,2119,2121,5,12,0,0,2120,2119,1,0,0,0,
        2120,2121,1,0,0,0,2121,2124,1,0,0,0,2122,2125,5,446,0,0,2123,2125,
        3,436,218,0,2124,2122,1,0,0,0,2124,2123,1,0,0,0,2125,2127,1,0,0,
        0,2126,2128,5,13,0,0,2127,2126,1,0,0,0,2127,2128,1,0,0,0,2128,357,
        1,0,0,0,2129,2130,3,620,310,0,2130,2131,5,15,0,0,2131,359,1,0,0,
        0,2132,2134,3,362,181,0,2133,2132,1,0,0,0,2134,2135,1,0,0,0,2135,
        2133,1,0,0,0,2135,2136,1,0,0,0,2136,361,1,0,0,0,2137,2176,3,396,
        198,0,2138,2176,3,410,205,0,2139,2176,3,472,236,0,2140,2176,3,474,
        237,0,2141,2176,3,476,238,0,2142,2176,3,478,239,0,2143,2176,3,500,
        250,0,2144,2176,3,508,254,0,2145,2176,3,510,255,0,2146,2176,3,534,
        267,0,2147,2176,3,556,278,0,2148,2176,3,576,288,0,2149,2176,3,578,
        289,0,2150,2176,3,580,290,0,2151,2176,3,590,295,0,2152,2176,3,612,
        306,0,2153,2176,3,616,308,0,2154,2176,3,618,309,0,2155,2176,3,622,
        311,0,2156,2176,3,626,313,0,2157,2176,3,636,318,0,2158,2176,3,640,
        320,0,2159,2176,3,642,321,0,2160,2176,3,644,322,0,2161,2176,3,646,
        323,0,2162,2176,3,650,325,0,2163,2176,3,388,194,0,2164,2176,3,386,
        193,0,2165,2176,3,384,192,0,2166,2176,3,358,179,0,2167,2176,3,240,
        120,0,2168,2176,3,242,121,0,2169,2176,3,370,185,0,2170,2176,3,366,
        183,0,2171,2176,3,104,52,0,2172,2176,3,364,182,0,2173,2176,3,32,
        16,0,2174,2176,3,90,45,0,2175,2137,1,0,0,0,2175,2138,1,0,0,0,2175,
        2139,1,0,0,0,2175,2140,1,0,0,0,2175,2141,1,0,0,0,2175,2142,1,0,0,
        0,2175,2143,1,0,0,0,2175,2144,1,0,0,0,2175,2145,1,0,0,0,2175,2146,
        1,0,0,0,2175,2147,1,0,0,0,2175,2148,1,0,0,0,2175,2149,1,0,0,0,2175,
        2150,1,0,0,0,2175,2151,1,0,0,0,2175,2152,1,0,0,0,2175,2153,1,0,0,
        0,2175,2154,1,0,0,0,2175,2155,1,0,0,0,2175,2156,1,0,0,0,2175,2157,
        1,0,0,0,2175,2158,1,0,0,0,2175,2159,1,0,0,0,2175,2160,1,0,0,0,2175,
        2161,1,0,0,0,2175,2162,1,0,0,0,2175,2163,1,0,0,0,2175,2164,1,0,0,
        0,2175,2165,1,0,0,0,2175,2166,1,0,0,0,2175,2167,1,0,0,0,2175,2168,
        1,0,0,0,2175,2169,1,0,0,0,2175,2170,1,0,0,0,2175,2171,1,0,0,0,2175,
        2172,1,0,0,0,2175,2173,1,0,0,0,2175,2174,1,0,0,0,2176,363,1,0,0,
        0,2177,2178,5,278,0,0,2178,2179,5,163,0,0,2179,2180,5,252,0,0,2180,
        2181,3,20,10,0,2181,2182,3,416,208,0,2182,2183,5,20,0,0,2183,365,
        1,0,0,0,2184,2185,5,288,0,0,2185,2186,5,1,0,0,2186,2187,5,115,0,
        0,2187,2192,3,368,184,0,2188,2189,5,4,0,0,2189,2191,3,368,184,0,
        2190,2188,1,0,0,0,2191,2194,1,0,0,0,2192,2190,1,0,0,0,2192,2193,
        1,0,0,0,2193,2195,1,0,0,0,2194,2192,1,0,0,0,2195,2197,3,638,319,
        0,2196,2198,3,628,314,0,2197,2196,1,0,0,0,2197,2198,1,0,0,0,2198,
        2200,1,0,0,0,2199,2201,3,632,316,0,2200,2199,1,0,0,0,2200,2201,1,
        0,0,0,2201,2206,1,0,0,0,2202,2203,5,8,0,0,2203,2204,3,244,122,0,
        2204,2205,5,9,0,0,2205,2207,1,0,0,0,2206,2202,1,0,0,0,2206,2207,
        1,0,0,0,2207,2208,1,0,0,0,2208,2209,5,20,0,0,2209,367,1,0,0,0,2210,
        2214,3,20,10,0,2211,2214,3,356,178,0,2212,2214,5,29,0,0,2213,2210,
        1,0,0,0,2213,2211,1,0,0,0,2213,2212,1,0,0,0,2214,2223,1,0,0,0,2215,
        2219,5,4,0,0,2216,2220,3,20,10,0,2217,2220,3,356,178,0,2218,2220,
        5,29,0,0,2219,2216,1,0,0,0,2219,2217,1,0,0,0,2219,2218,1,0,0,0,2220,
        2222,1,0,0,0,2221,2215,1,0,0,0,2222,2225,1,0,0,0,2223,2221,1,0,0,
        0,2223,2224,1,0,0,0,2224,2227,1,0,0,0,2225,2223,1,0,0,0,2226,2228,
        3,394,197,0,2227,2226,1,0,0,0,2227,2228,1,0,0,0,2228,2230,1,0,0,
        0,2229,2231,3,628,314,0,2230,2229,1,0,0,0,2230,2231,1,0,0,0,2231,
        369,1,0,0,0,2232,2233,5,275,0,0,2233,2234,3,372,186,0,2234,2235,
        5,20,0,0,2235,2236,3,374,187,0,2236,2237,5,20,0,0,2237,371,1,0,0,
        0,2238,2241,3,20,10,0,2239,2241,3,356,178,0,2240,2238,1,0,0,0,2240,
        2239,1,0,0,0,2241,2249,1,0,0,0,2242,2245,5,4,0,0,2243,2246,3,20,
        10,0,2244,2246,3,356,178,0,2245,2243,1,0,0,0,2245,2244,1,0,0,0,2246,
        2248,1,0,0,0,2247,2242,1,0,0,0,2248,2251,1,0,0,0,2249,2247,1,0,0,
        0,2249,2250,1,0,0,0,2250,2256,1,0,0,0,2251,2249,1,0,0,0,2252,2253,
        5,8,0,0,2253,2254,3,244,122,0,2254,2255,5,9,0,0,2255,2257,1,0,0,
        0,2256,2252,1,0,0,0,2256,2257,1,0,0,0,2257,373,1,0,0,0,2258,2259,
        5,361,0,0,2259,2264,5,29,0,0,2260,2261,5,12,0,0,2261,2262,3,376,
        188,0,2262,2263,5,13,0,0,2263,2265,1,0,0,0,2264,2260,1,0,0,0,2264,
        2265,1,0,0,0,2265,375,1,0,0,0,2266,2271,3,378,189,0,2267,2268,5,
        4,0,0,2268,2270,3,378,189,0,2269,2267,1,0,0,0,2270,2273,1,0,0,0,
        2271,2269,1,0,0,0,2271,2272,1,0,0,0,2272,2275,1,0,0,0,2273,2271,
        1,0,0,0,2274,2266,1,0,0,0,2274,2275,1,0,0,0,2275,377,1,0,0,0,2276,
        2277,3,382,191,0,2277,2278,5,29,0,0,2278,2283,3,380,190,0,2279,2280,
        5,4,0,0,2280,2282,3,380,190,0,2281,2279,1,0,0,0,2282,2285,1,0,0,
        0,2283,2281,1,0,0,0,2283,2284,1,0,0,0,2284,379,1,0,0,0,2285,2283,
        1,0,0,0,2286,2295,5,447,0,0,2287,2295,5,449,0,0,2288,2295,5,446,
        0,0,2289,2295,3,294,147,0,2290,2295,3,306,153,0,2291,2295,3,312,
        156,0,2292,2295,3,20,10,0,2293,2295,3,356,178,0,2294,2286,1,0,0,
        0,2294,2287,1,0,0,0,2294,2288,1,0,0,0,2294,2289,1,0,0,0,2294,2290,
        1,0,0,0,2294,2291,1,0,0,0,2294,2292,1,0,0,0,2294,2293,1,0,0,0,2295,
        381,1,0,0,0,2296,2297,7,27,0,0,2297,383,1,0,0,0,2298,2299,5,262,
        0,0,2299,2300,5,1,0,0,2300,2301,5,161,0,0,2301,2304,1,0,0,0,2302,
        2305,3,20,10,0,2303,2305,3,356,178,0,2304,2302,1,0,0,0,2304,2303,
        1,0,0,0,2305,2313,1,0,0,0,2306,2309,5,4,0,0,2307,2310,3,20,10,0,
        2308,2310,3,356,178,0,2309,2307,1,0,0,0,2309,2308,1,0,0,0,2310,2312,
        1,0,0,0,2311,2306,1,0,0,0,2312,2315,1,0,0,0,2313,2311,1,0,0,0,2313,
        2314,1,0,0,0,2314,2317,1,0,0,0,2315,2313,1,0,0,0,2316,2318,3,628,
        314,0,2317,2316,1,0,0,0,2317,2318,1,0,0,0,2318,2320,1,0,0,0,2319,
        2321,3,632,316,0,2320,2319,1,0,0,0,2320,2321,1,0,0,0,2321,2326,1,
        0,0,0,2322,2323,5,8,0,0,2323,2324,3,244,122,0,2324,2325,5,9,0,0,
        2325,2327,1,0,0,0,2326,2322,1,0,0,0,2326,2327,1,0,0,0,2327,2328,
        1,0,0,0,2328,2329,5,20,0,0,2329,385,1,0,0,0,2330,2331,5,262,0,0,
        2331,2332,5,1,0,0,2332,2333,5,265,0,0,2333,2336,1,0,0,0,2334,2337,
        3,20,10,0,2335,2337,3,356,178,0,2336,2334,1,0,0,0,2336,2335,1,0,
        0,0,2337,2345,1,0,0,0,2338,2341,5,4,0,0,2339,2342,3,20,10,0,2340,
        2342,3,356,178,0,2341,2339,1,0,0,0,2341,2340,1,0,0,0,2342,2344,1,
        0,0,0,2343,2338,1,0,0,0,2344,2347,1,0,0,0,2345,2343,1,0,0,0,2345,
        2346,1,0,0,0,2346,2349,1,0,0,0,2347,2345,1,0,0,0,2348,2350,3,628,
        314,0,2349,2348,1,0,0,0,2349,2350,1,0,0,0,2350,2352,1,0,0,0,2351,
        2353,3,632,316,0,2352,2351,1,0,0,0,2352,2353,1,0,0,0,2353,2358,1,
        0,0,0,2354,2355,5,8,0,0,2355,2356,3,244,122,0,2356,2357,5,9,0,0,
        2357,2359,1,0,0,0,2358,2354,1,0,0,0,2358,2359,1,0,0,0,2359,2360,
        1,0,0,0,2360,2361,5,20,0,0,2361,387,1,0,0,0,2362,2364,5,22,0,0,2363,
        2362,1,0,0,0,2363,2364,1,0,0,0,2364,2365,1,0,0,0,2365,2367,5,262,
        0,0,2366,2368,3,390,195,0,2367,2366,1,0,0,0,2367,2368,1,0,0,0,2368,
        2369,1,0,0,0,2369,2374,3,392,196,0,2370,2371,5,4,0,0,2371,2373,3,
        392,196,0,2372,2370,1,0,0,0,2373,2376,1,0,0,0,2374,2372,1,0,0,0,
        2374,2375,1,0,0,0,2375,2378,1,0,0,0,2376,2374,1,0,0,0,2377,2379,
        3,632,316,0,2378,2377,1,0,0,0,2378,2379,1,0,0,0,2379,2384,1,0,0,
        0,2380,2381,5,8,0,0,2381,2382,3,244,122,0,2382,2383,5,9,0,0,2383,
        2385,1,0,0,0,2384,2380,1,0,0,0,2384,2385,1,0,0,0,2385,2387,1,0,0,
        0,2386,2388,5,20,0,0,2387,2386,1,0,0,0,2387,2388,1,0,0,0,2388,389,
        1,0,0,0,2389,2390,5,8,0,0,2390,2391,5,446,0,0,2391,2392,5,9,0,0,
        2392,391,1,0,0,0,2393,2397,3,20,10,0,2394,2397,3,356,178,0,2395,
        2397,5,29,0,0,2396,2393,1,0,0,0,2396,2394,1,0,0,0,2396,2395,1,0,
        0,0,2397,2402,1,0,0,0,2398,2399,5,4,0,0,2399,2401,3,20,10,0,2400,
        2398,1,0,0,0,2401,2404,1,0,0,0,2402,2400,1,0,0,0,2402,2403,1,0,0,
        0,2403,2406,1,0,0,0,2404,2402,1,0,0,0,2405,2407,3,394,197,0,2406,
        2405,1,0,0,0,2406,2407,1,0,0,0,2407,2409,1,0,0,0,2408,2410,3,628,
        314,0,2409,2408,1,0,0,0,2409,2410,1,0,0,0,2410,393,1,0,0,0,2411,
        2415,5,189,0,0,2412,2416,3,356,178,0,2413,2416,5,449,0,0,2414,2416,
        3,20,10,0,2415,2412,1,0,0,0,2415,2413,1,0,0,0,2415,2414,1,0,0,0,
        2416,2422,1,0,0,0,2417,2418,5,12,0,0,2418,2419,5,446,0,0,2419,2420,
        5,29,0,0,2420,2421,5,446,0,0,2421,2423,5,13,0,0,2422,2417,1,0,0,
        0,2422,2423,1,0,0,0,2423,395,1,0,0,0,2424,2427,7,28,0,0,2425,2428,
        3,20,10,0,2426,2428,3,356,178,0,2427,2425,1,0,0,0,2427,2426,1,0,
        0,0,2428,2431,1,0,0,0,2429,2430,5,253,0,0,2430,2432,3,574,287,0,
        2431,2429,1,0,0,0,2431,2432,1,0,0,0,2432,2441,1,0,0,0,2433,2434,
        5,212,0,0,2434,2437,3,404,202,0,2435,2436,5,253,0,0,2436,2438,3,
        408,204,0,2437,2435,1,0,0,0,2437,2438,1,0,0,0,2438,2442,1,0,0,0,
        2439,2440,5,212,0,0,2440,2442,3,406,203,0,2441,2433,1,0,0,0,2441,
        2439,1,0,0,0,2441,2442,1,0,0,0,2442,2447,1,0,0,0,2443,2444,5,12,
        0,0,2444,2445,3,244,122,0,2445,2446,5,13,0,0,2446,2448,1,0,0,0,2447,
        2443,1,0,0,0,2447,2448,1,0,0,0,2448,2453,1,0,0,0,2449,2450,5,8,0,
        0,2450,2451,3,244,122,0,2451,2452,5,9,0,0,2452,2454,1,0,0,0,2453,
        2449,1,0,0,0,2453,2454,1,0,0,0,2454,2460,1,0,0,0,2455,2461,5,256,
        0,0,2456,2461,5,210,0,0,2457,2461,5,255,0,0,2458,2459,5,210,0,0,
        2459,2461,5,255,0,0,2460,2455,1,0,0,0,2460,2456,1,0,0,0,2460,2457,
        1,0,0,0,2460,2458,1,0,0,0,2460,2461,1,0,0,0,2461,2463,1,0,0,0,2462,
        2464,5,20,0,0,2463,2462,1,0,0,0,2463,2464,1,0,0,0,2464,2466,1,0,
        0,0,2465,2467,3,398,199,0,2466,2465,1,0,0,0,2466,2467,1,0,0,0,2467,
        2469,1,0,0,0,2468,2470,5,20,0,0,2469,2468,1,0,0,0,2469,2470,1,0,
        0,0,2470,397,1,0,0,0,2471,2477,5,196,0,0,2472,2478,3,280,140,0,2473,
        2478,3,250,125,0,2474,2478,3,400,200,0,2475,2478,3,402,201,0,2476,
        2478,3,104,52,0,2477,2472,1,0,0,0,2477,2473,1,0,0,0,2477,2474,1,
        0,0,0,2477,2475,1,0,0,0,2477,2476,1,0,0,0,2478,2480,1,0,0,0,2479,
        2471,1,0,0,0,2480,2481,1,0,0,0,2481,2479,1,0,0,0,2481,2482,1,0,0,
        0,2482,399,1,0,0,0,2483,2484,5,210,0,0,2484,2496,3,20,10,0,2485,
        2486,5,12,0,0,2486,2491,3,252,126,0,2487,2488,5,4,0,0,2488,2490,
        3,252,126,0,2489,2487,1,0,0,0,2490,2493,1,0,0,0,2491,2489,1,0,0,
        0,2491,2492,1,0,0,0,2492,2494,1,0,0,0,2493,2491,1,0,0,0,2494,2495,
        5,13,0,0,2495,2497,1,0,0,0,2496,2485,1,0,0,0,2496,2497,1,0,0,0,2497,
        401,1,0,0,0,2498,2499,5,330,0,0,2499,2511,3,20,10,0,2500,2501,5,
        12,0,0,2501,2506,3,252,126,0,2502,2503,5,4,0,0,2503,2505,3,252,126,
        0,2504,2502,1,0,0,0,2505,2508,1,0,0,0,2506,2504,1,0,0,0,2506,2507,
        1,0,0,0,2507,2509,1,0,0,0,2508,2506,1,0,0,0,2509,2510,5,13,0,0,2510,
        2512,1,0,0,0,2511,2500,1,0,0,0,2511,2512,1,0,0,0,2512,403,1,0,0,
        0,2513,2514,7,29,0,0,2514,405,1,0,0,0,2515,2516,3,20,10,0,2516,407,
        1,0,0,0,2517,2518,5,446,0,0,2518,409,1,0,0,0,2519,2522,7,30,0,0,
        2520,2523,3,20,10,0,2521,2523,3,356,178,0,2522,2520,1,0,0,0,2522,
        2521,1,0,0,0,2523,2529,1,0,0,0,2524,2527,5,253,0,0,2525,2528,3,574,
        287,0,2526,2528,3,86,43,0,2527,2525,1,0,0,0,2527,2526,1,0,0,0,2528,
        2530,1,0,0,0,2529,2524,1,0,0,0,2529,2530,1,0,0,0,2530,2532,1,0,0,
        0,2531,2533,3,416,208,0,2532,2531,1,0,0,0,2532,2533,1,0,0,0,2533,
        2538,1,0,0,0,2534,2535,5,12,0,0,2535,2536,3,244,122,0,2536,2537,
        5,13,0,0,2537,2539,1,0,0,0,2538,2534,1,0,0,0,2538,2539,1,0,0,0,2539,
        2541,1,0,0,0,2540,2542,5,20,0,0,2541,2540,1,0,0,0,2541,2542,1,0,
        0,0,2542,2547,1,0,0,0,2543,2544,5,8,0,0,2544,2545,3,244,122,0,2545,
        2546,5,9,0,0,2546,2548,1,0,0,0,2547,2543,1,0,0,0,2547,2548,1,0,0,
        0,2548,2549,1,0,0,0,2549,2551,5,20,0,0,2550,2552,3,470,235,0,2551,
        2550,1,0,0,0,2551,2552,1,0,0,0,2552,2554,1,0,0,0,2553,2555,3,412,
        206,0,2554,2553,1,0,0,0,2554,2555,1,0,0,0,2555,411,1,0,0,0,2556,
        2557,5,206,0,0,2557,2561,5,81,0,0,2558,2559,7,31,0,0,2559,2560,7,
        32,0,0,2560,2562,3,52,26,0,2561,2558,1,0,0,0,2561,2562,1,0,0,0,2562,
        2564,1,0,0,0,2563,2565,5,80,0,0,2564,2563,1,0,0,0,2564,2565,1,0,
        0,0,2565,2566,1,0,0,0,2566,2567,5,236,0,0,2567,2570,5,12,0,0,2568,
        2571,3,20,10,0,2569,2571,5,29,0,0,2570,2568,1,0,0,0,2570,2569,1,
        0,0,0,2571,2572,1,0,0,0,2572,2573,5,216,0,0,2573,2574,3,20,10,0,
        2574,2575,5,13,0,0,2575,2576,5,268,0,0,2576,2590,3,20,10,0,2577,
        2578,5,12,0,0,2578,2583,3,252,126,0,2579,2580,5,4,0,0,2580,2582,
        3,252,126,0,2581,2579,1,0,0,0,2582,2585,1,0,0,0,2583,2581,1,0,0,
        0,2583,2584,1,0,0,0,2584,2586,1,0,0,0,2585,2583,1,0,0,0,2586,2587,
        5,13,0,0,2587,2589,1,0,0,0,2588,2577,1,0,0,0,2589,2592,1,0,0,0,2590,
        2588,1,0,0,0,2590,2591,1,0,0,0,2591,2596,1,0,0,0,2592,2590,1,0,0,
        0,2593,2595,3,414,207,0,2594,2593,1,0,0,0,2595,2598,1,0,0,0,2596,
        2594,1,0,0,0,2596,2597,1,0,0,0,2597,2599,1,0,0,0,2598,2596,1,0,0,
        0,2599,2600,5,242,0,0,2600,2601,5,243,0,0,2601,2604,3,20,10,0,2602,
        2603,5,253,0,0,2603,2605,3,574,287,0,2604,2602,1,0,0,0,2604,2605,
        1,0,0,0,2605,2606,1,0,0,0,2606,2607,5,240,0,0,2607,2608,5,241,0,
        0,2608,2609,5,198,0,0,2609,2610,5,447,0,0,2610,2612,5,48,0,0,2611,
        2613,5,72,0,0,2612,2611,1,0,0,0,2612,2613,1,0,0,0,2613,2614,1,0,
        0,0,2614,2615,5,22,0,0,2615,2618,1,0,0,0,2616,2618,3,104,52,0,2617,
        2556,1,0,0,0,2617,2616,1,0,0,0,2618,413,1,0,0,0,2619,2621,5,244,
        0,0,2620,2622,5,104,0,0,2621,2620,1,0,0,0,2621,2622,1,0,0,0,2622,
        2623,1,0,0,0,2623,2631,5,12,0,0,2624,2632,5,446,0,0,2625,2632,3,
        658,329,0,2626,2629,3,20,10,0,2627,2628,5,216,0,0,2628,2630,3,574,
        287,0,2629,2627,1,0,0,0,2629,2630,1,0,0,0,2630,2632,1,0,0,0,2631,
        2624,1,0,0,0,2631,2625,1,0,0,0,2631,2626,1,0,0,0,2632,2645,1,0,0,
        0,2633,2641,5,4,0,0,2634,2642,5,446,0,0,2635,2642,3,658,329,0,2636,
        2639,3,20,10,0,2637,2638,5,216,0,0,2638,2640,3,574,287,0,2639,2637,
        1,0,0,0,2639,2640,1,0,0,0,2640,2642,1,0,0,0,2641,2634,1,0,0,0,2641,
        2635,1,0,0,0,2641,2636,1,0,0,0,2642,2644,1,0,0,0,2643,2633,1,0,0,
        0,2644,2647,1,0,0,0,2645,2643,1,0,0,0,2645,2646,1,0,0,0,2646,2648,
        1,0,0,0,2647,2645,1,0,0,0,2648,2649,5,13,0,0,2649,415,1,0,0,0,2650,
        2659,5,12,0,0,2651,2656,3,418,209,0,2652,2653,5,4,0,0,2653,2655,
        3,418,209,0,2654,2652,1,0,0,0,2655,2658,1,0,0,0,2656,2654,1,0,0,
        0,2656,2657,1,0,0,0,2657,2660,1,0,0,0,2658,2656,1,0,0,0,2659,2651,
        1,0,0,0,2659,2660,1,0,0,0,2660,2661,1,0,0,0,2661,2662,5,13,0,0,2662,
        417,1,0,0,0,2663,2675,3,420,210,0,2664,2675,3,422,211,0,2665,2675,
        3,294,147,0,2666,2675,3,436,218,0,2667,2668,5,446,0,0,2668,2675,
        5,251,0,0,2669,2670,5,395,0,0,2670,2671,5,12,0,0,2671,2672,5,336,
        0,0,2672,2675,5,13,0,0,2673,2675,3,356,178,0,2674,2663,1,0,0,0,2674,
        2664,1,0,0,0,2674,2665,1,0,0,0,2674,2666,1,0,0,0,2674,2667,1,0,0,
        0,2674,2669,1,0,0,0,2674,2673,1,0,0,0,2675,419,1,0,0,0,2676,2679,
        5,447,0,0,2677,2678,5,19,0,0,2678,2680,5,447,0,0,2679,2677,1,0,0,
        0,2679,2680,1,0,0,0,2680,421,1,0,0,0,2681,2694,5,447,0,0,2682,2694,
        3,430,215,0,2683,2694,5,446,0,0,2684,2685,3,244,122,0,2685,2688,
        5,12,0,0,2686,2689,3,492,246,0,2687,2689,3,282,141,0,2688,2686,1,
        0,0,0,2688,2687,1,0,0,0,2689,2690,1,0,0,0,2690,2691,5,13,0,0,2691,
        2694,1,0,0,0,2692,2694,3,424,212,0,2693,2681,1,0,0,0,2693,2682,1,
        0,0,0,2693,2683,1,0,0,0,2693,2684,1,0,0,0,2693,2692,1,0,0,0,2694,
        423,1,0,0,0,2695,2700,3,428,214,0,2696,2700,3,448,224,0,2697,2700,
        3,450,225,0,2698,2700,3,426,213,0,2699,2695,1,0,0,0,2699,2696,1,
        0,0,0,2699,2697,1,0,0,0,2699,2698,1,0,0,0,2700,425,1,0,0,0,2701,
        2702,5,446,0,0,2702,2705,5,12,0,0,2703,2706,3,422,211,0,2704,2706,
        3,436,218,0,2705,2703,1,0,0,0,2705,2704,1,0,0,0,2706,2707,1,0,0,
        0,2707,2708,5,13,0,0,2708,427,1,0,0,0,2709,2710,5,232,0,0,2710,2711,
        5,12,0,0,2711,2712,3,422,211,0,2712,2713,5,13,0,0,2713,2720,1,0,
        0,0,2714,2715,5,64,0,0,2715,2716,5,12,0,0,2716,2717,3,436,218,0,
        2717,2718,5,13,0,0,2718,2720,1,0,0,0,2719,2709,1,0,0,0,2719,2714,
        1,0,0,0,2720,429,1,0,0,0,2721,2723,5,12,0,0,2722,2721,1,0,0,0,2722,
        2723,1,0,0,0,2723,2724,1,0,0,0,2724,2729,3,432,216,0,2725,2726,7,
        14,0,0,2726,2728,3,432,216,0,2727,2725,1,0,0,0,2728,2731,1,0,0,0,
        2729,2727,1,0,0,0,2729,2730,1,0,0,0,2730,2733,1,0,0,0,2731,2729,
        1,0,0,0,2732,2734,5,13,0,0,2733,2732,1,0,0,0,2733,2734,1,0,0,0,2734,
        431,1,0,0,0,2735,2740,3,434,217,0,2736,2737,7,33,0,0,2737,2739,3,
        434,217,0,2738,2736,1,0,0,0,2739,2742,1,0,0,0,2740,2738,1,0,0,0,
        2740,2741,1,0,0,0,2741,433,1,0,0,0,2742,2740,1,0,0,0,2743,2756,5,
        446,0,0,2744,2756,5,447,0,0,2745,2756,3,424,212,0,2746,2747,3,244,
        122,0,2747,2748,5,12,0,0,2748,2749,3,282,141,0,2749,2750,5,13,0,
        0,2750,2756,1,0,0,0,2751,2752,5,12,0,0,2752,2753,3,430,215,0,2753,
        2754,5,13,0,0,2754,2756,1,0,0,0,2755,2743,1,0,0,0,2755,2744,1,0,
        0,0,2755,2745,1,0,0,0,2755,2746,1,0,0,0,2755,2751,1,0,0,0,2756,435,
        1,0,0,0,2757,2762,5,449,0,0,2758,2762,3,526,263,0,2759,2762,3,438,
        219,0,2760,2762,5,2,0,0,2761,2757,1,0,0,0,2761,2758,1,0,0,0,2761,
        2759,1,0,0,0,2761,2760,1,0,0,0,2762,437,1,0,0,0,2763,2775,3,460,
        230,0,2764,2775,3,464,232,0,2765,2775,3,468,234,0,2766,2775,3,458,
        229,0,2767,2775,3,456,228,0,2768,2775,3,452,226,0,2769,2775,3,454,
        227,0,2770,2775,3,448,224,0,2771,2775,3,444,222,0,2772,2775,3,442,
        221,0,2773,2775,3,440,220,0,2774,2763,1,0,0,0,2774,2764,1,0,0,0,
        2774,2765,1,0,0,0,2774,2766,1,0,0,0,2774,2767,1,0,0,0,2774,2768,
        1,0,0,0,2774,2769,1,0,0,0,2774,2770,1,0,0,0,2774,2771,1,0,0,0,2774,
        2772,1,0,0,0,2774,2773,1,0,0,0,2775,439,1,0,0,0,2776,2777,5,446,
        0,0,2777,2781,5,12,0,0,2778,2782,5,446,0,0,2779,2782,3,254,127,0,
        2780,2782,3,282,141,0,2781,2778,1,0,0,0,2781,2779,1,0,0,0,2781,2780,
        1,0,0,0,2782,2783,1,0,0,0,2783,2784,5,13,0,0,2784,441,1,0,0,0,2785,
        2786,5,267,0,0,2786,2787,5,12,0,0,2787,2788,3,436,218,0,2788,2789,
        5,13,0,0,2789,443,1,0,0,0,2790,2791,5,129,0,0,2791,2792,5,12,0,0,
        2792,2793,3,446,223,0,2793,2794,5,13,0,0,2794,445,1,0,0,0,2795,2796,
        7,34,0,0,2796,447,1,0,0,0,2797,2798,5,396,0,0,2798,2803,5,12,0,0,
        2799,2804,5,446,0,0,2800,2804,5,442,0,0,2801,2804,5,334,0,0,2802,
        2804,3,282,141,0,2803,2799,1,0,0,0,2803,2800,1,0,0,0,2803,2801,1,
        0,0,0,2803,2802,1,0,0,0,2804,2805,1,0,0,0,2805,2806,5,13,0,0,2806,
        449,1,0,0,0,2807,2808,5,395,0,0,2808,2813,5,12,0,0,2809,2814,5,446,
        0,0,2810,2814,5,442,0,0,2811,2814,5,334,0,0,2812,2814,3,282,141,
        0,2813,2809,1,0,0,0,2813,2810,1,0,0,0,2813,2811,1,0,0,0,2813,2812,
        1,0,0,0,2814,2815,1,0,0,0,2815,2816,5,13,0,0,2816,451,1,0,0,0,2817,
        2818,5,95,0,0,2818,2820,5,12,0,0,2819,2821,5,12,0,0,2820,2819,1,
        0,0,0,2820,2821,1,0,0,0,2821,2822,1,0,0,0,2822,2824,3,436,218,0,
        2823,2825,5,13,0,0,2824,2823,1,0,0,0,2824,2825,1,0,0,0,2825,2826,
        1,0,0,0,2826,2827,5,4,0,0,2827,2828,3,422,211,0,2828,2829,5,13,0,
        0,2829,453,1,0,0,0,2830,2831,5,96,0,0,2831,2832,5,12,0,0,2832,2833,
        3,436,218,0,2833,2834,5,4,0,0,2834,2835,3,422,211,0,2835,2836,5,
        13,0,0,2836,455,1,0,0,0,2837,2840,3,526,263,0,2838,2840,5,395,0,
        0,2839,2837,1,0,0,0,2839,2838,1,0,0,0,2840,2841,1,0,0,0,2841,2845,
        5,12,0,0,2842,2846,3,422,211,0,2843,2846,5,446,0,0,2844,2846,3,282,
        141,0,2845,2842,1,0,0,0,2845,2843,1,0,0,0,2845,2844,1,0,0,0,2846,
        2847,1,0,0,0,2847,2848,5,13,0,0,2848,457,1,0,0,0,2849,2850,5,235,
        0,0,2850,2853,5,12,0,0,2851,2854,3,436,218,0,2852,2854,3,422,211,
        0,2853,2851,1,0,0,0,2853,2852,1,0,0,0,2854,2855,1,0,0,0,2855,2858,
        5,4,0,0,2856,2859,3,422,211,0,2857,2859,5,28,0,0,2858,2856,1,0,0,
        0,2858,2857,1,0,0,0,2859,2860,1,0,0,0,2860,2861,5,13,0,0,2861,459,
        1,0,0,0,2862,2863,5,439,0,0,2863,2864,5,12,0,0,2864,2869,3,462,231,
        0,2865,2866,5,4,0,0,2866,2868,3,462,231,0,2867,2865,1,0,0,0,2868,
        2871,1,0,0,0,2869,2867,1,0,0,0,2869,2870,1,0,0,0,2870,2872,1,0,0,
        0,2871,2869,1,0,0,0,2872,2873,5,13,0,0,2873,461,1,0,0,0,2874,2880,
        5,446,0,0,2875,2877,5,441,0,0,2876,2875,1,0,0,0,2876,2877,1,0,0,
        0,2877,2878,1,0,0,0,2878,2880,5,449,0,0,2879,2874,1,0,0,0,2879,2876,
        1,0,0,0,2880,463,1,0,0,0,2881,2882,5,440,0,0,2882,2883,5,12,0,0,
        2883,2888,3,466,233,0,2884,2885,5,4,0,0,2885,2887,3,466,233,0,2886,
        2884,1,0,0,0,2887,2890,1,0,0,0,2888,2886,1,0,0,0,2888,2889,1,0,0,
        0,2889,2891,1,0,0,0,2890,2888,1,0,0,0,2891,2892,5,13,0,0,2892,465,
        1,0,0,0,2893,2899,5,446,0,0,2894,2896,5,441,0,0,2895,2894,1,0,0,
        0,2895,2896,1,0,0,0,2896,2897,1,0,0,0,2897,2899,5,449,0,0,2898,2893,
        1,0,0,0,2898,2895,1,0,0,0,2899,467,1,0,0,0,2900,2908,3,526,263,0,
        2901,2908,5,449,0,0,2902,2908,3,444,222,0,2903,2908,3,452,226,0,
        2904,2908,5,2,0,0,2905,2908,3,458,229,0,2906,2908,3,454,227,0,2907,
        2900,1,0,0,0,2907,2901,1,0,0,0,2907,2902,1,0,0,0,2907,2903,1,0,0,
        0,2907,2904,1,0,0,0,2907,2905,1,0,0,0,2907,2906,1,0,0,0,2908,2911,
        1,0,0,0,2909,2910,7,35,0,0,2910,2912,3,436,218,0,2911,2909,1,0,0,
        0,2912,2913,1,0,0,0,2913,2911,1,0,0,0,2913,2914,1,0,0,0,2914,469,
        1,0,0,0,2915,2920,3,280,140,0,2916,2920,3,250,125,0,2917,2920,3,
        400,200,0,2918,2920,3,402,201,0,2919,2915,1,0,0,0,2919,2916,1,0,
        0,0,2919,2917,1,0,0,0,2919,2918,1,0,0,0,2920,2921,1,0,0,0,2921,2919,
        1,0,0,0,2921,2922,1,0,0,0,2922,471,1,0,0,0,2923,2925,5,202,0,0,2924,
        2926,5,12,0,0,2925,2924,1,0,0,0,2925,2926,1,0,0,0,2926,2927,1,0,
        0,0,2927,2929,3,312,156,0,2928,2930,5,13,0,0,2929,2928,1,0,0,0,2929,
        2930,1,0,0,0,2930,2932,1,0,0,0,2931,2933,5,20,0,0,2932,2931,1,0,
        0,0,2932,2933,1,0,0,0,2933,473,1,0,0,0,2934,2935,5,391,0,0,2935,
        2936,5,12,0,0,2936,2937,3,244,122,0,2937,2938,5,13,0,0,2938,2939,
        5,20,0,0,2939,475,1,0,0,0,2940,2947,5,248,0,0,2941,2944,5,8,0,0,
        2942,2945,3,244,122,0,2943,2945,5,396,0,0,2944,2942,1,0,0,0,2944,
        2943,1,0,0,0,2945,2946,1,0,0,0,2946,2948,5,9,0,0,2947,2941,1,0,0,
        0,2947,2948,1,0,0,0,2948,2950,1,0,0,0,2949,2951,5,12,0,0,2950,2949,
        1,0,0,0,2950,2951,1,0,0,0,2951,2953,1,0,0,0,2952,2954,3,312,156,
        0,2953,2952,1,0,0,0,2953,2954,1,0,0,0,2954,2956,1,0,0,0,2955,2957,
        5,13,0,0,2956,2955,1,0,0,0,2956,2957,1,0,0,0,2957,2959,1,0,0,0,2958,
        2960,5,20,0,0,2959,2958,1,0,0,0,2959,2960,1,0,0,0,2960,477,1,0,0,
        0,2961,2966,5,252,0,0,2962,2963,5,12,0,0,2963,2964,3,480,240,0,2964,
        2965,5,13,0,0,2965,2967,1,0,0,0,2966,2962,1,0,0,0,2966,2967,1,0,
        0,0,2967,2969,1,0,0,0,2968,2970,5,20,0,0,2969,2968,1,0,0,0,2969,
        2970,1,0,0,0,2970,479,1,0,0,0,2971,2974,3,436,218,0,2972,2973,5,
        4,0,0,2973,2975,3,482,241,0,2974,2972,1,0,0,0,2974,2975,1,0,0,0,
        2975,2978,1,0,0,0,2976,2978,3,482,241,0,2977,2971,1,0,0,0,2977,2976,
        1,0,0,0,2978,481,1,0,0,0,2979,3007,5,254,0,0,2980,3007,3,420,210,
        0,2981,3007,3,244,122,0,2982,3007,3,488,244,0,2983,2984,3,244,122,
        0,2984,2985,7,36,0,0,2985,2986,3,488,244,0,2986,3007,1,0,0,0,2987,
        3007,3,484,242,0,2988,3007,3,486,243,0,2989,2990,3,244,122,0,2990,
        2991,5,12,0,0,2991,2992,3,490,245,0,2992,2993,5,13,0,0,2993,3007,
        1,0,0,0,2994,2997,5,237,0,0,2995,2998,3,20,10,0,2996,2998,3,356,
        178,0,2997,2995,1,0,0,0,2997,2996,1,0,0,0,2998,3001,1,0,0,0,2999,
        3000,5,253,0,0,3000,3002,3,574,287,0,3001,2999,1,0,0,0,3001,3002,
        1,0,0,0,3002,3003,1,0,0,0,3003,3004,5,270,0,0,3004,3005,7,37,0,0,
        3005,3007,1,0,0,0,3006,2979,1,0,0,0,3006,2980,1,0,0,0,3006,2981,
        1,0,0,0,3006,2982,1,0,0,0,3006,2983,1,0,0,0,3006,2987,1,0,0,0,3006,
        2988,1,0,0,0,3006,2989,1,0,0,0,3006,2994,1,0,0,0,3007,483,1,0,0,
        0,3008,3009,3,244,122,0,3009,3012,5,12,0,0,3010,3013,3,492,246,0,
        3011,3013,3,494,247,0,3012,3010,1,0,0,0,3012,3011,1,0,0,0,3013,3014,
        1,0,0,0,3014,3015,5,13,0,0,3015,3016,3,498,249,0,3016,3017,3,420,
        210,0,3017,485,1,0,0,0,3018,3019,3,244,122,0,3019,3020,5,12,0,0,
        3020,3021,3,496,248,0,3021,3022,5,13,0,0,3022,3023,5,270,0,0,3023,
        3024,3,488,244,0,3024,487,1,0,0,0,3025,3026,7,38,0,0,3026,489,1,
        0,0,0,3027,3028,7,39,0,0,3028,491,1,0,0,0,3029,3030,7,40,0,0,3030,
        493,1,0,0,0,3031,3032,7,41,0,0,3032,495,1,0,0,0,3033,3034,7,42,0,
        0,3034,497,1,0,0,0,3035,3036,7,43,0,0,3036,499,1,0,0,0,3037,3039,
        5,263,0,0,3038,3040,3,502,251,0,3039,3038,1,0,0,0,3039,3040,1,0,
        0,0,3040,3041,1,0,0,0,3041,3046,3,506,253,0,3042,3043,5,8,0,0,3043,
        3044,3,244,122,0,3044,3045,5,9,0,0,3045,3047,1,0,0,0,3046,3042,1,
        0,0,0,3046,3047,1,0,0,0,3047,3049,1,0,0,0,3048,3050,3,280,140,0,
        3049,3048,1,0,0,0,3049,3050,1,0,0,0,3050,3051,1,0,0,0,3051,3052,
        5,20,0,0,3052,3082,1,0,0,0,3053,3054,5,263,0,0,3054,3055,3,20,10,
        0,3055,3056,3,394,197,0,3056,3063,1,0,0,0,3057,3058,5,4,0,0,3058,
        3059,3,20,10,0,3059,3060,3,394,197,0,3060,3062,1,0,0,0,3061,3057,
        1,0,0,0,3062,3065,1,0,0,0,3063,3061,1,0,0,0,3063,3064,1,0,0,0,3064,
        3067,1,0,0,0,3065,3063,1,0,0,0,3066,3068,3,628,314,0,3067,3066,1,
        0,0,0,3067,3068,1,0,0,0,3068,3070,1,0,0,0,3069,3071,3,632,316,0,
        3070,3069,1,0,0,0,3070,3071,1,0,0,0,3071,3076,1,0,0,0,3072,3073,
        5,8,0,0,3073,3074,3,244,122,0,3074,3075,5,9,0,0,3075,3077,1,0,0,
        0,3076,3072,1,0,0,0,3076,3077,1,0,0,0,3077,3079,1,0,0,0,3078,3080,
        5,20,0,0,3079,3078,1,0,0,0,3079,3080,1,0,0,0,3080,3082,1,0,0,0,3081,
        3037,1,0,0,0,3081,3053,1,0,0,0,3082,501,1,0,0,0,3083,3085,7,44,0,
        0,3084,3083,1,0,0,0,3084,3085,1,0,0,0,3085,3086,1,0,0,0,3086,3091,
        3,504,252,0,3087,3088,5,4,0,0,3088,3090,3,504,252,0,3089,3087,1,
        0,0,0,3090,3093,1,0,0,0,3091,3089,1,0,0,0,3091,3092,1,0,0,0,3092,
        503,1,0,0,0,3093,3091,1,0,0,0,3094,3095,7,45,0,0,3095,505,1,0,0,
        0,3096,3100,3,20,10,0,3097,3100,3,356,178,0,3098,3100,5,29,0,0,3099,
        3096,1,0,0,0,3099,3097,1,0,0,0,3099,3098,1,0,0,0,3100,3105,1,0,0,
        0,3101,3102,5,4,0,0,3102,3104,3,20,10,0,3103,3101,1,0,0,0,3104,3107,
        1,0,0,0,3105,3103,1,0,0,0,3105,3106,1,0,0,0,3106,3109,1,0,0,0,3107,
        3105,1,0,0,0,3108,3110,3,394,197,0,3109,3108,1,0,0,0,3109,3110,1,
        0,0,0,3110,3112,1,0,0,0,3111,3113,3,628,314,0,3112,3111,1,0,0,0,
        3112,3113,1,0,0,0,3113,3115,1,0,0,0,3114,3116,3,632,316,0,3115,3114,
        1,0,0,0,3115,3116,1,0,0,0,3116,507,1,0,0,0,3117,3125,5,392,0,0,3118,
        3126,3,500,250,0,3119,3126,3,396,198,0,3120,3126,3,410,205,0,3121,
        3126,3,534,267,0,3122,3126,3,650,325,0,3123,3126,3,388,194,0,3124,
        3126,3,366,183,0,3125,3118,1,0,0,0,3125,3119,1,0,0,0,3125,3120,1,
        0,0,0,3125,3121,1,0,0,0,3125,3122,1,0,0,0,3125,3123,1,0,0,0,3125,
        3124,1,0,0,0,3126,3131,1,0,0,0,3127,3128,5,8,0,0,3128,3129,3,244,
        122,0,3129,3130,5,9,0,0,3130,3132,1,0,0,0,3131,3127,1,0,0,0,3131,
        3132,1,0,0,0,3132,3134,1,0,0,0,3133,3135,3,470,235,0,3134,3133,1,
        0,0,0,3134,3135,1,0,0,0,3135,3137,1,0,0,0,3136,3138,5,20,0,0,3137,
        3136,1,0,0,0,3137,3138,1,0,0,0,3138,509,1,0,0,0,3139,3146,3,512,
        256,0,3140,3146,3,516,258,0,3141,3146,3,520,260,0,3142,3146,3,524,
        262,0,3143,3146,3,528,264,0,3144,3146,3,532,266,0,3145,3139,1,0,
        0,0,3145,3140,1,0,0,0,3145,3141,1,0,0,0,3145,3142,1,0,0,0,3145,3143,
        1,0,0,0,3145,3144,1,0,0,0,3146,511,1,0,0,0,3147,3148,3,514,257,0,
        3148,3149,5,30,0,0,3149,3150,3,294,147,0,3150,3151,5,20,0,0,3151,
        513,1,0,0,0,3152,3153,5,446,0,0,3153,515,1,0,0,0,3154,3155,3,518,
        259,0,3155,3156,5,30,0,0,3156,3158,3,422,211,0,3157,3159,5,20,0,
        0,3158,3157,1,0,0,0,3158,3159,1,0,0,0,3159,517,1,0,0,0,3160,3161,
        5,446,0,0,3161,519,1,0,0,0,3162,3163,3,522,261,0,3163,3164,5,30,
        0,0,3164,3165,3,420,210,0,3165,3166,5,20,0,0,3166,521,1,0,0,0,3167,
        3168,5,446,0,0,3168,523,1,0,0,0,3169,3170,3,526,263,0,3170,3172,
        5,30,0,0,3171,3173,3,436,218,0,3172,3171,1,0,0,0,3172,3173,1,0,0,
        0,3173,3175,1,0,0,0,3174,3176,5,20,0,0,3175,3174,1,0,0,0,3175,3176,
        1,0,0,0,3176,525,1,0,0,0,3177,3180,5,446,0,0,3178,3180,3,658,329,
        0,3179,3177,1,0,0,0,3179,3178,1,0,0,0,3180,527,1,0,0,0,3181,3182,
        3,530,265,0,3182,3183,5,12,0,0,3183,3188,3,252,126,0,3184,3185,5,
        4,0,0,3185,3187,3,252,126,0,3186,3184,1,0,0,0,3187,3190,1,0,0,0,
        3188,3186,1,0,0,0,3188,3189,1,0,0,0,3189,3191,1,0,0,0,3190,3188,
        1,0,0,0,3191,3192,5,13,0,0,3192,3193,5,20,0,0,3193,529,1,0,0,0,3194,
        3195,5,446,0,0,3195,531,1,0,0,0,3196,3197,3,244,122,0,3197,3200,
        5,12,0,0,3198,3201,3,280,140,0,3199,3201,3,250,125,0,3200,3198,1,
        0,0,0,3200,3199,1,0,0,0,3201,3209,1,0,0,0,3202,3205,5,4,0,0,3203,
        3206,3,280,140,0,3204,3206,3,250,125,0,3205,3203,1,0,0,0,3205,3204,
        1,0,0,0,3206,3208,1,0,0,0,3207,3202,1,0,0,0,3208,3211,1,0,0,0,3209,
        3207,1,0,0,0,3209,3210,1,0,0,0,3210,3212,1,0,0,0,3211,3209,1,0,0,
        0,3212,3213,5,13,0,0,3213,3214,5,20,0,0,3214,533,1,0,0,0,3215,3216,
        7,46,0,0,3216,3219,3,20,10,0,3217,3218,5,253,0,0,3218,3220,3,574,
        287,0,3219,3217,1,0,0,0,3219,3220,1,0,0,0,3220,3225,1,0,0,0,3221,
        3222,5,12,0,0,3222,3223,3,536,268,0,3223,3224,5,13,0,0,3224,3226,
        1,0,0,0,3225,3221,1,0,0,0,3225,3226,1,0,0,0,3226,3231,1,0,0,0,3227,
        3228,5,8,0,0,3228,3229,3,244,122,0,3229,3230,5,9,0,0,3230,3232,1,
        0,0,0,3231,3227,1,0,0,0,3231,3232,1,0,0,0,3232,3235,1,0,0,0,3233,
        3234,5,215,0,0,3234,3236,5,256,0,0,3235,3233,1,0,0,0,3235,3236,1,
        0,0,0,3236,3242,1,0,0,0,3237,3243,5,20,0,0,3238,3239,5,18,0,0,3239,
        3243,3,554,277,0,3240,3241,5,20,0,0,3241,3243,3,44,22,0,3242,3237,
        1,0,0,0,3242,3238,1,0,0,0,3242,3240,1,0,0,0,3243,535,1,0,0,0,3244,
        3251,3,538,269,0,3245,3248,3,550,275,0,3246,3247,5,4,0,0,3247,3249,
        3,538,269,0,3248,3246,1,0,0,0,3248,3249,1,0,0,0,3249,3251,1,0,0,
        0,3250,3244,1,0,0,0,3250,3245,1,0,0,0,3251,537,1,0,0,0,3252,3257,
        3,540,270,0,3253,3254,5,4,0,0,3254,3256,3,540,270,0,3255,3253,1,
        0,0,0,3256,3259,1,0,0,0,3257,3255,1,0,0,0,3257,3258,1,0,0,0,3258,
        539,1,0,0,0,3259,3257,1,0,0,0,3260,3261,3,542,271,0,3261,3262,5,
        30,0,0,3262,3263,3,420,210,0,3263,3277,1,0,0,0,3264,3265,3,544,272,
        0,3265,3266,5,30,0,0,3266,3267,3,422,211,0,3267,3277,1,0,0,0,3268,
        3269,3,546,273,0,3269,3270,5,30,0,0,3270,3271,3,294,147,0,3271,3277,
        1,0,0,0,3272,3273,3,548,274,0,3273,3274,5,30,0,0,3274,3275,3,436,
        218,0,3275,3277,1,0,0,0,3276,3260,1,0,0,0,3276,3264,1,0,0,0,3276,
        3268,1,0,0,0,3276,3272,1,0,0,0,3277,541,1,0,0,0,3278,3279,5,446,
        0,0,3279,543,1,0,0,0,3280,3281,5,446,0,0,3281,545,1,0,0,0,3282,3283,
        5,446,0,0,3283,547,1,0,0,0,3284,3285,5,446,0,0,3285,549,1,0,0,0,
        3286,3291,3,552,276,0,3287,3288,5,4,0,0,3288,3290,3,552,276,0,3289,
        3287,1,0,0,0,3290,3293,1,0,0,0,3291,3289,1,0,0,0,3291,3292,1,0,0,
        0,3292,551,1,0,0,0,3293,3291,1,0,0,0,3294,3299,3,420,210,0,3295,
        3299,3,422,211,0,3296,3299,3,294,147,0,3297,3299,3,436,218,0,3298,
        3294,1,0,0,0,3298,3295,1,0,0,0,3298,3296,1,0,0,0,3298,3297,1,0,0,
        0,3299,553,1,0,0,0,3300,3301,5,235,0,0,3301,3302,5,12,0,0,3302,3305,
        7,1,0,0,3303,3304,5,4,0,0,3304,3306,5,28,0,0,3305,3303,1,0,0,0,3305,
        3306,1,0,0,0,3306,3307,1,0,0,0,3307,3308,5,13,0,0,3308,555,1,0,0,
        0,3309,3310,5,269,0,0,3310,3311,3,558,279,0,3311,3313,3,566,283,
        0,3312,3314,3,568,284,0,3313,3312,1,0,0,0,3313,3314,1,0,0,0,3314,
        3326,1,0,0,0,3315,3316,5,193,0,0,3316,3317,5,269,0,0,3317,3318,3,
        558,279,0,3318,3320,3,566,283,0,3319,3321,3,568,284,0,3320,3319,
        1,0,0,0,3320,3321,1,0,0,0,3321,3322,1,0,0,0,3322,3323,5,204,0,0,
        3323,3324,5,20,0,0,3324,3326,1,0,0,0,3325,3309,1,0,0,0,3325,3315,
        1,0,0,0,3326,557,1,0,0,0,3327,3330,3,560,280,0,3328,3330,3,564,282,
        0,3329,3327,1,0,0,0,3329,3328,1,0,0,0,3330,559,1,0,0,0,3331,3333,
        5,441,0,0,3332,3331,1,0,0,0,3332,3333,1,0,0,0,3333,3335,1,0,0,0,
        3334,3336,5,12,0,0,3335,3334,1,0,0,0,3335,3336,1,0,0,0,3336,3337,
        1,0,0,0,3337,3339,3,570,285,0,3338,3340,5,13,0,0,3339,3338,1,0,0,
        0,3339,3340,1,0,0,0,3340,3354,1,0,0,0,3341,3343,7,47,0,0,3342,3344,
        5,441,0,0,3343,3342,1,0,0,0,3343,3344,1,0,0,0,3344,3346,1,0,0,0,
        3345,3347,5,12,0,0,3346,3345,1,0,0,0,3346,3347,1,0,0,0,3347,3348,
        1,0,0,0,3348,3350,3,570,285,0,3349,3351,5,13,0,0,3350,3349,1,0,0,
        0,3350,3351,1,0,0,0,3351,3353,1,0,0,0,3352,3341,1,0,0,0,3353,3356,
        1,0,0,0,3354,3352,1,0,0,0,3354,3355,1,0,0,0,3355,561,1,0,0,0,3356,
        3354,1,0,0,0,3357,3358,5,12,0,0,3358,3359,5,12,0,0,3359,3360,5,12,
        0,0,3360,3361,3,570,285,0,3361,3362,5,13,0,0,3362,3363,7,47,0,0,
        3363,3364,5,12,0,0,3364,3365,3,570,285,0,3365,3366,5,13,0,0,3366,
        3367,5,13,0,0,3367,3368,7,47,0,0,3368,3369,5,12,0,0,3369,3370,5,
        12,0,0,3370,3371,3,570,285,0,3371,3372,5,13,0,0,3372,3373,7,47,0,
        0,3373,3374,5,12,0,0,3374,3375,3,570,285,0,3375,3376,5,13,0,0,3376,
        3377,5,13,0,0,3377,3378,5,13,0,0,3378,563,1,0,0,0,3379,3382,3,562,
        281,0,3380,3381,7,47,0,0,3381,3383,3,562,281,0,3382,3380,1,0,0,0,
        3382,3383,1,0,0,0,3383,565,1,0,0,0,3384,3385,5,393,0,0,3385,3401,
        3,362,181,0,3386,3387,5,393,0,0,3387,3389,5,193,0,0,3388,3390,5,
        20,0,0,3389,3388,1,0,0,0,3389,3390,1,0,0,0,3390,3392,1,0,0,0,3391,
        3393,3,362,181,0,3392,3391,1,0,0,0,3393,3394,1,0,0,0,3394,3392,1,
        0,0,0,3394,3395,1,0,0,0,3395,3396,1,0,0,0,3396,3398,5,204,0,0,3397,
        3399,5,20,0,0,3398,3397,1,0,0,0,3398,3399,1,0,0,0,3399,3401,1,0,
        0,0,3400,3384,1,0,0,0,3400,3386,1,0,0,0,3401,567,1,0,0,0,3402,3403,
        5,203,0,0,3403,3419,3,362,181,0,3404,3405,5,203,0,0,3405,3407,5,
        193,0,0,3406,3408,5,20,0,0,3407,3406,1,0,0,0,3407,3408,1,0,0,0,3408,
        3410,1,0,0,0,3409,3411,3,362,181,0,3410,3409,1,0,0,0,3411,3412,1,
        0,0,0,3412,3410,1,0,0,0,3412,3413,1,0,0,0,3413,3414,1,0,0,0,3414,
        3416,5,204,0,0,3415,3417,5,20,0,0,3416,3415,1,0,0,0,3416,3417,1,
        0,0,0,3417,3419,1,0,0,0,3418,3402,1,0,0,0,3418,3404,1,0,0,0,3419,
        569,1,0,0,0,3420,3458,3,294,147,0,3421,3458,3,572,286,0,3422,3424,
        5,441,0,0,3423,3425,5,12,0,0,3424,3423,1,0,0,0,3424,3425,1,0,0,0,
        3425,3426,1,0,0,0,3426,3428,3,570,285,0,3427,3429,5,13,0,0,3428,
        3427,1,0,0,0,3428,3429,1,0,0,0,3429,3458,1,0,0,0,3430,3432,5,441,
        0,0,3431,3433,5,12,0,0,3432,3431,1,0,0,0,3432,3433,1,0,0,0,3433,
        3434,1,0,0,0,3434,3437,3,430,215,0,3435,3438,3,498,249,0,3436,3438,
        5,29,0,0,3437,3435,1,0,0,0,3437,3436,1,0,0,0,3438,3448,1,0,0,0,3439,
        3449,5,447,0,0,3440,3449,5,446,0,0,3441,3443,5,12,0,0,3442,3441,
        1,0,0,0,3442,3443,1,0,0,0,3443,3444,1,0,0,0,3444,3446,3,430,215,
        0,3445,3447,5,13,0,0,3446,3445,1,0,0,0,3446,3447,1,0,0,0,3447,3449,
        1,0,0,0,3448,3439,1,0,0,0,3448,3440,1,0,0,0,3448,3442,1,0,0,0,3449,
        3451,1,0,0,0,3450,3452,5,13,0,0,3451,3450,1,0,0,0,3451,3452,1,0,
        0,0,3452,3458,1,0,0,0,3453,3454,5,12,0,0,3454,3455,3,570,285,0,3455,
        3456,5,13,0,0,3456,3458,1,0,0,0,3457,3420,1,0,0,0,3457,3421,1,0,
        0,0,3457,3422,1,0,0,0,3457,3430,1,0,0,0,3457,3453,1,0,0,0,3458,571,
        1,0,0,0,3459,3460,3,244,122,0,3460,3461,5,12,0,0,3461,3462,3,490,
        245,0,3462,3463,5,13,0,0,3463,3464,7,36,0,0,3464,3465,3,294,147,
        0,3465,3576,1,0,0,0,3466,3467,3,244,122,0,3467,3470,5,12,0,0,3468,
        3471,3,490,245,0,3469,3471,3,492,246,0,3470,3468,1,0,0,0,3470,3469,
        1,0,0,0,3471,3472,1,0,0,0,3472,3477,5,13,0,0,3473,3478,3,498,249,
        0,3474,3478,5,270,0,0,3475,3478,5,271,0,0,3476,3478,5,29,0,0,3477,
        3473,1,0,0,0,3477,3474,1,0,0,0,3477,3475,1,0,0,0,3477,3476,1,0,0,
        0,3478,3487,1,0,0,0,3479,3488,5,447,0,0,3480,3482,5,12,0,0,3481,
        3480,1,0,0,0,3481,3482,1,0,0,0,3482,3483,1,0,0,0,3483,3485,3,430,
        215,0,3484,3486,5,13,0,0,3485,3484,1,0,0,0,3485,3486,1,0,0,0,3486,
        3488,1,0,0,0,3487,3479,1,0,0,0,3487,3481,1,0,0,0,3488,3576,1,0,0,
        0,3489,3490,3,20,10,0,3490,3491,7,36,0,0,3491,3492,7,48,0,0,3492,
        3576,1,0,0,0,3493,3496,5,237,0,0,3494,3497,3,356,178,0,3495,3497,
        3,20,10,0,3496,3494,1,0,0,0,3496,3495,1,0,0,0,3497,3500,1,0,0,0,
        3498,3499,5,253,0,0,3499,3501,3,574,287,0,3500,3498,1,0,0,0,3500,
        3501,1,0,0,0,3501,3502,1,0,0,0,3502,3503,7,36,0,0,3503,3504,7,48,
        0,0,3504,3576,1,0,0,0,3505,3510,5,446,0,0,3506,3510,3,436,218,0,
        3507,3510,3,658,329,0,3508,3510,3,282,141,0,3509,3505,1,0,0,0,3509,
        3506,1,0,0,0,3509,3507,1,0,0,0,3509,3508,1,0,0,0,3510,3513,1,0,0,
        0,3511,3514,3,498,249,0,3512,3514,5,29,0,0,3513,3511,1,0,0,0,3513,
        3512,1,0,0,0,3514,3526,1,0,0,0,3515,3527,5,449,0,0,3516,3527,5,447,
        0,0,3517,3519,5,12,0,0,3518,3517,1,0,0,0,3518,3519,1,0,0,0,3519,
        3520,1,0,0,0,3520,3522,3,430,215,0,3521,3523,5,13,0,0,3522,3521,
        1,0,0,0,3522,3523,1,0,0,0,3523,3527,1,0,0,0,3524,3527,5,446,0,0,
        3525,3527,5,2,0,0,3526,3515,1,0,0,0,3526,3516,1,0,0,0,3526,3518,
        1,0,0,0,3526,3524,1,0,0,0,3526,3525,1,0,0,0,3527,3576,1,0,0,0,3528,
        3529,3,244,122,0,3529,3530,7,36,0,0,3530,3531,3,488,244,0,3531,3576,
        1,0,0,0,3532,3533,5,441,0,0,3533,3534,5,446,0,0,3534,3535,5,12,0,
        0,3535,3536,5,165,0,0,3536,3576,5,13,0,0,3537,3540,3,422,211,0,3538,
        3541,3,498,249,0,3539,3541,5,29,0,0,3540,3538,1,0,0,0,3540,3539,
        1,0,0,0,3541,3551,1,0,0,0,3542,3552,5,447,0,0,3543,3552,5,446,0,
        0,3544,3546,5,12,0,0,3545,3544,1,0,0,0,3545,3546,1,0,0,0,3546,3547,
        1,0,0,0,3547,3549,3,430,215,0,3548,3550,5,13,0,0,3549,3548,1,0,0,
        0,3549,3550,1,0,0,0,3550,3552,1,0,0,0,3551,3542,1,0,0,0,3551,3543,
        1,0,0,0,3551,3545,1,0,0,0,3552,3576,1,0,0,0,3553,3555,5,12,0,0,3554,
        3553,1,0,0,0,3554,3555,1,0,0,0,3555,3556,1,0,0,0,3556,3558,3,430,
        215,0,3557,3559,5,13,0,0,3558,3557,1,0,0,0,3558,3559,1,0,0,0,3559,
        3562,1,0,0,0,3560,3563,3,498,249,0,3561,3563,5,29,0,0,3562,3560,
        1,0,0,0,3562,3561,1,0,0,0,3563,3573,1,0,0,0,3564,3574,5,447,0,0,
        3565,3574,5,446,0,0,3566,3568,5,12,0,0,3567,3566,1,0,0,0,3567,3568,
        1,0,0,0,3568,3569,1,0,0,0,3569,3571,3,430,215,0,3570,3572,5,13,0,
        0,3571,3570,1,0,0,0,3571,3572,1,0,0,0,3572,3574,1,0,0,0,3573,3564,
        1,0,0,0,3573,3565,1,0,0,0,3573,3567,1,0,0,0,3574,3576,1,0,0,0,3575,
        3459,1,0,0,0,3575,3466,1,0,0,0,3575,3489,1,0,0,0,3575,3493,1,0,0,
        0,3575,3509,1,0,0,0,3575,3528,1,0,0,0,3575,3532,1,0,0,0,3575,3537,
        1,0,0,0,3575,3554,1,0,0,0,3576,573,1,0,0,0,3577,3578,5,446,0,0,3578,
        575,1,0,0,0,3579,3581,5,290,0,0,3580,3582,5,193,0,0,3581,3580,1,
        0,0,0,3581,3582,1,0,0,0,3582,3583,1,0,0,0,3583,3585,3,360,180,0,
        3584,3586,5,204,0,0,3585,3584,1,0,0,0,3585,3586,1,0,0,0,3586,3588,
        1,0,0,0,3587,3589,5,20,0,0,3588,3587,1,0,0,0,3588,3589,1,0,0,0,3589,
        3590,1,0,0,0,3590,3591,5,224,0,0,3591,3592,3,558,279,0,3592,3593,
        5,20,0,0,3593,577,1,0,0,0,3594,3595,5,287,0,0,3595,3596,3,558,279,
        0,3596,3606,5,290,0,0,3597,3599,5,193,0,0,3598,3600,3,362,181,0,
        3599,3598,1,0,0,0,3600,3601,1,0,0,0,3601,3599,1,0,0,0,3601,3602,
        1,0,0,0,3602,3603,1,0,0,0,3603,3604,5,204,0,0,3604,3607,1,0,0,0,
        3605,3607,3,362,181,0,3606,3597,1,0,0,0,3606,3605,1,0,0,0,3607,3608,
        1,0,0,0,3608,3609,5,20,0,0,3609,579,1,0,0,0,3610,3611,5,194,0,0,
        3611,3612,3,582,291,0,3612,3613,5,214,0,0,3613,3614,5,193,0,0,3614,
        3634,3,584,292,0,3615,3617,5,203,0,0,3616,3618,5,15,0,0,3617,3616,
        1,0,0,0,3617,3618,1,0,0,0,3618,3620,1,0,0,0,3619,3621,5,193,0,0,
        3620,3619,1,0,0,0,3620,3621,1,0,0,0,3621,3625,1,0,0,0,3622,3624,
        3,362,181,0,3623,3622,1,0,0,0,3624,3627,1,0,0,0,3625,3623,1,0,0,
        0,3625,3626,1,0,0,0,3626,3629,1,0,0,0,3627,3625,1,0,0,0,3628,3630,
        5,204,0,0,3629,3628,1,0,0,0,3629,3630,1,0,0,0,3630,3632,1,0,0,0,
        3631,3633,5,20,0,0,3632,3631,1,0,0,0,3632,3633,1,0,0,0,3633,3635,
        1,0,0,0,3634,3615,1,0,0,0,3634,3635,1,0,0,0,3635,3636,1,0,0,0,3636,
        3637,5,204,0,0,3637,3638,5,20,0,0,3638,581,1,0,0,0,3639,3643,3,422,
        211,0,3640,3643,3,436,218,0,3641,3643,5,446,0,0,3642,3639,1,0,0,
        0,3642,3640,1,0,0,0,3642,3641,1,0,0,0,3643,583,1,0,0,0,3644,3646,
        3,586,293,0,3645,3644,1,0,0,0,3646,3647,1,0,0,0,3647,3645,1,0,0,
        0,3647,3648,1,0,0,0,3648,585,1,0,0,0,3649,3650,5,12,0,0,3650,3651,
        3,588,294,0,3651,3652,5,13,0,0,3652,3662,5,15,0,0,3653,3655,5,193,
        0,0,3654,3656,3,362,181,0,3655,3654,1,0,0,0,3656,3657,1,0,0,0,3657,
        3655,1,0,0,0,3657,3658,1,0,0,0,3658,3659,1,0,0,0,3659,3660,5,204,
        0,0,3660,3663,1,0,0,0,3661,3663,3,362,181,0,3662,3653,1,0,0,0,3662,
        3661,1,0,0,0,3663,3665,1,0,0,0,3664,3666,5,20,0,0,3665,3664,1,0,
        0,0,3665,3666,1,0,0,0,3666,587,1,0,0,0,3667,3677,3,300,150,0,3668,
        3673,3,312,156,0,3669,3670,5,4,0,0,3670,3672,3,312,156,0,3671,3669,
        1,0,0,0,3672,3675,1,0,0,0,3673,3671,1,0,0,0,3673,3674,1,0,0,0,3674,
        3677,1,0,0,0,3675,3673,1,0,0,0,3676,3667,1,0,0,0,3676,3668,1,0,0,
        0,3677,589,1,0,0,0,3678,3681,5,274,0,0,3679,3682,3,592,296,0,3680,
        3682,3,594,297,0,3681,3679,1,0,0,0,3681,3680,1,0,0,0,3682,3685,1,
        0,0,0,3683,3684,5,253,0,0,3684,3686,3,574,287,0,3685,3683,1,0,0,
        0,3685,3686,1,0,0,0,3686,3687,1,0,0,0,3687,3688,5,12,0,0,3688,3689,
        3,596,298,0,3689,3690,5,13,0,0,3690,3691,5,20,0,0,3691,591,1,0,0,
        0,3692,3693,3,20,10,0,3693,593,1,0,0,0,3694,3695,3,20,10,0,3695,
        595,1,0,0,0,3696,3701,3,598,299,0,3697,3698,5,4,0,0,3698,3700,3,
        598,299,0,3699,3697,1,0,0,0,3700,3703,1,0,0,0,3701,3699,1,0,0,0,
        3701,3702,1,0,0,0,3702,597,1,0,0,0,3703,3701,1,0,0,0,3704,3705,5,
        50,0,0,3705,3706,5,29,0,0,3706,3796,3,600,300,0,3707,3708,5,51,0,
        0,3708,3709,5,29,0,0,3709,3796,7,49,0,0,3710,3711,5,73,0,0,3711,
        3712,5,29,0,0,3712,3796,7,49,0,0,3713,3714,5,426,0,0,3714,3715,5,
        29,0,0,3715,3796,3,20,10,0,3716,3717,5,74,0,0,3717,3718,5,29,0,0,
        3718,3796,3,570,285,0,3719,3720,5,78,0,0,3720,3721,5,29,0,0,3721,
        3796,3,570,285,0,3722,3723,5,82,0,0,3723,3724,5,29,0,0,3724,3796,
        3,570,285,0,3725,3726,5,84,0,0,3726,3727,5,29,0,0,3727,3796,3,570,
        285,0,3728,3729,5,85,0,0,3729,3730,5,29,0,0,3730,3796,3,570,285,
        0,3731,3732,5,88,0,0,3732,3733,5,29,0,0,3733,3796,3,570,285,0,3734,
        3735,5,90,0,0,3735,3736,5,29,0,0,3736,3796,3,604,302,0,3737,3738,
        5,97,0,0,3738,3739,5,29,0,0,3739,3796,3,604,302,0,3740,3741,5,420,
        0,0,3741,3742,5,29,0,0,3742,3796,3,554,277,0,3743,3744,5,98,0,0,
        3744,3745,5,29,0,0,3745,3796,3,570,285,0,3746,3747,5,99,0,0,3747,
        3748,5,29,0,0,3748,3796,3,570,285,0,3749,3796,3,602,301,0,3750,3751,
        5,100,0,0,3751,3752,5,29,0,0,3752,3796,3,610,305,0,3753,3754,5,104,
        0,0,3754,3755,5,29,0,0,3755,3796,3,610,305,0,3756,3757,5,105,0,0,
        3757,3758,5,29,0,0,3758,3796,3,610,305,0,3759,3760,5,106,0,0,3760,
        3761,5,29,0,0,3761,3796,3,610,305,0,3762,3763,5,107,0,0,3763,3764,
        5,29,0,0,3764,3796,3,610,305,0,3765,3766,5,422,0,0,3766,3767,5,29,
        0,0,3767,3796,3,554,277,0,3768,3769,5,108,0,0,3769,3770,5,29,0,0,
        3770,3796,3,554,277,0,3771,3772,5,424,0,0,3772,3773,5,29,0,0,3773,
        3796,3,554,277,0,3774,3775,5,109,0,0,3775,3776,5,29,0,0,3776,3796,
        3,422,211,0,3777,3778,5,429,0,0,3778,3781,5,29,0,0,3779,3782,3,20,
        10,0,3780,3782,5,2,0,0,3781,3779,1,0,0,0,3781,3780,1,0,0,0,3782,
        3796,1,0,0,0,3783,3784,5,110,0,0,3784,3785,5,29,0,0,3785,3796,3,
        422,211,0,3786,3787,5,399,0,0,3787,3788,5,29,0,0,3788,3796,3,606,
        303,0,3789,3790,5,111,0,0,3790,3791,5,29,0,0,3791,3796,3,606,303,
        0,3792,3793,5,118,0,0,3793,3794,5,29,0,0,3794,3796,3,422,211,0,3795,
        3704,1,0,0,0,3795,3707,1,0,0,0,3795,3710,1,0,0,0,3795,3713,1,0,0,
        0,3795,3716,1,0,0,0,3795,3719,1,0,0,0,3795,3722,1,0,0,0,3795,3725,
        1,0,0,0,3795,3728,1,0,0,0,3795,3731,1,0,0,0,3795,3734,1,0,0,0,3795,
        3737,1,0,0,0,3795,3740,1,0,0,0,3795,3743,1,0,0,0,3795,3746,1,0,0,
        0,3795,3749,1,0,0,0,3795,3750,1,0,0,0,3795,3753,1,0,0,0,3795,3756,
        1,0,0,0,3795,3759,1,0,0,0,3795,3762,1,0,0,0,3795,3765,1,0,0,0,3795,
        3768,1,0,0,0,3795,3771,1,0,0,0,3795,3774,1,0,0,0,3795,3777,1,0,0,
        0,3795,3783,1,0,0,0,3795,3786,1,0,0,0,3795,3789,1,0,0,0,3795,3792,
        1,0,0,0,3796,599,1,0,0,0,3797,3802,5,2,0,0,3798,3799,5,18,0,0,3799,
        3802,3,554,277,0,3800,3802,5,235,0,0,3801,3797,1,0,0,0,3801,3798,
        1,0,0,0,3801,3800,1,0,0,0,3802,601,1,0,0,0,3803,3804,5,119,0,0,3804,
        3809,5,29,0,0,3805,3810,3,608,304,0,3806,3807,5,18,0,0,3807,3810,
        3,554,277,0,3808,3810,5,2,0,0,3809,3805,1,0,0,0,3809,3806,1,0,0,
        0,3809,3808,1,0,0,0,3810,3868,1,0,0,0,3811,3812,5,131,0,0,3812,3817,
        5,29,0,0,3813,3818,3,608,304,0,3814,3815,5,18,0,0,3815,3818,3,554,
        277,0,3816,3818,5,2,0,0,3817,3813,1,0,0,0,3817,3814,1,0,0,0,3817,
        3816,1,0,0,0,3818,3868,1,0,0,0,3819,3820,5,132,0,0,3820,3821,5,29,
        0,0,3821,3868,3,610,305,0,3822,3823,5,134,0,0,3823,3824,5,29,0,0,
        3824,3868,3,610,305,0,3825,3826,5,135,0,0,3826,3827,5,29,0,0,3827,
        3868,3,610,305,0,3828,3829,5,136,0,0,3829,3830,5,29,0,0,3830,3868,
        3,570,285,0,3831,3832,5,137,0,0,3832,3833,5,29,0,0,3833,3868,3,570,
        285,0,3834,3835,5,138,0,0,3835,3836,5,29,0,0,3836,3868,3,570,285,
        0,3837,3838,5,139,0,0,3838,3839,5,29,0,0,3839,3868,3,570,285,0,3840,
        3841,5,140,0,0,3841,3842,5,29,0,0,3842,3868,3,570,285,0,3843,3844,
        5,141,0,0,3844,3845,5,29,0,0,3845,3868,3,570,285,0,3846,3847,5,142,
        0,0,3847,3848,5,29,0,0,3848,3868,3,570,285,0,3849,3850,5,143,0,0,
        3850,3851,5,29,0,0,3851,3868,3,570,285,0,3852,3853,5,144,0,0,3853,
        3854,5,29,0,0,3854,3868,3,570,285,0,3855,3856,5,145,0,0,3856,3857,
        5,29,0,0,3857,3868,3,570,285,0,3858,3859,5,49,0,0,3859,3860,5,29,
        0,0,3860,3868,3,570,285,0,3861,3862,5,146,0,0,3862,3863,5,29,0,0,
        3863,3868,3,570,285,0,3864,3865,5,147,0,0,3865,3866,5,29,0,0,3866,
        3868,3,570,285,0,3867,3803,1,0,0,0,3867,3811,1,0,0,0,3867,3819,1,
        0,0,0,3867,3822,1,0,0,0,3867,3825,1,0,0,0,3867,3828,1,0,0,0,3867,
        3831,1,0,0,0,3867,3834,1,0,0,0,3867,3837,1,0,0,0,3867,3840,1,0,0,
        0,3867,3843,1,0,0,0,3867,3846,1,0,0,0,3867,3849,1,0,0,0,3867,3852,
        1,0,0,0,3867,3855,1,0,0,0,3867,3858,1,0,0,0,3867,3861,1,0,0,0,3867,
        3864,1,0,0,0,3868,603,1,0,0,0,3869,3870,5,446,0,0,3870,605,1,0,0,
        0,3871,3872,5,446,0,0,3872,607,1,0,0,0,3873,3874,5,446,0,0,3874,
        609,1,0,0,0,3875,3876,7,50,0,0,3876,611,1,0,0,0,3877,3878,5,264,
        0,0,3878,3881,3,614,307,0,3879,3880,5,253,0,0,3880,3882,3,408,204,
        0,3881,3879,1,0,0,0,3881,3882,1,0,0,0,3882,3883,1,0,0,0,3883,3884,
        5,268,0,0,3884,3886,3,614,307,0,3885,3887,3,628,314,0,3886,3885,
        1,0,0,0,3886,3887,1,0,0,0,3887,3888,1,0,0,0,3888,3889,5,20,0,0,3889,
        613,1,0,0,0,3890,3893,3,20,10,0,3891,3893,3,356,178,0,3892,3890,
        1,0,0,0,3892,3891,1,0,0,0,3893,615,1,0,0,0,3894,3895,5,257,0,0,3895,
        3896,5,12,0,0,3896,3897,3,530,265,0,3897,3898,5,13,0,0,3898,3899,
        5,20,0,0,3899,617,1,0,0,0,3900,3902,5,255,0,0,3901,3903,5,268,0,
        0,3902,3901,1,0,0,0,3902,3903,1,0,0,0,3903,3904,1,0,0,0,3904,3905,
        3,620,310,0,3905,3906,5,20,0,0,3906,619,1,0,0,0,3907,3908,5,446,
        0,0,3908,621,1,0,0,0,3909,3912,5,284,0,0,3910,3913,3,20,10,0,3911,
        3913,3,356,178,0,3912,3910,1,0,0,0,3912,3911,1,0,0,0,3913,3919,1,
        0,0,0,3914,3917,5,253,0,0,3915,3918,3,574,287,0,3916,3918,3,86,43,
        0,3917,3915,1,0,0,0,3917,3916,1,0,0,0,3918,3920,1,0,0,0,3919,3914,
        1,0,0,0,3919,3920,1,0,0,0,3920,3922,1,0,0,0,3921,3923,3,416,208,
        0,3922,3921,1,0,0,0,3922,3923,1,0,0,0,3923,3928,1,0,0,0,3924,3925,
        5,12,0,0,3925,3926,3,244,122,0,3926,3927,5,13,0,0,3927,3929,1,0,
        0,0,3928,3924,1,0,0,0,3928,3929,1,0,0,0,3929,3931,1,0,0,0,3930,3932,
        5,20,0,0,3931,3930,1,0,0,0,3931,3932,1,0,0,0,3932,3937,1,0,0,0,3933,
        3934,5,8,0,0,3934,3935,3,244,122,0,3935,3936,5,9,0,0,3936,3938,1,
        0,0,0,3937,3933,1,0,0,0,3937,3938,1,0,0,0,3938,3939,1,0,0,0,3939,
        3941,5,20,0,0,3940,3942,3,470,235,0,3941,3940,1,0,0,0,3941,3942,
        1,0,0,0,3942,3946,1,0,0,0,3943,3944,3,412,206,0,3944,3945,5,22,0,
        0,3945,3947,1,0,0,0,3946,3943,1,0,0,0,3946,3947,1,0,0,0,3947,623,
        1,0,0,0,3948,3949,5,253,0,0,3949,3950,5,446,0,0,3950,625,1,0,0,0,
        3951,3952,5,265,0,0,3952,3957,3,20,10,0,3953,3954,5,4,0,0,3954,3956,
        3,20,10,0,3955,3953,1,0,0,0,3956,3959,1,0,0,0,3957,3955,1,0,0,0,
        3957,3958,1,0,0,0,3958,3962,1,0,0,0,3959,3957,1,0,0,0,3960,3963,
        3,624,312,0,3961,3963,3,628,314,0,3962,3960,1,0,0,0,3962,3961,1,
        0,0,0,3962,3963,1,0,0,0,3963,3965,1,0,0,0,3964,3966,5,20,0,0,3965,
        3964,1,0,0,0,3965,3966,1,0,0,0,3966,627,1,0,0,0,3967,3971,5,216,
        0,0,3968,3972,3,574,287,0,3969,3972,3,356,178,0,3970,3972,3,86,43,
        0,3971,3968,1,0,0,0,3971,3969,1,0,0,0,3971,3970,1,0,0,0,3972,3984,
        1,0,0,0,3973,3974,5,12,0,0,3974,3979,3,630,315,0,3975,3976,5,4,0,
        0,3976,3978,3,630,315,0,3977,3975,1,0,0,0,3978,3981,1,0,0,0,3979,
        3977,1,0,0,0,3979,3980,1,0,0,0,3980,3982,1,0,0,0,3981,3979,1,0,0,
        0,3982,3983,5,13,0,0,3983,3985,1,0,0,0,3984,3973,1,0,0,0,3984,3985,
        1,0,0,0,3985,629,1,0,0,0,3986,3991,5,446,0,0,3987,3991,3,658,329,
        0,3988,3991,3,282,141,0,3989,3991,3,86,43,0,3990,3986,1,0,0,0,3990,
        3987,1,0,0,0,3990,3988,1,0,0,0,3990,3989,1,0,0,0,3991,4000,1,0,0,
        0,3992,3998,5,29,0,0,3993,3999,5,446,0,0,3994,3999,3,658,329,0,3995,
        3999,3,86,43,0,3996,3999,3,20,10,0,3997,3999,5,449,0,0,3998,3993,
        1,0,0,0,3998,3994,1,0,0,0,3998,3995,1,0,0,0,3998,3996,1,0,0,0,3998,
        3997,1,0,0,0,3999,4001,1,0,0,0,4000,3992,1,0,0,0,4000,4001,1,0,0,
        0,4001,631,1,0,0,0,4002,4008,5,268,0,0,4003,4009,3,574,287,0,4004,
        4009,3,86,43,0,4005,4009,3,356,178,0,4006,4009,3,658,329,0,4007,
        4009,5,447,0,0,4008,4003,1,0,0,0,4008,4004,1,0,0,0,4008,4005,1,0,
        0,0,4008,4006,1,0,0,0,4008,4007,1,0,0,0,4009,4021,1,0,0,0,4010,4011,
        5,12,0,0,4011,4016,3,634,317,0,4012,4013,5,4,0,0,4013,4015,3,634,
        317,0,4014,4012,1,0,0,0,4015,4018,1,0,0,0,4016,4014,1,0,0,0,4016,
        4017,1,0,0,0,4017,4019,1,0,0,0,4018,4016,1,0,0,0,4019,4020,5,13,
        0,0,4020,4022,1,0,0,0,4021,4010,1,0,0,0,4021,4022,1,0,0,0,4022,633,
        1,0,0,0,4023,4028,5,446,0,0,4024,4028,3,658,329,0,4025,4028,3,282,
        141,0,4026,4028,3,86,43,0,4027,4023,1,0,0,0,4027,4024,1,0,0,0,4027,
        4025,1,0,0,0,4027,4026,1,0,0,0,4028,4056,1,0,0,0,4029,4054,5,29,
        0,0,4030,4055,5,446,0,0,4031,4055,3,658,329,0,4032,4055,3,86,43,
        0,4033,4042,5,12,0,0,4034,4043,5,449,0,0,4035,4043,5,446,0,0,4036,
        4037,5,17,0,0,4037,4038,5,446,0,0,4038,4039,5,12,0,0,4039,4040,5,
        446,0,0,4040,4041,5,13,0,0,4041,4043,5,17,0,0,4042,4034,1,0,0,0,
        4042,4035,1,0,0,0,4042,4036,1,0,0,0,4043,4048,1,0,0,0,4044,4045,
        5,4,0,0,4045,4047,7,51,0,0,4046,4044,1,0,0,0,4047,4050,1,0,0,0,4048,
        4046,1,0,0,0,4048,4049,1,0,0,0,4049,4051,1,0,0,0,4050,4048,1,0,0,
        0,4051,4055,5,13,0,0,4052,4055,3,20,10,0,4053,4055,3,294,147,0,4054,
        4030,1,0,0,0,4054,4031,1,0,0,0,4054,4032,1,0,0,0,4054,4033,1,0,0,
        0,4054,4052,1,0,0,0,4054,4053,1,0,0,0,4055,4057,1,0,0,0,4056,4029,
        1,0,0,0,4056,4057,1,0,0,0,4057,635,1,0,0,0,4058,4059,5,253,0,0,4059,
        4074,7,52,0,0,4060,4072,5,4,0,0,4061,4063,5,193,0,0,4062,4064,3,
        362,181,0,4063,4062,1,0,0,0,4064,4065,1,0,0,0,4065,4063,1,0,0,0,
        4065,4066,1,0,0,0,4066,4067,1,0,0,0,4067,4069,5,204,0,0,4068,4070,
        5,20,0,0,4069,4068,1,0,0,0,4069,4070,1,0,0,0,4070,4073,1,0,0,0,4071,
        4073,3,362,181,0,4072,4061,1,0,0,0,4072,4071,1,0,0,0,4073,4075,1,
        0,0,0,4074,4060,1,0,0,0,4074,4075,1,0,0,0,4075,637,1,0,0,0,4076,
        4079,5,114,0,0,4077,4080,3,574,287,0,4078,4080,3,356,178,0,4079,
        4077,1,0,0,0,4079,4078,1,0,0,0,4080,4095,1,0,0,0,4081,4084,5,12,
        0,0,4082,4085,5,446,0,0,4083,4085,3,658,329,0,4084,4082,1,0,0,0,
        4084,4083,1,0,0,0,4085,4092,1,0,0,0,4086,4090,5,29,0,0,4087,4091,
        5,446,0,0,4088,4091,3,658,329,0,4089,4091,3,86,43,0,4090,4087,1,
        0,0,0,4090,4088,1,0,0,0,4090,4089,1,0,0,0,4091,4093,1,0,0,0,4092,
        4086,1,0,0,0,4092,4093,1,0,0,0,4093,4094,1,0,0,0,4094,4096,5,13,
        0,0,4095,4081,1,0,0,0,4095,4096,1,0,0,0,4096,639,1,0,0,0,4097,4098,
        5,444,0,0,4098,4099,5,12,0,0,4099,4100,3,530,265,0,4100,4101,5,13,
        0,0,4101,4102,5,20,0,0,4102,641,1,0,0,0,4103,4104,5,258,0,0,4104,
        4105,5,12,0,0,4105,4106,3,530,265,0,4106,4107,5,13,0,0,4107,4108,
        5,20,0,0,4108,643,1,0,0,0,4109,4110,5,260,0,0,4110,4111,5,12,0,0,
        4111,4112,3,530,265,0,4112,4113,5,13,0,0,4113,4114,5,20,0,0,4114,
        645,1,0,0,0,4115,4117,5,45,0,0,4116,4118,3,648,324,0,4117,4116,1,
        0,0,0,4117,4118,1,0,0,0,4118,4119,1,0,0,0,4119,4124,3,506,253,0,
        4120,4121,5,8,0,0,4121,4122,3,244,122,0,4122,4123,5,9,0,0,4123,4125,
        1,0,0,0,4124,4120,1,0,0,0,4124,4125,1,0,0,0,4125,4128,1,0,0,0,4126,
        4127,5,20,0,0,4127,4129,3,280,140,0,4128,4126,1,0,0,0,4128,4129,
        1,0,0,0,4129,4130,1,0,0,0,4130,4131,5,20,0,0,4131,647,1,0,0,0,4132,
        4134,7,44,0,0,4133,4132,1,0,0,0,4133,4134,1,0,0,0,4134,4135,1,0,
        0,0,4135,4140,7,53,0,0,4136,4137,5,4,0,0,4137,4139,3,648,324,0,4138,
        4136,1,0,0,0,4139,4142,1,0,0,0,4140,4138,1,0,0,0,4140,4141,1,0,0,
        0,4141,649,1,0,0,0,4142,4140,1,0,0,0,4143,4149,3,652,326,0,4144,
        4146,5,12,0,0,4145,4147,3,654,327,0,4146,4145,1,0,0,0,4146,4147,
        1,0,0,0,4147,4148,1,0,0,0,4148,4150,5,13,0,0,4149,4144,1,0,0,0,4149,
        4150,1,0,0,0,4150,4151,1,0,0,0,4151,4152,5,20,0,0,4152,651,1,0,0,
        0,4153,4157,5,446,0,0,4154,4157,3,404,202,0,4155,4157,3,658,329,
        0,4156,4153,1,0,0,0,4156,4154,1,0,0,0,4156,4155,1,0,0,0,4157,653,
        1,0,0,0,4158,4163,3,656,328,0,4159,4160,5,4,0,0,4160,4162,3,656,
        328,0,4161,4159,1,0,0,0,4162,4165,1,0,0,0,4163,4161,1,0,0,0,4163,
        4164,1,0,0,0,4164,655,1,0,0,0,4165,4163,1,0,0,0,4166,4174,3,306,
        153,0,4167,4174,3,300,150,0,4168,4174,3,294,147,0,4169,4174,3,312,
        156,0,4170,4174,3,244,122,0,4171,4174,3,530,265,0,4172,4174,5,449,
        0,0,4173,4166,1,0,0,0,4173,4167,1,0,0,0,4173,4168,1,0,0,0,4173,4169,
        1,0,0,0,4173,4170,1,0,0,0,4173,4171,1,0,0,0,4173,4172,1,0,0,0,4174,
        657,1,0,0,0,4175,4176,7,54,0,0,4176,659,1,0,0,0,492,662,668,671,
        677,681,687,690,698,707,713,716,725,730,735,738,744,748,754,758,
        762,771,774,777,783,787,790,797,813,818,837,856,911,927,940,942,
        944,1000,1003,1008,1010,1049,1061,1064,1068,1071,1078,1081,1086,
        1090,1095,1103,1114,1123,1128,1139,1144,1152,1156,1161,1163,1172,
        1179,1184,1186,1197,1209,1213,1215,1219,1231,1236,1251,1255,1266,
        1273,1286,1295,1301,1307,1311,1326,1330,1336,1345,1349,1352,1359,
        1367,1378,1384,1388,1418,1437,1467,1477,1507,1514,1519,1526,1537,
        1548,1555,1558,1565,1573,1576,1584,1590,1593,1600,1606,1611,1619,
        1632,1642,1646,1655,1658,1662,1670,1676,1681,1686,1690,1699,1704,
        1710,1718,1723,1726,1731,1737,1740,1745,1753,1758,1760,1765,1779,
        1813,1815,1822,1824,1832,1836,1848,1853,1855,1859,1862,1872,1880,
        1892,1897,1905,1913,1923,1931,1936,1944,1952,1957,1961,1969,1976,
        1980,1987,1995,2002,2014,2023,2044,2049,2054,2065,2074,2079,2084,
        2089,2094,2097,2107,2110,2114,2120,2124,2127,2135,2175,2192,2197,
        2200,2206,2213,2219,2223,2227,2230,2240,2245,2249,2256,2264,2271,
        2274,2283,2294,2304,2309,2313,2317,2320,2326,2336,2341,2345,2349,
        2352,2358,2363,2367,2374,2378,2384,2387,2396,2402,2406,2409,2415,
        2422,2427,2431,2437,2441,2447,2453,2460,2463,2466,2469,2477,2481,
        2491,2496,2506,2511,2522,2527,2529,2532,2538,2541,2547,2551,2554,
        2561,2564,2570,2583,2590,2596,2604,2612,2617,2621,2629,2631,2639,
        2641,2645,2656,2659,2674,2679,2688,2693,2699,2705,2719,2722,2729,
        2733,2740,2755,2761,2774,2781,2803,2813,2820,2824,2839,2845,2853,
        2858,2869,2876,2879,2888,2895,2898,2907,2913,2919,2921,2925,2929,
        2932,2944,2947,2950,2953,2956,2959,2966,2969,2974,2977,2997,3001,
        3006,3012,3039,3046,3049,3063,3067,3070,3076,3079,3081,3084,3091,
        3099,3105,3109,3112,3115,3125,3131,3134,3137,3145,3158,3172,3175,
        3179,3188,3200,3205,3209,3219,3225,3231,3235,3242,3248,3250,3257,
        3276,3291,3298,3305,3313,3320,3325,3329,3332,3335,3339,3343,3346,
        3350,3354,3382,3389,3394,3398,3400,3407,3412,3416,3418,3424,3428,
        3432,3437,3442,3446,3448,3451,3457,3470,3477,3481,3485,3487,3496,
        3500,3509,3513,3518,3522,3526,3540,3545,3549,3551,3554,3558,3562,
        3567,3571,3573,3575,3581,3585,3588,3601,3606,3617,3620,3625,3629,
        3632,3634,3642,3647,3657,3662,3665,3673,3676,3681,3685,3701,3781,
        3795,3801,3809,3817,3867,3881,3886,3892,3902,3912,3917,3919,3922,
        3928,3931,3937,3941,3946,3957,3962,3965,3971,3979,3984,3990,3998,
        4000,4008,4016,4021,4027,4042,4048,4054,4056,4065,4069,4072,4074,
        4079,4084,4090,4092,4095,4117,4124,4128,4133,4140,4146,4149,4156,
        4163,4173
    ]

class WFLParser ( Parser ):

    grammarFileName = "WFL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'&'", "'\"\"'", "'_'", "','", "'\\'", 
                     "'~'", "'`'", "'['", "']'", "'{'", "'}'", "'('", "')'", 
                     "'|'", "':'", "'$'", "'@'", "'#'", "'.'", "';'", "'!'", 
                     "'?'", "'<'", "'>'", "'+'", "'-'", "'/'", "'*'", "'='", 
                     "':='", "'^'", "'SW1'", "'SW2'", "'SW3'", "'SW4'", 
                     "'SW5'", "'SW6'", "'SW7'", "'SW8'", "'COBOL74'", "'COBOL85'", 
                     "'FORTRAN77'", "'MODULA2'", "'LCOBOL74'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'ALGOL'" ]

    symbolicNames = [ "<INVALID>", "AMPERSAND", "EMPTYSTRING", "UNDERSCORE", 
                      "COMMA", "BACKSLASH", "TILDE", "BACKTICK", "LS", "RS", 
                      "LB", "RB", "LP", "RP", "PIPE", "COLON", "DOLLAR", 
                      "ATS", "HASH", "DOT", "SEMICOLON", "EXCLAMATION", 
                      "QMARK", "LT", "GT", "PLUS", "MINUS", "SLASH", "STAR", 
                      "EQUAL", "ASSIGN", "CARET", "SW1", "SW2", "SW3", "SW4", 
                      "SW5", "SW6", "SW7", "SW8", "COBOL74", "COBOL85", 
                      "FORTRAN77", "MODULA2", "LCOBOL74", "REPLACE", "SELECT", 
                      "DIV", "TASKFAULT", "SETGROUPCODE", "ALTERNATEGROUPS", 
                      "PROPAGATESECURITYTODIRS", "ACCESSED", "BEFORE", "QUIT", 
                      "DATASET", "PROGRAM", "RECORD", "STOPPED", "USE", 
                      "TOTALING", "SOURCE", "BREAK", "LOAD", "DECIMAL", 
                      "ORDER", "BY", "DONTPROPAGATE", "EXCLUSIVE", "DISABLE", 
                      "ENABLE", "PROPAGATE", "NOZ", "PROPAGATESECURITYTOFILES", 
                      "ALIGNMENT", "UPDATE", "NOPOSTDUMP", "RESET", "APL", 
                      "DB", "ALL", "CARD", "BANNER", "SPEC", "LOCKEDFILE", 
                      "SECURITYADMIN", "HEADING", "PAGE", "SENSITIVEDATA", 
                      "SET", "CCSVERSION", "OPTIONS", "DUMP", "OFFLINE", 
                      "ONLINE", "TAKE", "DROP", "EXTMODE", "PAGECOMP", "TRANSFORM", 
                      "EXTDELIMITER", "GLOBAL", "INTERNAL", "ALLOWEDCORE", 
                      "FILEKIND", "LABEL", "PRINTERKIND", "TRAINID", "PRODUCT", 
                      "SAVEFACTOR", "SECURITYMODE", "SECURITYUSE", "INCLUDE", 
                      "PRINTPARTIAL", "INTO", "COMPRESS", "ERRORFILE", "ENTRY", 
                      "USERINFO", "GROUP", "COMPLETEDOK", "OPTIONAL", "OR", 
                      "YYMMDD", "YYYYMMDD", "HHMMSS", "MMDDYY", "MMDDYYYY", 
                      "YYYYMMDDHHMMSS", "TIMEDATE", "DAYNUMBER", "OWNER", 
                      "GROUPRWX", "USERBACKUPNAME", "OTHERRWX", "OWNERRWX", 
                      "GROUPR", "GROUPW", "GROUPX", "OTHERR", "OTHERW", 
                      "OTHERX", "OWNERR", "OWNERW", "OWNERX", "SETUSERCODE", 
                      "USEGUARDFILE", "GUARDOWNER", "RWX", "RW", "RX", "WX", 
                      "NO", "BACKUP", "DSONERROR", "WAITONERROR", "REPORTS", 
                      "REPORT", "SKIPEXCLUSIVE", "FROMSTART", "VERIFY", 
                      "COMPARE", "BECOMEOWNER", "AND", "LABELSINTABLE", 
                      "RESIDENT", "ACTIVE", "TERMINATED", "BADINITIATE", 
                      "NEVERUSED", "COMPLETED", "EQL", "GTR", "LSS", "GEQ", 
                      "LEQ", "NEQ", "CC", "SORT", "RPG", "PASCAL", "NEWP", 
                      "NDLII", "DMALGOL", "DCALGOL", "BINDER", "ALGOL", 
                      "PRIORITY", "AT", "AS", "EXECUTE", "ACCESSCODELIST", 
                      "ACCESSCODE", "BEGIN", "CASE", "COMPILE", "COMPILER", 
                      "CONVENTION", "CLASS", "CHARGECODE", "DATA", "DISK", 
                      "DISPLAY", "ELSE", "END", "GENERATE", "EBCDIC", "ELAPSEDLIMIT", 
                      "FAMILY", "KIND", "LIBRARY", "TITLE", "WITH", "RUN", 
                      "OF", "FOR", "FROM", "JOB", "OTHERWISE", "MYPACK", 
                      "MAXPROCTIME", "MAXIOTIME", "MAXLINES", "MAXWAIT", 
                      "UNTIL", "USER", "USERDATA", "USERDATAFILE", "USERCODE", 
                      "CONSTANT", "BOOLEAN", "REAL", "INTEGER", "ASCENDING", 
                      "DESCENDING", "STRING", "FILES", "FILE", "TASK", "TRUE", 
                      "JOBSYMBOL", "NOSUMMARY", "LOCKDECK", "DECKLABEL", 
                      "EXCLUDE", "FALSE", "SUBROUTINE", "ABORTED", "ABORT", 
                      "DENSITY", "STOP", "REFERENCE", "WAIT", "ON", "OK", 
                      "GO", "SYNTAX", "CRUNCH", "LOCK", "PURGE", "RELEASE", 
                      "REWIND", "COPY", "ADD", "CHANGE", "REMOVE", "SECURITY", 
                      "ACCEPT", "TO", "IF", "IS", "ISNT", "INSTRUCTION", 
                      "FETCH", "ALTER", "PRINT", "PB", "RERUN", "START", 
                      "STARTJOB", "STARTTIME", "ARCHIVE", "CATALOG", "BLOCKSTRUCTURE", 
                      "MODIFY", "UNWRAP", "VALUE", "WHILE", "WRAP", "LOG", 
                      "DO", "BIND", "NOLIST", "TODAY", "TOMORROW", "SUNDAY", 
                      "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", 
                      "SATURDAY", "JANUARY", "FEBRUARY", "MARCH", "APRIL", 
                      "MAY", "JUNE", "JULY", "AUGUST", "SEPTEMBER", "OCTOBER", 
                      "MOD", "NOVEMBER", "DECEMBER", "ITINERARY", "AUTOSWITCHTOMARC", 
                      "DESTSTATION", "DISPLAYONLYTOMCS", "LANGUAGE", "ORGUNIT", 
                      "SOURCEKIND", "SOURCESTATION", "STATION", "STATIONNAME", 
                      "TANKING", "OPTION", "TADS", "TASKFILE", "CURRENTDIRECTORY", 
                      "DATABASE", "DATAPATH", "EXECUTEPATH", "FILEACCESSRULE", 
                      "JOBNUMBER", "MIXNUMBER", "NAME", "MPID", "WORKLOADGROUP", 
                      "AX", "LOCKED", "PARTNEREXISTS", "STATUS", "OUTPUT", 
                      "ITEMS", "ARE", "TARGET", "TASKLIMIT", "TASKSTRING", 
                      "TASKVALUE", "TYPE", "JOBSUMMARY", "JOBSUMMARYTITLE", 
                      "NOJOBSUMMARYIO", "LIBRARYSTATE", "LIBRARYUSERS", 
                      "CORE", "STACKLIMIT", "STACKSIZE", "BACKUPFAMILY", 
                      "BDNAME", "PRINTDEFAULTS", "ACCUMIOTIME", "ACCUMPROCTIME", 
                      "ELAPSEDTIME", "INITPBITCOUNT", "INITPBITTIME", "OTHERPBITCOUNT", 
                      "OTHERPBITTIME", "TEMPFILEMBYTES", "RESOURCE", "SAVEMEMORYLIMIT", 
                      "TEMPFILELIMIT", "TOTALMEMORYLIMIT", "WAITLIMIT", 
                      "BRCLASS", "CHECKPOINTABLE", "RESTART", "RESTARTED", 
                      "DECKGROUPNO", "ERROR", "HISTORY", "HISTORYCAUSE", 
                      "HISTORYTYPE", "HSPARAMSIZE", "STACKHISTORY", "STOPPOINT", 
                      "SUPPRESSWARNING", "TASKWARNINGS", "FAMILYDISK", "DEFAULT", 
                      "INITIALIZE", "PROCESS", "THEN", "ONLY", "MYJOB", 
                      "MYSELF", "MAXRECSIZE", "SERIALNO", "SECURITYTYPE", 
                      "PUBLIC", "UNITS", "CHARACTERS", "FAMILYOWNER", "FILENAME", 
                      "PRINTCHARGE", "STATIONLIST", "LFILENAME", "LTITLE", 
                      "APPLICATIONGROUP", "INTNAME", "MYHOST", "MYHOSTGROUP", 
                      "SCRATCHPOOL", "YOURHOST", "YOURHOSTGROUP", "YOURUSERCODE", 
                      "FAMILYNAME", "AFTER", "DESTINATION", "FORMID", "LICENSEKEY", 
                      "NOTE", "PATHNAME", "RELEASEID", "WARNINGS", "ALIGNFILE", 
                      "COPYNAME", "MYNAME", "SECURITYGUARD", "YOURNAME", 
                      "STATE", "TIMESTAMP", "DEPENDENTSPECS", "NEWFILE", 
                      "LIBACCESS", "LIBPARAMETER", "COMPILEDOK", "CHARGE", 
                      "HEAD", "TAIL", "NOT", "HOSTNAME", "DEVICEKIND", "OPEN", 
                      "BLOCKSIZE", "Identifier", "Num", "NumCombineWithChar", 
                      "LITERAL", "COMMENT", "WS" ]

    RULE_startRule = 0
    RULE_job = 1
    RULE_beginJob = 2
    RULE_hostname = 3
    RULE_parameters = 4
    RULE_parameterList = 5
    RULE_parameter = 6
    RULE_parameterDefaultValue = 7
    RULE_dataType = 8
    RULE_endJob = 9
    RULE_filePath = 10
    RULE_equal = 11
    RULE_filePathName = 12
    RULE_filePathNameChar = 13
    RULE_attributes = 14
    RULE_attribute = 15
    RULE_stackLimitAttribute = 16
    RULE_optionsAttribute = 17
    RULE_optionList = 18
    RULE_option = 19
    RULE_languageAttribute = 20
    RULE_bdNameAttribute = 21
    RULE_startTimeAttribute = 22
    RULE_startTimeSpec = 23
    RULE_time = 24
    RULE_timeInterval = 25
    RULE_date = 26
    RULE_dayOfWeek = 27
    RULE_month = 28
    RULE_mm = 29
    RULE_dd = 30
    RULE_yy = 31
    RULE_yyyy = 32
    RULE_yyddd = 33
    RULE_yyyyddd = 34
    RULE_dayInterval = 35
    RULE_fetchAttribute = 36
    RULE_maxIOTimeAttribute = 37
    RULE_maxLinesAttribute = 38
    RULE_maxProcTimeAttribute = 39
    RULE_maxWaitAttribute = 40
    RULE_elapsedLimitAttribute = 41
    RULE_familyAttribute = 42
    RULE_reservedKeyword = 43
    RULE_accessCodeAttribute = 44
    RULE_userAttribute = 45
    RULE_userCodeAttribute = 46
    RULE_classAttribute = 47
    RULE_priorityAttribute = 48
    RULE_chargeCodeAttribute = 49
    RULE_declarations = 50
    RULE_declaration = 51
    RULE_dataDeclaration = 52
    RULE_dataFilePathDelaration = 53
    RULE_dataShowName = 54
    RULE_dataSystemClause = 55
    RULE_dataSpecification = 56
    RULE_dataSpecificationAssignment = 57
    RULE_dataSpecificationSection = 58
    RULE_dataSpecificationEntry = 59
    RULE_dataSpecificationSectionType = 60
    RULE_dataSpecificationSectionName = 61
    RULE_dataSpecificationAttribute = 62
    RULE_dataSpecificationValue = 63
    RULE_dataUseClause = 64
    RULE_dataUseClauseComponent = 65
    RULE_headingComponent = 66
    RULE_pageComponent = 67
    RULE_includeComponent = 68
    RULE_excludeComponent = 69
    RULE_outputComponent = 70
    RULE_reportsComponent = 71
    RULE_outputItems = 72
    RULE_useComponent = 73
    RULE_reportComponent = 74
    RULE_sourceComponent = 75
    RULE_sortByComponent = 76
    RULE_sortByParam = 77
    RULE_breakComponent = 78
    RULE_breakOnParam = 79
    RULE_totalling = 80
    RULE_totallingParam = 81
    RULE_databaseClause = 82
    RULE_databaseMalnipulationOptions = 83
    RULE_otherDatabaseClauseInput = 84
    RULE_datasetClause = 85
    RULE_datasetDbDeclaration = 86
    RULE_datasetDatasetDeclaration = 87
    RULE_datasetFileDeclaration = 88
    RULE_datasetRecordDeclaration = 89
    RULE_datasetSourceDeclaration = 90
    RULE_datasetLoadDeclaration = 91
    RULE_dataUserAndAccessCodeListClause = 92
    RULE_setMergeLabelsintable = 93
    RULE_setMergeResetList = 94
    RULE_updateClause = 95
    RULE_resetZipClause = 96
    RULE_globalAndResourseSetting = 97
    RULE_nopostdumpConfig = 98
    RULE_globalConfig = 99
    RULE_internalFileConfig = 100
    RULE_allowedCoreConfig = 101
    RULE_setListZipClause = 102
    RULE_setListClause = 103
    RULE_generateBlock = 104
    RULE_generateParameters = 105
    RULE_generateNonCopyParameters = 106
    RULE_generateNonCopyParameter = 107
    RULE_generateCopyParameters = 108
    RULE_generateCopyParameter = 109
    RULE_orderByClause = 110
    RULE_databaseDeclaration = 111
    RULE_databaseOptions = 112
    RULE_databaseOption = 113
    RULE_dumpDeclaration = 114
    RULE_dumpParameters = 115
    RULE_dumpParameter = 116
    RULE_includeDeclaration = 117
    RULE_taskDeclaration = 118
    RULE_taskIdentifierDeclaration = 119
    RULE_myselfTaskAssignment = 120
    RULE_myjobTaskAssignment = 121
    RULE_taskIdentifier = 122
    RULE_taskIdentifierAssigments = 123
    RULE_taskIdentifierAssigment = 124
    RULE_fileEquation = 125
    RULE_fileAttributeAssignment = 126
    RULE_fileAttribute = 127
    RULE_booleanFileAttribute = 128
    RULE_integerFileAttribute = 129
    RULE_stringFileAttribute = 130
    RULE_titleFileAttribute = 131
    RULE_blockSizeFileAttribute = 132
    RULE_fileNameFileAttribute = 133
    RULE_longFileNameFileAttribute = 134
    RULE_longTitleFileAttribute = 135
    RULE_mnemonicFileAttribute = 136
    RULE_deviceKindAssigment = 137
    RULE_serialNumberAssigment = 138
    RULE_fileAttributeValue = 139
    RULE_taskAttributeAssignment = 140
    RULE_taskAttribute = 141
    RULE_taskAttributeValue = 142
    RULE_fileDeclaration = 143
    RULE_fileDeclarationElement = 144
    RULE_booleanDeclaration = 145
    RULE_booleanDeclarationElement = 146
    RULE_booleanConstantExpression = 147
    RULE_integerDeclaration = 148
    RULE_integerDeclarationElement = 149
    RULE_integerConstantExpression = 150
    RULE_realDeclaration = 151
    RULE_realDeclarationElement = 152
    RULE_realConstantExpression = 153
    RULE_stringDeclaration = 154
    RULE_stringDeclarationElement = 155
    RULE_stringConstantExpression = 156
    RULE_primaryStringExpression = 157
    RULE_stringFunction = 158
    RULE_parameterReference = 159
    RULE_constantDeclaration = 160
    RULE_constantDeclarationElement = 161
    RULE_booleanConstantDeclaration = 162
    RULE_integerConstantDeclaration = 163
    RULE_realConstantDeclaration = 164
    RULE_stringConstantDeclaration = 165
    RULE_subroutineDeclaration = 166
    RULE_subroutineName = 167
    RULE_subroutineParameters = 168
    RULE_subroutineParameterList = 169
    RULE_subroutineParameter = 170
    RULE_booleanParameter = 171
    RULE_integerParameter = 172
    RULE_realParameter = 173
    RULE_stringParameter = 174
    RULE_fileParameter = 175
    RULE_taskParameter = 176
    RULE_subroutineBlock = 177
    RULE_fileReferencedVariable = 178
    RULE_label = 179
    RULE_statements = 180
    RULE_statement = 181
    RULE_startAndWaitStatement = 182
    RULE_wrapAndCompressStatement = 183
    RULE_wrapAndCompressFrom = 184
    RULE_printStatement = 185
    RULE_printSpecification = 186
    RULE_printDefault = 187
    RULE_printDefaultParameters = 188
    RULE_printDefaultParameter = 189
    RULE_printAttributeValue = 190
    RULE_printAttribute = 191
    RULE_copyAndCompareStatement = 192
    RULE_copyAndRemoveStatement = 193
    RULE_copyStatement = 194
    RULE_copyProtocol = 195
    RULE_copyFromClause = 196
    RULE_copyAsClause = 197
    RULE_compileStatement = 198
    RULE_compilerTaskEquationList = 199
    RULE_libraryEquation = 200
    RULE_databaseEquation = 201
    RULE_compilerName = 202
    RULE_compilerTitle = 203
    RULE_familyName = 204
    RULE_runStatement = 205
    RULE_localDataSpecification = 206
    RULE_excludeClause = 207
    RULE_runParameterList = 208
    RULE_runParameter = 209
    RULE_realExpression = 210
    RULE_integerExpression = 211
    RULE_integerMethod = 212
    RULE_otherIntegerMethod = 213
    RULE_integerIntegerMethod = 214
    RULE_calcExpression = 215
    RULE_calcExpressionTerm = 216
    RULE_calcExpressionFactor = 217
    RULE_stringExpression = 218
    RULE_stringMethod = 219
    RULE_otherStringMethod = 220
    RULE_acceptMethod = 221
    RULE_timeDateMethod = 222
    RULE_timeDateParameter = 223
    RULE_myselfMethod = 224
    RULE_myjobMethod = 225
    RULE_takeMethod = 226
    RULE_dropMethod = 227
    RULE_subStringMethod = 228
    RULE_stringStringMethod = 229
    RULE_headMethod = 230
    RULE_headParameter = 231
    RULE_tailMethod = 232
    RULE_tailParameter = 233
    RULE_concatMethod = 234
    RULE_taskEquationList = 235
    RULE_displayStatement = 236
    RULE_initializeStatement = 237
    RULE_abortStatement = 238
    RULE_waitStatement = 239
    RULE_waitContent = 240
    RULE_waitSpecification = 241
    RULE_simpleTaskRelation = 242
    RULE_taskMnemonicComparison = 243
    RULE_taskState = 244
    RULE_booleanTaskAttribute = 245
    RULE_integerTaskAttribute = 246
    RULE_realTaskAttribute = 247
    RULE_mnemonicTaskAttribute = 248
    RULE_realRelation = 249
    RULE_addStatement = 250
    RULE_addOptions = 251
    RULE_addOption = 252
    RULE_copyRequest = 253
    RULE_processStatement = 254
    RULE_assignmentStatement = 255
    RULE_booleanAssignmentStatement = 256
    RULE_booleanIdentifier = 257
    RULE_integerAssignmentStatement = 258
    RULE_integerIdentifier = 259
    RULE_realAssignmentStatement = 260
    RULE_realIdentifier = 261
    RULE_stringAssignmentStatement = 262
    RULE_stringIdentifier = 263
    RULE_fileAssignmentStatement = 264
    RULE_fileIdentifier = 265
    RULE_taskAssignmentStatement = 266
    RULE_startStatement = 267
    RULE_startParameterList = 268
    RULE_namedParameterList = 269
    RULE_namedParameter = 270
    RULE_realFormalParameter = 271
    RULE_integerFormalParameter = 272
    RULE_booleanFormalParameter = 273
    RULE_stringFormalParameter = 274
    RULE_positionalParameterList = 275
    RULE_positionalParameter = 276
    RULE_stringPrimary = 277
    RULE_ifStatement = 278
    RULE_condition = 279
    RULE_simpleCondition = 280
    RULE_complexCondition = 281
    RULE_combineComplexCondition = 282
    RULE_thenClause = 283
    RULE_elseClause = 284
    RULE_booleanExpression = 285
    RULE_booleanComparison = 286
    RULE_storageUnit = 287
    RULE_doStatement = 288
    RULE_whileStatement = 289
    RULE_caseStatement = 290
    RULE_caseExpression = 291
    RULE_caseClauses = 292
    RULE_caseClause = 293
    RULE_caseConstantExpression = 294
    RULE_alterStatement = 295
    RULE_longFileTitle = 296
    RULE_longDirectoryTitle = 297
    RULE_alterAttributeList = 298
    RULE_alterAttribute = 299
    RULE_alternategroupsValue = 300
    RULE_groupExpression = 301
    RULE_mnemonicValue = 302
    RULE_fileMnemonicPrimary = 303
    RULE_nameConstant = 304
    RULE_mnemonic = 305
    RULE_changeStatement = 306
    RULE_changeItem = 307
    RULE_crunchStatement = 308
    RULE_goStatement = 309
    RULE_labelIdentifer = 310
    RULE_modifyStatement = 311
    RULE_onClause = 312
    RULE_removeStatement = 313
    RULE_fromClause = 314
    RULE_fromClauseParameter = 315
    RULE_toClause = 316
    RULE_toClauseParameters = 317
    RULE_onStatement = 318
    RULE_intoClause = 319
    RULE_openStatement = 320
    RULE_lockStatement = 321
    RULE_releaseStatement = 322
    RULE_replaceStatement = 323
    RULE_replaceOptions = 324
    RULE_subroutineInvocationStatement = 325
    RULE_subroutineIdentifier = 326
    RULE_argumentList = 327
    RULE_argument = 328
    RULE_charDataKeyword = 329

    ruleNames =  [ "startRule", "job", "beginJob", "hostname", "parameters", 
                   "parameterList", "parameter", "parameterDefaultValue", 
                   "dataType", "endJob", "filePath", "equal", "filePathName", 
                   "filePathNameChar", "attributes", "attribute", "stackLimitAttribute", 
                   "optionsAttribute", "optionList", "option", "languageAttribute", 
                   "bdNameAttribute", "startTimeAttribute", "startTimeSpec", 
                   "time", "timeInterval", "date", "dayOfWeek", "month", 
                   "mm", "dd", "yy", "yyyy", "yyddd", "yyyyddd", "dayInterval", 
                   "fetchAttribute", "maxIOTimeAttribute", "maxLinesAttribute", 
                   "maxProcTimeAttribute", "maxWaitAttribute", "elapsedLimitAttribute", 
                   "familyAttribute", "reservedKeyword", "accessCodeAttribute", 
                   "userAttribute", "userCodeAttribute", "classAttribute", 
                   "priorityAttribute", "chargeCodeAttribute", "declarations", 
                   "declaration", "dataDeclaration", "dataFilePathDelaration", 
                   "dataShowName", "dataSystemClause", "dataSpecification", 
                   "dataSpecificationAssignment", "dataSpecificationSection", 
                   "dataSpecificationEntry", "dataSpecificationSectionType", 
                   "dataSpecificationSectionName", "dataSpecificationAttribute", 
                   "dataSpecificationValue", "dataUseClause", "dataUseClauseComponent", 
                   "headingComponent", "pageComponent", "includeComponent", 
                   "excludeComponent", "outputComponent", "reportsComponent", 
                   "outputItems", "useComponent", "reportComponent", "sourceComponent", 
                   "sortByComponent", "sortByParam", "breakComponent", "breakOnParam", 
                   "totalling", "totallingParam", "databaseClause", "databaseMalnipulationOptions", 
                   "otherDatabaseClauseInput", "datasetClause", "datasetDbDeclaration", 
                   "datasetDatasetDeclaration", "datasetFileDeclaration", 
                   "datasetRecordDeclaration", "datasetSourceDeclaration", 
                   "datasetLoadDeclaration", "dataUserAndAccessCodeListClause", 
                   "setMergeLabelsintable", "setMergeResetList", "updateClause", 
                   "resetZipClause", "globalAndResourseSetting", "nopostdumpConfig", 
                   "globalConfig", "internalFileConfig", "allowedCoreConfig", 
                   "setListZipClause", "setListClause", "generateBlock", 
                   "generateParameters", "generateNonCopyParameters", "generateNonCopyParameter", 
                   "generateCopyParameters", "generateCopyParameter", "orderByClause", 
                   "databaseDeclaration", "databaseOptions", "databaseOption", 
                   "dumpDeclaration", "dumpParameters", "dumpParameter", 
                   "includeDeclaration", "taskDeclaration", "taskIdentifierDeclaration", 
                   "myselfTaskAssignment", "myjobTaskAssignment", "taskIdentifier", 
                   "taskIdentifierAssigments", "taskIdentifierAssigment", 
                   "fileEquation", "fileAttributeAssignment", "fileAttribute", 
                   "booleanFileAttribute", "integerFileAttribute", "stringFileAttribute", 
                   "titleFileAttribute", "blockSizeFileAttribute", "fileNameFileAttribute", 
                   "longFileNameFileAttribute", "longTitleFileAttribute", 
                   "mnemonicFileAttribute", "deviceKindAssigment", "serialNumberAssigment", 
                   "fileAttributeValue", "taskAttributeAssignment", "taskAttribute", 
                   "taskAttributeValue", "fileDeclaration", "fileDeclarationElement", 
                   "booleanDeclaration", "booleanDeclarationElement", "booleanConstantExpression", 
                   "integerDeclaration", "integerDeclarationElement", "integerConstantExpression", 
                   "realDeclaration", "realDeclarationElement", "realConstantExpression", 
                   "stringDeclaration", "stringDeclarationElement", "stringConstantExpression", 
                   "primaryStringExpression", "stringFunction", "parameterReference", 
                   "constantDeclaration", "constantDeclarationElement", 
                   "booleanConstantDeclaration", "integerConstantDeclaration", 
                   "realConstantDeclaration", "stringConstantDeclaration", 
                   "subroutineDeclaration", "subroutineName", "subroutineParameters", 
                   "subroutineParameterList", "subroutineParameter", "booleanParameter", 
                   "integerParameter", "realParameter", "stringParameter", 
                   "fileParameter", "taskParameter", "subroutineBlock", 
                   "fileReferencedVariable", "label", "statements", "statement", 
                   "startAndWaitStatement", "wrapAndCompressStatement", 
                   "wrapAndCompressFrom", "printStatement", "printSpecification", 
                   "printDefault", "printDefaultParameters", "printDefaultParameter", 
                   "printAttributeValue", "printAttribute", "copyAndCompareStatement", 
                   "copyAndRemoveStatement", "copyStatement", "copyProtocol", 
                   "copyFromClause", "copyAsClause", "compileStatement", 
                   "compilerTaskEquationList", "libraryEquation", "databaseEquation", 
                   "compilerName", "compilerTitle", "familyName", "runStatement", 
                   "localDataSpecification", "excludeClause", "runParameterList", 
                   "runParameter", "realExpression", "integerExpression", 
                   "integerMethod", "otherIntegerMethod", "integerIntegerMethod", 
                   "calcExpression", "calcExpressionTerm", "calcExpressionFactor", 
                   "stringExpression", "stringMethod", "otherStringMethod", 
                   "acceptMethod", "timeDateMethod", "timeDateParameter", 
                   "myselfMethod", "myjobMethod", "takeMethod", "dropMethod", 
                   "subStringMethod", "stringStringMethod", "headMethod", 
                   "headParameter", "tailMethod", "tailParameter", "concatMethod", 
                   "taskEquationList", "displayStatement", "initializeStatement", 
                   "abortStatement", "waitStatement", "waitContent", "waitSpecification", 
                   "simpleTaskRelation", "taskMnemonicComparison", "taskState", 
                   "booleanTaskAttribute", "integerTaskAttribute", "realTaskAttribute", 
                   "mnemonicTaskAttribute", "realRelation", "addStatement", 
                   "addOptions", "addOption", "copyRequest", "processStatement", 
                   "assignmentStatement", "booleanAssignmentStatement", 
                   "booleanIdentifier", "integerAssignmentStatement", "integerIdentifier", 
                   "realAssignmentStatement", "realIdentifier", "stringAssignmentStatement", 
                   "stringIdentifier", "fileAssignmentStatement", "fileIdentifier", 
                   "taskAssignmentStatement", "startStatement", "startParameterList", 
                   "namedParameterList", "namedParameter", "realFormalParameter", 
                   "integerFormalParameter", "booleanFormalParameter", "stringFormalParameter", 
                   "positionalParameterList", "positionalParameter", "stringPrimary", 
                   "ifStatement", "condition", "simpleCondition", "complexCondition", 
                   "combineComplexCondition", "thenClause", "elseClause", 
                   "booleanExpression", "booleanComparison", "storageUnit", 
                   "doStatement", "whileStatement", "caseStatement", "caseExpression", 
                   "caseClauses", "caseClause", "caseConstantExpression", 
                   "alterStatement", "longFileTitle", "longDirectoryTitle", 
                   "alterAttributeList", "alterAttribute", "alternategroupsValue", 
                   "groupExpression", "mnemonicValue", "fileMnemonicPrimary", 
                   "nameConstant", "mnemonic", "changeStatement", "changeItem", 
                   "crunchStatement", "goStatement", "labelIdentifer", "modifyStatement", 
                   "onClause", "removeStatement", "fromClause", "fromClauseParameter", 
                   "toClause", "toClauseParameters", "onStatement", "intoClause", 
                   "openStatement", "lockStatement", "releaseStatement", 
                   "replaceStatement", "replaceOptions", "subroutineInvocationStatement", 
                   "subroutineIdentifier", "argumentList", "argument", "charDataKeyword" ]

    EOF = Token.EOF
    AMPERSAND=1
    EMPTYSTRING=2
    UNDERSCORE=3
    COMMA=4
    BACKSLASH=5
    TILDE=6
    BACKTICK=7
    LS=8
    RS=9
    LB=10
    RB=11
    LP=12
    RP=13
    PIPE=14
    COLON=15
    DOLLAR=16
    ATS=17
    HASH=18
    DOT=19
    SEMICOLON=20
    EXCLAMATION=21
    QMARK=22
    LT=23
    GT=24
    PLUS=25
    MINUS=26
    SLASH=27
    STAR=28
    EQUAL=29
    ASSIGN=30
    CARET=31
    SW1=32
    SW2=33
    SW3=34
    SW4=35
    SW5=36
    SW6=37
    SW7=38
    SW8=39
    COBOL74=40
    COBOL85=41
    FORTRAN77=42
    MODULA2=43
    LCOBOL74=44
    REPLACE=45
    SELECT=46
    DIV=47
    TASKFAULT=48
    SETGROUPCODE=49
    ALTERNATEGROUPS=50
    PROPAGATESECURITYTODIRS=51
    ACCESSED=52
    BEFORE=53
    QUIT=54
    DATASET=55
    PROGRAM=56
    RECORD=57
    STOPPED=58
    USE=59
    TOTALING=60
    SOURCE=61
    BREAK=62
    LOAD=63
    DECIMAL=64
    ORDER=65
    BY=66
    DONTPROPAGATE=67
    EXCLUSIVE=68
    DISABLE=69
    ENABLE=70
    PROPAGATE=71
    NOZ=72
    PROPAGATESECURITYTOFILES=73
    ALIGNMENT=74
    UPDATE=75
    NOPOSTDUMP=76
    RESET=77
    APL=78
    DB=79
    ALL=80
    CARD=81
    BANNER=82
    SPEC=83
    LOCKEDFILE=84
    SECURITYADMIN=85
    HEADING=86
    PAGE=87
    SENSITIVEDATA=88
    SET=89
    CCSVERSION=90
    OPTIONS=91
    DUMP=92
    OFFLINE=93
    ONLINE=94
    TAKE=95
    DROP=96
    EXTMODE=97
    PAGECOMP=98
    TRANSFORM=99
    EXTDELIMITER=100
    GLOBAL=101
    INTERNAL=102
    ALLOWEDCORE=103
    FILEKIND=104
    LABEL=105
    PRINTERKIND=106
    TRAINID=107
    PRODUCT=108
    SAVEFACTOR=109
    SECURITYMODE=110
    SECURITYUSE=111
    INCLUDE=112
    PRINTPARTIAL=113
    INTO=114
    COMPRESS=115
    ERRORFILE=116
    ENTRY=117
    USERINFO=118
    GROUP=119
    COMPLETEDOK=120
    OPTIONAL=121
    OR=122
    YYMMDD=123
    YYYYMMDD=124
    HHMMSS=125
    MMDDYY=126
    MMDDYYYY=127
    YYYYMMDDHHMMSS=128
    TIMEDATE=129
    DAYNUMBER=130
    OWNER=131
    GROUPRWX=132
    USERBACKUPNAME=133
    OTHERRWX=134
    OWNERRWX=135
    GROUPR=136
    GROUPW=137
    GROUPX=138
    OTHERR=139
    OTHERW=140
    OTHERX=141
    OWNERR=142
    OWNERW=143
    OWNERX=144
    SETUSERCODE=145
    USEGUARDFILE=146
    GUARDOWNER=147
    RWX=148
    RW=149
    RX=150
    WX=151
    NO=152
    BACKUP=153
    DSONERROR=154
    WAITONERROR=155
    REPORTS=156
    REPORT=157
    SKIPEXCLUSIVE=158
    FROMSTART=159
    VERIFY=160
    COMPARE=161
    BECOMEOWNER=162
    AND=163
    LABELSINTABLE=164
    RESIDENT=165
    ACTIVE=166
    TERMINATED=167
    BADINITIATE=168
    NEVERUSED=169
    COMPLETED=170
    EQL=171
    GTR=172
    LSS=173
    GEQ=174
    LEQ=175
    NEQ=176
    CC=177
    SORT=178
    RPG=179
    PASCAL=180
    NEWP=181
    NDLII=182
    DMALGOL=183
    DCALGOL=184
    BINDER=185
    ALGOL=186
    PRIORITY=187
    AT=188
    AS=189
    EXECUTE=190
    ACCESSCODELIST=191
    ACCESSCODE=192
    BEGIN=193
    CASE=194
    COMPILE=195
    COMPILER=196
    CONVENTION=197
    CLASS=198
    CHARGECODE=199
    DATA=200
    DISK=201
    DISPLAY=202
    ELSE=203
    END=204
    GENERATE=205
    EBCDIC=206
    ELAPSEDLIMIT=207
    FAMILY=208
    KIND=209
    LIBRARY=210
    TITLE=211
    WITH=212
    RUN=213
    OF=214
    FOR=215
    FROM=216
    JOB=217
    OTHERWISE=218
    MYPACK=219
    MAXPROCTIME=220
    MAXIOTIME=221
    MAXLINES=222
    MAXWAIT=223
    UNTIL=224
    USER=225
    USERDATA=226
    USERDATAFILE=227
    USERCODE=228
    CONSTANT=229
    BOOLEAN=230
    REAL=231
    INTEGER=232
    ASCENDING=233
    DESCENDING=234
    STRING=235
    FILES=236
    FILE=237
    TASK=238
    TRUE=239
    JOBSYMBOL=240
    NOSUMMARY=241
    LOCKDECK=242
    DECKLABEL=243
    EXCLUDE=244
    FALSE=245
    SUBROUTINE=246
    ABORTED=247
    ABORT=248
    DENSITY=249
    STOP=250
    REFERENCE=251
    WAIT=252
    ON=253
    OK=254
    GO=255
    SYNTAX=256
    CRUNCH=257
    LOCK=258
    PURGE=259
    RELEASE=260
    REWIND=261
    COPY=262
    ADD=263
    CHANGE=264
    REMOVE=265
    SECURITY=266
    ACCEPT=267
    TO=268
    IF=269
    IS=270
    ISNT=271
    INSTRUCTION=272
    FETCH=273
    ALTER=274
    PRINT=275
    PB=276
    RERUN=277
    START=278
    STARTJOB=279
    STARTTIME=280
    ARCHIVE=281
    CATALOG=282
    BLOCKSTRUCTURE=283
    MODIFY=284
    UNWRAP=285
    VALUE=286
    WHILE=287
    WRAP=288
    LOG=289
    DO=290
    BIND=291
    NOLIST=292
    TODAY=293
    TOMORROW=294
    SUNDAY=295
    MONDAY=296
    TUESDAY=297
    WEDNESDAY=298
    THURSDAY=299
    FRIDAY=300
    SATURDAY=301
    JANUARY=302
    FEBRUARY=303
    MARCH=304
    APRIL=305
    MAY=306
    JUNE=307
    JULY=308
    AUGUST=309
    SEPTEMBER=310
    OCTOBER=311
    MOD=312
    NOVEMBER=313
    DECEMBER=314
    ITINERARY=315
    AUTOSWITCHTOMARC=316
    DESTSTATION=317
    DISPLAYONLYTOMCS=318
    LANGUAGE=319
    ORGUNIT=320
    SOURCEKIND=321
    SOURCESTATION=322
    STATION=323
    STATIONNAME=324
    TANKING=325
    OPTION=326
    TADS=327
    TASKFILE=328
    CURRENTDIRECTORY=329
    DATABASE=330
    DATAPATH=331
    EXECUTEPATH=332
    FILEACCESSRULE=333
    JOBNUMBER=334
    MIXNUMBER=335
    NAME=336
    MPID=337
    WORKLOADGROUP=338
    AX=339
    LOCKED=340
    PARTNEREXISTS=341
    STATUS=342
    OUTPUT=343
    ITEMS=344
    ARE=345
    TARGET=346
    TASKLIMIT=347
    TASKSTRING=348
    TASKVALUE=349
    TYPE=350
    JOBSUMMARY=351
    JOBSUMMARYTITLE=352
    NOJOBSUMMARYIO=353
    LIBRARYSTATE=354
    LIBRARYUSERS=355
    CORE=356
    STACKLIMIT=357
    STACKSIZE=358
    BACKUPFAMILY=359
    BDNAME=360
    PRINTDEFAULTS=361
    ACCUMIOTIME=362
    ACCUMPROCTIME=363
    ELAPSEDTIME=364
    INITPBITCOUNT=365
    INITPBITTIME=366
    OTHERPBITCOUNT=367
    OTHERPBITTIME=368
    TEMPFILEMBYTES=369
    RESOURCE=370
    SAVEMEMORYLIMIT=371
    TEMPFILELIMIT=372
    TOTALMEMORYLIMIT=373
    WAITLIMIT=374
    BRCLASS=375
    CHECKPOINTABLE=376
    RESTART=377
    RESTARTED=378
    DECKGROUPNO=379
    ERROR=380
    HISTORY=381
    HISTORYCAUSE=382
    HISTORYTYPE=383
    HSPARAMSIZE=384
    STACKHISTORY=385
    STOPPOINT=386
    SUPPRESSWARNING=387
    TASKWARNINGS=388
    FAMILYDISK=389
    DEFAULT=390
    INITIALIZE=391
    PROCESS=392
    THEN=393
    ONLY=394
    MYJOB=395
    MYSELF=396
    MAXRECSIZE=397
    SERIALNO=398
    SECURITYTYPE=399
    PUBLIC=400
    UNITS=401
    CHARACTERS=402
    FAMILYOWNER=403
    FILENAME=404
    PRINTCHARGE=405
    STATIONLIST=406
    LFILENAME=407
    LTITLE=408
    APPLICATIONGROUP=409
    INTNAME=410
    MYHOST=411
    MYHOSTGROUP=412
    SCRATCHPOOL=413
    YOURHOST=414
    YOURHOSTGROUP=415
    YOURUSERCODE=416
    FAMILYNAME=417
    AFTER=418
    DESTINATION=419
    FORMID=420
    LICENSEKEY=421
    NOTE=422
    PATHNAME=423
    RELEASEID=424
    WARNINGS=425
    ALIGNFILE=426
    COPYNAME=427
    MYNAME=428
    SECURITYGUARD=429
    YOURNAME=430
    STATE=431
    TIMESTAMP=432
    DEPENDENTSPECS=433
    NEWFILE=434
    LIBACCESS=435
    LIBPARAMETER=436
    COMPILEDOK=437
    CHARGE=438
    HEAD=439
    TAIL=440
    NOT=441
    HOSTNAME=442
    DEVICEKIND=443
    OPEN=444
    BLOCKSIZE=445
    Identifier=446
    Num=447
    NumCombineWithChar=448
    LITERAL=449
    COMMENT=450
    WS=451

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(WFLParser.EOF, 0)

        def job(self):
            return self.getTypedRuleContext(WFLParser.JobContext,0)


        def statements(self):
            return self.getTypedRuleContext(WFLParser.StatementsContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_startRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartRule" ):
                listener.enterStartRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartRule" ):
                listener.exitStartRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartRule" ):
                return visitor.visitStartRule(self)
            else:
                return visitor.visitChildren(self)




    def startRule(self):

        localctx = WFLParser.StartRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_startRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 662
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 660
                self.job()
                pass

            elif la_ == 2:
                self.state = 661
                self.statements()
                pass


            self.state = 664
            self.match(WFLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JobContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beginJob(self):
            return self.getTypedRuleContext(WFLParser.BeginJobContext,0)


        def statements(self):
            return self.getTypedRuleContext(WFLParser.StatementsContext,0)


        def endJob(self):
            return self.getTypedRuleContext(WFLParser.EndJobContext,0)


        def attributes(self):
            return self.getTypedRuleContext(WFLParser.AttributesContext,0)


        def declarations(self):
            return self.getTypedRuleContext(WFLParser.DeclarationsContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_job

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJob" ):
                listener.enterJob(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJob" ):
                listener.exitJob(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJob" ):
                return visitor.visitJob(self)
            else:
                return visitor.visitChildren(self)




    def job(self):

        localctx = WFLParser.JobContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_job)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 666
            self.beginJob()
            self.state = 668
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 667
                self.attributes()


            self.state = 671
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 670
                self.declarations()


            self.state = 673
            self.statements()
            self.state = 674
            self.endJob()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginJobContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def JOB(self):
            return self.getToken(WFLParser.JOB, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def QMARK(self):
            return self.getToken(WFLParser.QMARK, 0)

        def AT(self):
            return self.getToken(WFLParser.AT, 0)

        def hostname(self):
            return self.getTypedRuleContext(WFLParser.HostnameContext,0)


        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def COPY(self):
            return self.getToken(WFLParser.COPY, 0)

        def parameters(self):
            return self.getTypedRuleContext(WFLParser.ParametersContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_beginJob

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginJob" ):
                listener.enterBeginJob(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginJob" ):
                listener.exitBeginJob(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginJob" ):
                return visitor.visitBeginJob(self)
            else:
                return visitor.visitChildren(self)




    def beginJob(self):

        localctx = WFLParser.BeginJobContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beginJob)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 677
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 676
                self.match(WFLParser.QMARK)


            self.state = 681
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==188:
                self.state = 679
                self.match(WFLParser.AT)
                self.state = 680
                self.hostname()


            self.state = 683
            self.match(WFLParser.BEGIN)
            self.state = 684
            self.match(WFLParser.JOB)
            self.state = 687
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 685
                self.filePath()

            elif la_ == 2:
                self.state = 686
                self.match(WFLParser.COPY)


            self.state = 690
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 689
                self.parameters()


            self.state = 692
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HostnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_hostname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHostname" ):
                listener.enterHostname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHostname" ):
                listener.exitHostname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHostname" ):
                return visitor.visitHostname(self)
            else:
                return visitor.visitChildren(self)




    def hostname(self):

        localctx = WFLParser.HostnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_hostname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 694
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def parameterList(self):
            return self.getTypedRuleContext(WFLParser.ParameterListContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameters" ):
                return visitor.visitParameters(self)
            else:
                return visitor.visitChildren(self)




    def parameters(self):

        localctx = WFLParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.match(WFLParser.LP)
            self.state = 698
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & 295) != 0):
                self.state = 697
                self.parameterList()


            self.state = 700
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.ParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = WFLParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 702
            self.parameter()
            self.state = 707
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 703
                self.match(WFLParser.COMMA)
                self.state = 704
                self.parameter()
                self.state = 709
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataType(self):
            return self.getTypedRuleContext(WFLParser.DataTypeContext,0)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def parameterDefaultValue(self):
            return self.getTypedRuleContext(WFLParser.ParameterDefaultValueContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = WFLParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self.dataType()
            self.state = 713
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.state = 711
                self.match(WFLParser.Identifier)
                pass
            elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                self.state = 712
                self.charDataKeyword()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==121:
                self.state = 715
                self.parameterDefaultValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefaultValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPTIONAL(self):
            return self.getToken(WFLParser.OPTIONAL, 0)

        def DEFAULT(self):
            return self.getToken(WFLParser.DEFAULT, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_parameterDefaultValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefaultValue" ):
                listener.enterParameterDefaultValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefaultValue" ):
                listener.exitParameterDefaultValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefaultValue" ):
                return visitor.visitParameterDefaultValue(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefaultValue(self):

        localctx = WFLParser.ParameterDefaultValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_parameterDefaultValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 718
            self.match(WFLParser.OPTIONAL)
            self.state = 719
            self.match(WFLParser.DEFAULT)
            self.state = 720
            self.match(WFLParser.EQUAL)
            self.state = 725
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 721
                self.stringExpression()
                pass

            elif la_ == 2:
                self.state = 722
                self.realExpression()
                pass

            elif la_ == 3:
                self.state = 723
                self.integerExpression()
                pass

            elif la_ == 4:
                self.state = 724
                self.booleanConstantExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL(self):
            return self.getToken(WFLParser.REAL, 0)

        def INTEGER(self):
            return self.getToken(WFLParser.INTEGER, 0)

        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def BOOLEAN(self):
            return self.getToken(WFLParser.BOOLEAN, 0)

        def TASK(self):
            return self.getToken(WFLParser.TASK, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dataType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataType" ):
                listener.enterDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataType" ):
                listener.exitDataType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataType" ):
                return visitor.visitDataType(self)
            else:
                return visitor.visitChildren(self)




    def dataType(self):

        localctx = WFLParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_dataType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 727
            _la = self._input.LA(1)
            if not(((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & 295) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndJobContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def JOB(self):
            return self.getToken(WFLParser.JOB, 0)

        def QMARK(self):
            return self.getToken(WFLParser.QMARK, 0)

        def DOT(self):
            return self.getToken(WFLParser.DOT, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_endJob

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndJob" ):
                listener.enterEndJob(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndJob" ):
                listener.exitEndJob(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndJob" ):
                return visitor.visitEndJob(self)
            else:
                return visitor.visitChildren(self)




    def endJob(self):

        localctx = WFLParser.EndJobContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_endJob)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 729
                self.match(WFLParser.QMARK)


            self.state = 732
            self.match(WFLParser.END)
            self.state = 733
            self.match(WFLParser.JOB)
            self.state = 735
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 734
                self.match(WFLParser.DOT)


            self.state = 738
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 737
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilePathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SLASH)
            else:
                return self.getToken(WFLParser.SLASH, i)

        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def equal(self):
            return self.getTypedRuleContext(WFLParser.EqualContext,0)


        def filePathName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathNameContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathNameContext,i)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def getRuleIndex(self):
            return WFLParser.RULE_filePath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilePath" ):
                listener.enterFilePath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilePath" ):
                listener.exitFilePath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilePath" ):
                return visitor.visitFilePath(self)
            else:
                return visitor.visitChildren(self)




    def filePath(self):

        localctx = WFLParser.FilePathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_filePath)
        self._la = 0 # Token type
        try:
            self.state = 790
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 12, 16, 18, 23, 24, 26, 28, 29, 32, 33, 34, 35, 36, 37, 38, 39, 46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 171, 172, 173, 174, 175, 176, 177, 182, 187, 189, 192, 195, 200, 201, 202, 205, 207, 208, 209, 210, 211, 217, 219, 220, 221, 222, 223, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 282, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 391, 394, 398, 418, 438, 442, 444, 446, 447, 448, 449]:
                self.enterOuterAlt(localctx, 1)
                self.state = 754
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 744
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==12:
                        self.state = 740
                        self.match(WFLParser.LP)
                        self.state = 741
                        self.filePathName()
                        self.state = 742
                        self.match(WFLParser.RP)


                    self.state = 748
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [3, 16, 18, 23, 24, 26, 28, 32, 33, 34, 35, 36, 37, 38, 39, 46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 171, 172, 173, 174, 175, 176, 177, 182, 187, 189, 192, 195, 200, 201, 202, 205, 207, 208, 209, 210, 211, 217, 219, 220, 221, 222, 223, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 282, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 391, 394, 398, 418, 438, 442, 444, 446, 447, 448, 449]:
                        self.state = 746
                        self.filePathName()
                        pass
                    elif token in [29]:
                        self.state = 747
                        self.match(WFLParser.EQUAL)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass

                elif la_ == 2:
                    self.state = 750
                    self.match(WFLParser.LP)
                    self.state = 751
                    self.filePathName()
                    self.state = 752
                    self.match(WFLParser.RP)
                    pass


                self.state = 762
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==27:
                    self.state = 756
                    self.match(WFLParser.SLASH)
                    self.state = 758
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                    if la_ == 1:
                        self.state = 757
                        self.filePathName()


                    self.state = 764
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 774
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
                if la_ == 1:
                    self.state = 765
                    self.match(WFLParser.LP)
                    self.state = 766
                    self.match(WFLParser.Identifier)

                    self.state = 767
                    self.match(WFLParser.COMMA)
                    self.state = 771
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 768
                            _la = self._input.LA(1)
                            if not(_la==446 or _la==447):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume() 
                        self.state = 773
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,20,self._ctx)



                self.state = 777
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 776
                    self.equal()


                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 2)
                self.state = 779
                self.match(WFLParser.SLASH)
                self.state = 780
                self.filePathName()
                self.state = 787
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==27:
                    self.state = 781
                    self.match(WFLParser.SLASH)
                    self.state = 783
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                    if la_ == 1:
                        self.state = 782
                        self.filePathName()


                    self.state = 789
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_equal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqual" ):
                listener.enterEqual(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqual" ):
                listener.exitEqual(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqual" ):
                return visitor.visitEqual(self)
            else:
                return visitor.visitChildren(self)




    def equal(self):

        localctx = WFLParser.EqualContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_equal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.match(WFLParser.EQUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilePathNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePathNameChar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathNameCharContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathNameCharContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_filePathName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilePathName" ):
                listener.enterFilePathName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilePathName" ):
                listener.exitFilePathName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilePathName" ):
                return visitor.visitFilePathName(self)
            else:
                return visitor.visitChildren(self)




    def filePathName(self):

        localctx = WFLParser.FilePathNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_filePathName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 794
                    self.filePathNameChar()

                else:
                    raise NoViableAltException(self)
                self.state = 797 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilePathNameCharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def UNDERSCORE(self):
            return self.getToken(WFLParser.UNDERSCORE, 0)

        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def NumCombineWithChar(self):
            return self.getToken(WFLParser.NumCombineWithChar, 0)

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def MINUS(self):
            return self.getToken(WFLParser.MINUS, 0)

        def addOption(self):
            return self.getTypedRuleContext(WFLParser.AddOptionContext,0)


        def STAR(self):
            return self.getToken(WFLParser.STAR, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def realRelation(self):
            return self.getTypedRuleContext(WFLParser.RealRelationContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_filePathNameChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilePathNameChar" ):
                listener.enterFilePathNameChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilePathNameChar" ):
                listener.exitFilePathNameChar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilePathNameChar" ):
                return visitor.visitFilePathNameChar(self)
            else:
                return visitor.visitChildren(self)




    def filePathNameChar(self):

        localctx = WFLParser.FilePathNameCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_filePathNameChar)
        try:
            self.state = 813
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 799
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 800
                self.charDataKeyword()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 801
                self.match(WFLParser.Num)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 802
                self.match(WFLParser.UNDERSCORE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 803
                self.reservedKeyword()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 804
                self.match(WFLParser.NumCombineWithChar)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 805
                self.taskAttribute()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 806
                self.match(WFLParser.MINUS)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 807
                self.addOption()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 808
                self.match(WFLParser.STAR)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 809
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 810
                self.realRelation()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 811
                self.fileReferencedVariable()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 812
                self.match(WFLParser.DOLLAR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.AttributeContext)
            else:
                return self.getTypedRuleContext(WFLParser.AttributeContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_attributes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributes" ):
                listener.enterAttributes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributes" ):
                listener.exitAttributes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributes" ):
                return visitor.visitAttributes(self)
            else:
                return visitor.visitChildren(self)




    def attributes(self):

        localctx = WFLParser.AttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_attributes)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 816 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 815
                    self.attribute()

                else:
                    raise NoViableAltException(self)
                self.state = 818 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def priorityAttribute(self):
            return self.getTypedRuleContext(WFLParser.PriorityAttributeContext,0)


        def userAttribute(self):
            return self.getTypedRuleContext(WFLParser.UserAttributeContext,0)


        def userCodeAttribute(self):
            return self.getTypedRuleContext(WFLParser.UserCodeAttributeContext,0)


        def chargeCodeAttribute(self):
            return self.getTypedRuleContext(WFLParser.ChargeCodeAttributeContext,0)


        def classAttribute(self):
            return self.getTypedRuleContext(WFLParser.ClassAttributeContext,0)


        def fetchAttribute(self):
            return self.getTypedRuleContext(WFLParser.FetchAttributeContext,0)


        def accessCodeAttribute(self):
            return self.getTypedRuleContext(WFLParser.AccessCodeAttributeContext,0)


        def familyAttribute(self):
            return self.getTypedRuleContext(WFLParser.FamilyAttributeContext,0)


        def elapsedLimitAttribute(self):
            return self.getTypedRuleContext(WFLParser.ElapsedLimitAttributeContext,0)


        def maxIOTimeAttribute(self):
            return self.getTypedRuleContext(WFLParser.MaxIOTimeAttributeContext,0)


        def maxLinesAttribute(self):
            return self.getTypedRuleContext(WFLParser.MaxLinesAttributeContext,0)


        def maxProcTimeAttribute(self):
            return self.getTypedRuleContext(WFLParser.MaxProcTimeAttributeContext,0)


        def maxWaitAttribute(self):
            return self.getTypedRuleContext(WFLParser.MaxWaitAttributeContext,0)


        def startTimeAttribute(self):
            return self.getTypedRuleContext(WFLParser.StartTimeAttributeContext,0)


        def bdNameAttribute(self):
            return self.getTypedRuleContext(WFLParser.BdNameAttributeContext,0)


        def languageAttribute(self):
            return self.getTypedRuleContext(WFLParser.LanguageAttributeContext,0)


        def optionsAttribute(self):
            return self.getTypedRuleContext(WFLParser.OptionsAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_attribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribute" ):
                listener.enterAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribute" ):
                listener.exitAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribute" ):
                return visitor.visitAttribute(self)
            else:
                return visitor.visitChildren(self)




    def attribute(self):

        localctx = WFLParser.AttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_attribute)
        try:
            self.state = 837
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [187]:
                self.enterOuterAlt(localctx, 1)
                self.state = 820
                self.priorityAttribute()
                pass
            elif token in [225]:
                self.enterOuterAlt(localctx, 2)
                self.state = 821
                self.userAttribute()
                pass
            elif token in [228]:
                self.enterOuterAlt(localctx, 3)
                self.state = 822
                self.userCodeAttribute()
                pass
            elif token in [199]:
                self.enterOuterAlt(localctx, 4)
                self.state = 823
                self.chargeCodeAttribute()
                pass
            elif token in [198]:
                self.enterOuterAlt(localctx, 5)
                self.state = 824
                self.classAttribute()
                pass
            elif token in [273]:
                self.enterOuterAlt(localctx, 6)
                self.state = 825
                self.fetchAttribute()
                pass
            elif token in [192]:
                self.enterOuterAlt(localctx, 7)
                self.state = 826
                self.accessCodeAttribute()
                pass
            elif token in [208]:
                self.enterOuterAlt(localctx, 8)
                self.state = 827
                self.familyAttribute()
                pass
            elif token in [207]:
                self.enterOuterAlt(localctx, 9)
                self.state = 828
                self.elapsedLimitAttribute()
                pass
            elif token in [221]:
                self.enterOuterAlt(localctx, 10)
                self.state = 829
                self.maxIOTimeAttribute()
                pass
            elif token in [222]:
                self.enterOuterAlt(localctx, 11)
                self.state = 830
                self.maxLinesAttribute()
                pass
            elif token in [220]:
                self.enterOuterAlt(localctx, 12)
                self.state = 831
                self.maxProcTimeAttribute()
                pass
            elif token in [223]:
                self.enterOuterAlt(localctx, 13)
                self.state = 832
                self.maxWaitAttribute()
                pass
            elif token in [280]:
                self.enterOuterAlt(localctx, 14)
                self.state = 833
                self.startTimeAttribute()
                pass
            elif token in [360]:
                self.enterOuterAlt(localctx, 15)
                self.state = 834
                self.bdNameAttribute()
                pass
            elif token in [319]:
                self.enterOuterAlt(localctx, 16)
                self.state = 835
                self.languageAttribute()
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 17)
                self.state = 836
                self.optionsAttribute()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StackLimitAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STACKLIMIT(self):
            return self.getToken(WFLParser.STACKLIMIT, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stackLimitAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStackLimitAttribute" ):
                listener.enterStackLimitAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStackLimitAttribute" ):
                listener.exitStackLimitAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStackLimitAttribute" ):
                return visitor.visitStackLimitAttribute(self)
            else:
                return visitor.visitChildren(self)




    def stackLimitAttribute(self):

        localctx = WFLParser.StackLimitAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_stackLimitAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 839
            self.match(WFLParser.STACKLIMIT)
            self.state = 840
            self.match(WFLParser.EQUAL)
            self.state = 841
            self.match(WFLParser.Num)
            self.state = 842
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionsAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPTIONS(self):
            return self.getToken(WFLParser.OPTIONS, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def optionList(self):
            return self.getTypedRuleContext(WFLParser.OptionListContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_optionsAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionsAttribute" ):
                listener.enterOptionsAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionsAttribute" ):
                listener.exitOptionsAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionsAttribute" ):
                return visitor.visitOptionsAttribute(self)
            else:
                return visitor.visitChildren(self)




    def optionsAttribute(self):

        localctx = WFLParser.OptionsAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_optionsAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 844
            self.match(WFLParser.OPTIONS)
            self.state = 845
            self.match(WFLParser.EQUAL)
            self.state = 846
            self.match(WFLParser.LP)
            self.state = 847
            self.optionList()
            self.state = 848
            self.match(WFLParser.RP)
            self.state = 849
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.OptionContext)
            else:
                return self.getTypedRuleContext(WFLParser.OptionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_optionList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionList" ):
                listener.enterOptionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionList" ):
                listener.exitOptionList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionList" ):
                return visitor.visitOptionList(self)
            else:
                return visitor.visitChildren(self)




    def optionList(self):

        localctx = WFLParser.OptionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_optionList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 851
            self.option()
            self.state = 856
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 852
                self.match(WFLParser.COMMA)
                self.state = 853
                self.option()
                self.state = 858
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOption" ):
                listener.enterOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOption" ):
                listener.exitOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOption" ):
                return visitor.visitOption(self)
            else:
                return visitor.visitChildren(self)




    def option(self):

        localctx = WFLParser.OptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_option)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 859
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LanguageAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LANGUAGE(self):
            return self.getToken(WFLParser.LANGUAGE, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_languageAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLanguageAttribute" ):
                listener.enterLanguageAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLanguageAttribute" ):
                listener.exitLanguageAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLanguageAttribute" ):
                return visitor.visitLanguageAttribute(self)
            else:
                return visitor.visitChildren(self)




    def languageAttribute(self):

        localctx = WFLParser.LanguageAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_languageAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 861
            self.match(WFLParser.LANGUAGE)
            self.state = 862
            self.match(WFLParser.EQUAL)
            self.state = 863
            self.match(WFLParser.Identifier)
            self.state = 864
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BdNameAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BDNAME(self):
            return self.getToken(WFLParser.BDNAME, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_bdNameAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBdNameAttribute" ):
                listener.enterBdNameAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBdNameAttribute" ):
                listener.exitBdNameAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBdNameAttribute" ):
                return visitor.visitBdNameAttribute(self)
            else:
                return visitor.visitChildren(self)




    def bdNameAttribute(self):

        localctx = WFLParser.BdNameAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_bdNameAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 866
            self.match(WFLParser.BDNAME)
            self.state = 867
            self.match(WFLParser.EQUAL)
            self.state = 868
            self.filePath()
            self.state = 869
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartTimeAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STARTTIME(self):
            return self.getToken(WFLParser.STARTTIME, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def startTimeSpec(self):
            return self.getTypedRuleContext(WFLParser.StartTimeSpecContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_startTimeAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartTimeAttribute" ):
                listener.enterStartTimeAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartTimeAttribute" ):
                listener.exitStartTimeAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartTimeAttribute" ):
                return visitor.visitStartTimeAttribute(self)
            else:
                return visitor.visitChildren(self)




    def startTimeAttribute(self):

        localctx = WFLParser.StartTimeAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_startTimeAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 871
            self.match(WFLParser.STARTTIME)
            self.state = 872
            self.match(WFLParser.EQUAL)
            self.state = 873
            self.startTimeSpec()
            self.state = 874
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartTimeSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def time(self):
            return self.getTypedRuleContext(WFLParser.TimeContext,0)


        def PLUS(self):
            return self.getToken(WFLParser.PLUS, 0)

        def timeInterval(self):
            return self.getTypedRuleContext(WFLParser.TimeIntervalContext,0)


        def TODAY(self):
            return self.getToken(WFLParser.TODAY, 0)

        def TOMORROW(self):
            return self.getToken(WFLParser.TOMORROW, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def date(self):
            return self.getTypedRuleContext(WFLParser.DateContext,0)


        def dayInterval(self):
            return self.getTypedRuleContext(WFLParser.DayIntervalContext,0)


        def AT(self):
            return self.getToken(WFLParser.AT, 0)

        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_startTimeSpec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartTimeSpec" ):
                listener.enterStartTimeSpec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartTimeSpec" ):
                listener.exitStartTimeSpec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartTimeSpec" ):
                return visitor.visitStartTimeSpec(self)
            else:
                return visitor.visitChildren(self)




    def startTimeSpec(self):

        localctx = WFLParser.StartTimeSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_startTimeSpec)
        try:
            self.state = 911
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 876
                self.time()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 877
                self.time()
                self.state = 878
                self.match(WFLParser.PLUS)
                self.state = 879
                self.timeInterval()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 881
                self.match(WFLParser.TODAY)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 882
                self.match(WFLParser.TOMORROW)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 883
                self.match(WFLParser.ON)
                self.state = 884
                self.date()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 885
                self.match(WFLParser.ON)
                self.state = 886
                self.date()
                self.state = 887
                self.match(WFLParser.PLUS)
                self.state = 888
                self.dayInterval()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 890
                self.date()
                self.state = 891
                self.match(WFLParser.AT)
                self.state = 892
                self.time()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 894
                self.date()
                self.state = 895
                self.match(WFLParser.AT)
                self.state = 896
                self.time()
                self.state = 897
                self.match(WFLParser.PLUS)
                self.state = 898
                self.timeInterval()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 900
                self.match(WFLParser.PLUS)
                self.state = 901
                self.dayInterval()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 902
                self.time()
                self.state = 903
                self.match(WFLParser.ON)
                self.state = 904
                self.date()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 906
                self.time()
                self.state = 907
                self.match(WFLParser.ON)
                self.state = 908
                self.dayInterval()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 910
                self.fileReferencedVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime" ):
                return visitor.visitTime(self)
            else:
                return visitor.visitChildren(self)




    def time(self):

        localctx = WFLParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 913
            self.match(WFLParser.Num)
            self.state = 914
            self.match(WFLParser.COLON)
            self.state = 915
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_timeInterval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeInterval" ):
                listener.enterTimeInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeInterval" ):
                listener.exitTimeInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeInterval" ):
                return visitor.visitTimeInterval(self)
            else:
                return visitor.visitChildren(self)




    def timeInterval(self):

        localctx = WFLParser.TimeIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_timeInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 917
            self.match(WFLParser.Num)
            self.state = 918
            self.match(WFLParser.COLON)
            self.state = 919
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mm(self):
            return self.getTypedRuleContext(WFLParser.MmContext,0)


        def SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SLASH)
            else:
                return self.getToken(WFLParser.SLASH, i)

        def dd(self):
            return self.getTypedRuleContext(WFLParser.DdContext,0)


        def yy(self):
            return self.getTypedRuleContext(WFLParser.YyContext,0)


        def yyyy(self):
            return self.getTypedRuleContext(WFLParser.YyyyContext,0)


        def yyddd(self):
            return self.getTypedRuleContext(WFLParser.YydddContext,0)


        def yyyyddd(self):
            return self.getTypedRuleContext(WFLParser.YyyydddContext,0)


        def TODAY(self):
            return self.getToken(WFLParser.TODAY, 0)

        def TOMORROW(self):
            return self.getToken(WFLParser.TOMORROW, 0)

        def dayOfWeek(self):
            return self.getTypedRuleContext(WFLParser.DayOfWeekContext,0)


        def month(self):
            return self.getTypedRuleContext(WFLParser.MonthContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate" ):
                return visitor.visitDate(self)
            else:
                return visitor.visitChildren(self)




    def date(self):

        localctx = WFLParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_date)
        self._la = 0 # Token type
        try:
            self.state = 944
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 921
                self.mm()
                self.state = 922
                self.match(WFLParser.SLASH)
                self.state = 923
                self.dd()
                self.state = 924
                self.match(WFLParser.SLASH)
                self.state = 927
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                if la_ == 1:
                    self.state = 925
                    self.yy()
                    pass

                elif la_ == 2:
                    self.state = 926
                    self.yyyy()
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 929
                self.yyddd()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 930
                self.yyyyddd()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 931
                self.match(WFLParser.TODAY)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 932
                self.match(WFLParser.TOMORROW)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 933
                self.dayOfWeek()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 934
                self.month()
                self.state = 935
                self.match(WFLParser.COMMA)
                self.state = 936
                self.match(WFLParser.Num)
                self.state = 942
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 937
                    self.match(WFLParser.COMMA)
                    self.state = 940
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
                    if la_ == 1:
                        self.state = 938
                        self.yy()
                        pass

                    elif la_ == 2:
                        self.state = 939
                        self.yyyy()
                        pass




                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DayOfWeekContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUNDAY(self):
            return self.getToken(WFLParser.SUNDAY, 0)

        def MONDAY(self):
            return self.getToken(WFLParser.MONDAY, 0)

        def TUESDAY(self):
            return self.getToken(WFLParser.TUESDAY, 0)

        def WEDNESDAY(self):
            return self.getToken(WFLParser.WEDNESDAY, 0)

        def THURSDAY(self):
            return self.getToken(WFLParser.THURSDAY, 0)

        def FRIDAY(self):
            return self.getToken(WFLParser.FRIDAY, 0)

        def SATURDAY(self):
            return self.getToken(WFLParser.SATURDAY, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dayOfWeek

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDayOfWeek" ):
                listener.enterDayOfWeek(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDayOfWeek" ):
                listener.exitDayOfWeek(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDayOfWeek" ):
                return visitor.visitDayOfWeek(self)
            else:
                return visitor.visitChildren(self)




    def dayOfWeek(self):

        localctx = WFLParser.DayOfWeekContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_dayOfWeek)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 946
            _la = self._input.LA(1)
            if not(((((_la - 295)) & ~0x3f) == 0 and ((1 << (_la - 295)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MonthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JANUARY(self):
            return self.getToken(WFLParser.JANUARY, 0)

        def FEBRUARY(self):
            return self.getToken(WFLParser.FEBRUARY, 0)

        def MARCH(self):
            return self.getToken(WFLParser.MARCH, 0)

        def APRIL(self):
            return self.getToken(WFLParser.APRIL, 0)

        def MAY(self):
            return self.getToken(WFLParser.MAY, 0)

        def JUNE(self):
            return self.getToken(WFLParser.JUNE, 0)

        def JULY(self):
            return self.getToken(WFLParser.JULY, 0)

        def AUGUST(self):
            return self.getToken(WFLParser.AUGUST, 0)

        def SEPTEMBER(self):
            return self.getToken(WFLParser.SEPTEMBER, 0)

        def OCTOBER(self):
            return self.getToken(WFLParser.OCTOBER, 0)

        def NOVEMBER(self):
            return self.getToken(WFLParser.NOVEMBER, 0)

        def DECEMBER(self):
            return self.getToken(WFLParser.DECEMBER, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonth" ):
                listener.enterMonth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonth" ):
                listener.exitMonth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMonth" ):
                return visitor.visitMonth(self)
            else:
                return visitor.visitChildren(self)




    def month(self):

        localctx = WFLParser.MonthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_month)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 948
            _la = self._input.LA(1)
            if not(((((_la - 302)) & ~0x3f) == 0 and ((1 << (_la - 302)) & 7167) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_mm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMm" ):
                listener.enterMm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMm" ):
                listener.exitMm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMm" ):
                return visitor.visitMm(self)
            else:
                return visitor.visitChildren(self)




    def mm(self):

        localctx = WFLParser.MmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_mm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDd" ):
                listener.enterDd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDd" ):
                listener.exitDd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDd" ):
                return visitor.visitDd(self)
            else:
                return visitor.visitChildren(self)




    def dd(self):

        localctx = WFLParser.DdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_dd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 952
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_yy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYy" ):
                listener.enterYy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYy" ):
                listener.exitYy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYy" ):
                return visitor.visitYy(self)
            else:
                return visitor.visitChildren(self)




    def yy(self):

        localctx = WFLParser.YyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_yy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YyyyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_yyyy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYyyy" ):
                listener.enterYyyy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYyyy" ):
                listener.exitYyyy(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYyyy" ):
                return visitor.visitYyyy(self)
            else:
                return visitor.visitChildren(self)




    def yyyy(self):

        localctx = WFLParser.YyyyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_yyyy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 956
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YydddContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_yyddd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYyddd" ):
                listener.enterYyddd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYyddd" ):
                listener.exitYyddd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYyddd" ):
                return visitor.visitYyddd(self)
            else:
                return visitor.visitChildren(self)




    def yyddd(self):

        localctx = WFLParser.YydddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_yyddd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 958
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YyyydddContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_yyyyddd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYyyyddd" ):
                listener.enterYyyyddd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYyyyddd" ):
                listener.exitYyyyddd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYyyyddd" ):
                return visitor.visitYyyyddd(self)
            else:
                return visitor.visitChildren(self)




    def yyyyddd(self):

        localctx = WFLParser.YyyydddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_yyyyddd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 960
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DayIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(WFLParser.PLUS, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dayInterval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDayInterval" ):
                listener.enterDayInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDayInterval" ):
                listener.exitDayInterval(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDayInterval" ):
                return visitor.visitDayInterval(self)
            else:
                return visitor.visitChildren(self)




    def dayInterval(self):

        localctx = WFLParser.DayIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_dayInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 962
            self.match(WFLParser.PLUS)
            self.state = 963
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FetchAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FETCH(self):
            return self.getToken(WFLParser.FETCH, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fetchAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFetchAttribute" ):
                listener.enterFetchAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFetchAttribute" ):
                listener.exitFetchAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFetchAttribute" ):
                return visitor.visitFetchAttribute(self)
            else:
                return visitor.visitChildren(self)




    def fetchAttribute(self):

        localctx = WFLParser.FetchAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_fetchAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 965
            self.match(WFLParser.FETCH)
            self.state = 966
            self.match(WFLParser.EQUAL)
            self.state = 967
            self.match(WFLParser.LITERAL)
            self.state = 968
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxIOTimeAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXIOTIME(self):
            return self.getToken(WFLParser.MAXIOTIME, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_maxIOTimeAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxIOTimeAttribute" ):
                listener.enterMaxIOTimeAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxIOTimeAttribute" ):
                listener.exitMaxIOTimeAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxIOTimeAttribute" ):
                return visitor.visitMaxIOTimeAttribute(self)
            else:
                return visitor.visitChildren(self)




    def maxIOTimeAttribute(self):

        localctx = WFLParser.MaxIOTimeAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_maxIOTimeAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 970
            self.match(WFLParser.MAXIOTIME)
            self.state = 971
            self.match(WFLParser.EQUAL)
            self.state = 972
            self.match(WFLParser.Num)
            self.state = 973
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxLinesAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXLINES(self):
            return self.getToken(WFLParser.MAXLINES, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_maxLinesAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxLinesAttribute" ):
                listener.enterMaxLinesAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxLinesAttribute" ):
                listener.exitMaxLinesAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxLinesAttribute" ):
                return visitor.visitMaxLinesAttribute(self)
            else:
                return visitor.visitChildren(self)




    def maxLinesAttribute(self):

        localctx = WFLParser.MaxLinesAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_maxLinesAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 975
            self.match(WFLParser.MAXLINES)
            self.state = 976
            self.match(WFLParser.EQUAL)
            self.state = 977
            self.match(WFLParser.Num)
            self.state = 978
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxProcTimeAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXPROCTIME(self):
            return self.getToken(WFLParser.MAXPROCTIME, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_maxProcTimeAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxProcTimeAttribute" ):
                listener.enterMaxProcTimeAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxProcTimeAttribute" ):
                listener.exitMaxProcTimeAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxProcTimeAttribute" ):
                return visitor.visitMaxProcTimeAttribute(self)
            else:
                return visitor.visitChildren(self)




    def maxProcTimeAttribute(self):

        localctx = WFLParser.MaxProcTimeAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_maxProcTimeAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 980
            self.match(WFLParser.MAXPROCTIME)
            self.state = 981
            self.match(WFLParser.EQUAL)
            self.state = 982
            self.match(WFLParser.Num)
            self.state = 983
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxWaitAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXWAIT(self):
            return self.getToken(WFLParser.MAXWAIT, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_maxWaitAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxWaitAttribute" ):
                listener.enterMaxWaitAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxWaitAttribute" ):
                listener.exitMaxWaitAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxWaitAttribute" ):
                return visitor.visitMaxWaitAttribute(self)
            else:
                return visitor.visitChildren(self)




    def maxWaitAttribute(self):

        localctx = WFLParser.MaxWaitAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_maxWaitAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 985
            self.match(WFLParser.MAXWAIT)
            self.state = 986
            self.match(WFLParser.EQUAL)
            self.state = 987
            self.match(WFLParser.Num)
            self.state = 988
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElapsedLimitAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSEDLIMIT(self):
            return self.getToken(WFLParser.ELAPSEDLIMIT, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_elapsedLimitAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElapsedLimitAttribute" ):
                listener.enterElapsedLimitAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElapsedLimitAttribute" ):
                listener.exitElapsedLimitAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElapsedLimitAttribute" ):
                return visitor.visitElapsedLimitAttribute(self)
            else:
                return visitor.visitChildren(self)




    def elapsedLimitAttribute(self):

        localctx = WFLParser.ElapsedLimitAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_elapsedLimitAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 990
            self.match(WFLParser.ELAPSEDLIMIT)
            self.state = 991
            self.match(WFLParser.EQUAL)
            self.state = 992
            self.match(WFLParser.Num)
            self.state = 993
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FamilyAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAMILY(self):
            return self.getToken(WFLParser.FAMILY, 0)

        def reservedKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ReservedKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,i)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def storageUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StorageUnitContext)
            else:
                return self.getTypedRuleContext(WFLParser.StorageUnitContext,i)


        def ONLY(self):
            return self.getToken(WFLParser.ONLY, 0)

        def OTHERWISE(self):
            return self.getToken(WFLParser.OTHERWISE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_familyAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFamilyAttribute" ):
                listener.enterFamilyAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFamilyAttribute" ):
                listener.exitFamilyAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFamilyAttribute" ):
                return visitor.visitFamilyAttribute(self)
            else:
                return visitor.visitChildren(self)




    def familyAttribute(self):

        localctx = WFLParser.FamilyAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_familyAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 995
            self.match(WFLParser.FAMILY)
            self.state = 996
            self.reservedKeyword()
            self.state = 997
            self.match(WFLParser.EQUAL)
            self.state = 1000
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [201, 209, 211, 219]:
                self.state = 998
                self.reservedKeyword()
                pass
            elif token in [446]:
                self.state = 999
                self.storageUnit()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1003
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==394:
                self.state = 1002
                self.match(WFLParser.ONLY)


            self.state = 1010
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==218:
                self.state = 1005
                self.match(WFLParser.OTHERWISE)
                self.state = 1008
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [201, 209, 211, 219]:
                    self.state = 1006
                    self.reservedKeyword()
                    pass
                elif token in [446]:
                    self.state = 1007
                    self.storageUnit()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 1012
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReservedKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TITLE(self):
            return self.getToken(WFLParser.TITLE, 0)

        def KIND(self):
            return self.getToken(WFLParser.KIND, 0)

        def DISK(self):
            return self.getToken(WFLParser.DISK, 0)

        def MYPACK(self):
            return self.getToken(WFLParser.MYPACK, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_reservedKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReservedKeyword" ):
                listener.enterReservedKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReservedKeyword" ):
                listener.exitReservedKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReservedKeyword" ):
                return visitor.visitReservedKeyword(self)
            else:
                return visitor.visitChildren(self)




    def reservedKeyword(self):

        localctx = WFLParser.ReservedKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_reservedKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1014
            _la = self._input.LA(1)
            if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 263425) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccessCodeAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCESSCODE(self):
            return self.getToken(WFLParser.ACCESSCODE, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_accessCodeAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessCodeAttribute" ):
                listener.enterAccessCodeAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessCodeAttribute" ):
                listener.exitAccessCodeAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessCodeAttribute" ):
                return visitor.visitAccessCodeAttribute(self)
            else:
                return visitor.visitChildren(self)




    def accessCodeAttribute(self):

        localctx = WFLParser.AccessCodeAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_accessCodeAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1016
            self.match(WFLParser.ACCESSCODE)
            self.state = 1017
            self.match(WFLParser.EQUAL)
            self.state = 1018
            self.filePath()
            self.state = 1019
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER(self):
            return self.getToken(WFLParser.USER, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_userAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserAttribute" ):
                listener.enterUserAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserAttribute" ):
                listener.exitUserAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserAttribute" ):
                return visitor.visitUserAttribute(self)
            else:
                return visitor.visitChildren(self)




    def userAttribute(self):

        localctx = WFLParser.UserAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_userAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            self.match(WFLParser.USER)
            self.state = 1022
            self.match(WFLParser.EQUAL)
            self.state = 1023
            self.filePath()
            self.state = 1024
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserCodeAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USERCODE(self):
            return self.getToken(WFLParser.USERCODE, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_userCodeAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserCodeAttribute" ):
                listener.enterUserCodeAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserCodeAttribute" ):
                listener.exitUserCodeAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserCodeAttribute" ):
                return visitor.visitUserCodeAttribute(self)
            else:
                return visitor.visitChildren(self)




    def userCodeAttribute(self):

        localctx = WFLParser.UserCodeAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_userCodeAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1026
            self.match(WFLParser.USERCODE)
            self.state = 1027
            self.match(WFLParser.EQUAL)
            self.state = 1028
            self.filePath()
            self.state = 1029
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(WFLParser.CLASS, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_classAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassAttribute" ):
                listener.enterClassAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassAttribute" ):
                listener.exitClassAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassAttribute" ):
                return visitor.visitClassAttribute(self)
            else:
                return visitor.visitChildren(self)




    def classAttribute(self):

        localctx = WFLParser.ClassAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_classAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1031
            self.match(WFLParser.CLASS)
            self.state = 1032
            self.match(WFLParser.EQUAL)
            self.state = 1033
            self.match(WFLParser.Num)
            self.state = 1034
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PriorityAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIORITY(self):
            return self.getToken(WFLParser.PRIORITY, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_priorityAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPriorityAttribute" ):
                listener.enterPriorityAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPriorityAttribute" ):
                listener.exitPriorityAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPriorityAttribute" ):
                return visitor.visitPriorityAttribute(self)
            else:
                return visitor.visitChildren(self)




    def priorityAttribute(self):

        localctx = WFLParser.PriorityAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_priorityAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1036
            self.match(WFLParser.PRIORITY)
            self.state = 1037
            self.match(WFLParser.EQUAL)
            self.state = 1038
            self.match(WFLParser.Num)
            self.state = 1039
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChargeCodeAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHARGECODE(self):
            return self.getToken(WFLParser.CHARGECODE, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_chargeCodeAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChargeCodeAttribute" ):
                listener.enterChargeCodeAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChargeCodeAttribute" ):
                listener.exitChargeCodeAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChargeCodeAttribute" ):
                return visitor.visitChargeCodeAttribute(self)
            else:
                return visitor.visitChildren(self)




    def chargeCodeAttribute(self):

        localctx = WFLParser.ChargeCodeAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_chargeCodeAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1041
            self.match(WFLParser.CHARGECODE)
            self.state = 1042
            self.match(WFLParser.EQUAL)
            self.state = 1043
            self.match(WFLParser.Identifier)
            self.state = 1044
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(WFLParser.DeclarationContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_declarations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarations" ):
                listener.enterDeclarations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarations" ):
                listener.exitDeclarations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarations" ):
                return visitor.visitDeclarations(self)
            else:
                return visitor.visitChildren(self)




    def declarations(self):

        localctx = WFLParser.DeclarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_declarations)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1047 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1046
                    self.declaration()

                else:
                    raise NoViableAltException(self)
                self.state = 1049 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantDeclaration(self):
            return self.getTypedRuleContext(WFLParser.ConstantDeclarationContext,0)


        def booleanDeclaration(self):
            return self.getTypedRuleContext(WFLParser.BooleanDeclarationContext,0)


        def integerDeclaration(self):
            return self.getTypedRuleContext(WFLParser.IntegerDeclarationContext,0)


        def realDeclaration(self):
            return self.getTypedRuleContext(WFLParser.RealDeclarationContext,0)


        def stringDeclaration(self):
            return self.getTypedRuleContext(WFLParser.StringDeclarationContext,0)


        def fileDeclaration(self):
            return self.getTypedRuleContext(WFLParser.FileDeclarationContext,0)


        def taskDeclaration(self):
            return self.getTypedRuleContext(WFLParser.TaskDeclarationContext,0)


        def subroutineDeclaration(self):
            return self.getTypedRuleContext(WFLParser.SubroutineDeclarationContext,0)


        def includeDeclaration(self):
            return self.getTypedRuleContext(WFLParser.IncludeDeclarationContext,0)


        def dataDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DataDeclarationContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = WFLParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_declaration)
        try:
            self.state = 1061
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [229]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1051
                self.constantDeclaration()
                pass
            elif token in [230]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1052
                self.booleanDeclaration()
                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1053
                self.integerDeclaration()
                pass
            elif token in [231]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1054
                self.realDeclaration()
                pass
            elif token in [235]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1055
                self.stringDeclaration()
                pass
            elif token in [237]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1056
                self.fileDeclaration()
                pass
            elif token in [238]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1057
                self.taskDeclaration()
                pass
            elif token in [246]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1058
                self.subroutineDeclaration()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1059
                self.includeDeclaration()
                pass
            elif token in [22, 200]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1060
                self.dataDeclaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA(self):
            return self.getToken(WFLParser.DATA, 0)

        def QMARK(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.QMARK)
            else:
                return self.getToken(WFLParser.QMARK, i)

        def databaseDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatabaseDeclarationContext,0)


        def dumpDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DumpDeclarationContext,0)


        def setMergeResetList(self):
            return self.getTypedRuleContext(WFLParser.SetMergeResetListContext,0)


        def setMergeLabelsintable(self):
            return self.getTypedRuleContext(WFLParser.SetMergeLabelsintableContext,0)


        def setListClause(self):
            return self.getTypedRuleContext(WFLParser.SetListClauseContext,0)


        def resetZipClause(self):
            return self.getTypedRuleContext(WFLParser.ResetZipClauseContext,0)


        def updateClause(self):
            return self.getTypedRuleContext(WFLParser.UpdateClauseContext,0)


        def databaseClause(self):
            return self.getTypedRuleContext(WFLParser.DatabaseClauseContext,0)


        def dataUseClause(self):
            return self.getTypedRuleContext(WFLParser.DataUseClauseContext,0)


        def dataSpecification(self):
            return self.getTypedRuleContext(WFLParser.DataSpecificationContext,0)


        def dataSystemClause(self):
            return self.getTypedRuleContext(WFLParser.DataSystemClauseContext,0)


        def dataShowName(self):
            return self.getTypedRuleContext(WFLParser.DataShowNameContext,0)


        def dataFilePathDelaration(self):
            return self.getTypedRuleContext(WFLParser.DataFilePathDelarationContext,0)


        def CARD(self):
            return self.getToken(WFLParser.CARD, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def setListZipClause(self):
            return self.getTypedRuleContext(WFLParser.SetListZipClauseContext,0)


        def generateBlock(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.GenerateBlockContext)
            else:
                return self.getTypedRuleContext(WFLParser.GenerateBlockContext,i)


        def globalAndResourseSetting(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.GlobalAndResourseSettingContext)
            else:
                return self.getTypedRuleContext(WFLParser.GlobalAndResourseSettingContext,i)


        def dataUserAndAccessCodeListClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataUserAndAccessCodeListClauseContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataUserAndAccessCodeListClauseContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_dataDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataDeclaration" ):
                listener.enterDataDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataDeclaration" ):
                listener.exitDataDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataDeclaration" ):
                return visitor.visitDataDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def dataDeclaration(self):

        localctx = WFLParser.DataDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_dataDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1064
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 1063
                self.match(WFLParser.QMARK)


            self.state = 1066
            self.match(WFLParser.DATA)
            self.state = 1068
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 1067
                self.match(WFLParser.CARD)


            self.state = 1071
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 1070
                self.match(WFLParser.SEMICOLON)


            self.state = 1114
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.state = 1073
                self.databaseDeclaration()
                self.state = 1074
                self.dumpDeclaration()
                pass

            elif la_ == 2:
                self.state = 1078
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 1076
                    self.setListZipClause()

                elif la_ == 2:
                    self.state = 1077
                    self.resetZipClause()


                self.state = 1081
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==75:
                    self.state = 1080
                    self.updateClause()


                self.state = 1086
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==205:
                    self.state = 1083
                    self.generateBlock()
                    self.state = 1088
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1090
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==20:
                    self.state = 1089
                    self.match(WFLParser.SEMICOLON)


                self.state = 1093 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1092
                    self.globalAndResourseSetting()
                    self.state = 1095 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1095216660480) != 0) or ((((_la - 76)) & ~0x3f) == 0 and ((1 << (_la - 76)) & 234881025) != 0) or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 2327883808801) != 0) or ((((_la - 315)) & ~0x3f) == 0 and ((1 << (_la - 315)) & -1879048193) != 0) or ((((_la - 379)) & ~0x3f) == 0 and ((1 << (_la - 379)) & -8646911284551350273) != 0)):
                        break

                pass

            elif la_ == 3:
                self.state = 1097
                self.setMergeResetList()
                pass

            elif la_ == 4:
                self.state = 1098
                self.setMergeLabelsintable()
                pass

            elif la_ == 5:
                self.state = 1099
                self.setListClause()
                pass

            elif la_ == 6:
                self.state = 1101 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1100
                    self.dataUserAndAccessCodeListClause()
                    self.state = 1103 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==225):
                        break

                pass

            elif la_ == 7:
                self.state = 1105
                self.resetZipClause()
                self.state = 1106
                self.updateClause()
                pass

            elif la_ == 8:
                self.state = 1108
                self.databaseClause()
                pass

            elif la_ == 9:
                self.state = 1109
                self.dataUseClause()
                pass

            elif la_ == 10:
                self.state = 1110
                self.dataSpecification()
                pass

            elif la_ == 11:
                self.state = 1111
                self.dataSystemClause()
                pass

            elif la_ == 12:
                self.state = 1112
                self.dataShowName()
                pass

            elif la_ == 13:
                self.state = 1113
                self.dataFilePathDelaration()
                pass


            self.state = 1116
            self.match(WFLParser.QMARK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataFilePathDelarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.DOT)
            else:
                return self.getToken(WFLParser.DOT, i)

        def getRuleIndex(self):
            return WFLParser.RULE_dataFilePathDelaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataFilePathDelaration" ):
                listener.enterDataFilePathDelaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataFilePathDelaration" ):
                listener.exitDataFilePathDelaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataFilePathDelaration" ):
                return visitor.visitDataFilePathDelaration(self)
            else:
                return visitor.visitChildren(self)




    def dataFilePathDelaration(self):

        localctx = WFLParser.DataFilePathDelarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_dataFilePathDelaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1118
                self.filePath()
                self.state = 1119
                self.match(WFLParser.DOT)
                self.state = 1123 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193241698771857400) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & 5337044842969038851) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & -5133502405958044447) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & -31489968026910211) != 0) or ((((_la - 324)) & ~0x3f) == 0 and ((1 << (_la - 324)) & -1) != 0) or ((((_la - 388)) & ~0x3f) == 0 and ((1 << (_la - 388)) & 4414653535803671627) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataShowNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def NAME(self):
            return self.getToken(WFLParser.NAME, 0)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_dataShowName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataShowName" ):
                listener.enterDataShowName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataShowName" ):
                listener.exitDataShowName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataShowName" ):
                return visitor.visitDataShowName(self)
            else:
                return visitor.visitChildren(self)




    def dataShowName(self):

        localctx = WFLParser.DataShowNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_dataShowName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1125
            self.filePath()
            self.state = 1128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 1126
                self.match(WFLParser.ON)
                self.state = 1127
                self.storageUnit()


            self.state = 1130
            self.match(WFLParser.Identifier)
            self.state = 1131
            self.match(WFLParser.NAME)
            self.state = 1132
            self.match(WFLParser.COLON)
            self.state = 1133
            self.match(WFLParser.FILE)
            self.state = 1134
            self.filePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSystemClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COLON)
            else:
                return self.getToken(WFLParser.COLON, i)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def taskAttribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskAttributeContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskAttributeContext,i)


        def QUIT(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.QUIT)
            else:
                return self.getToken(WFLParser.QUIT, i)

        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.ON)
            else:
                return self.getToken(WFLParser.ON, i)

        def storageUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StorageUnitContext)
            else:
                return self.getTypedRuleContext(WFLParser.StorageUnitContext,i)


        def ENABLE(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.ENABLE)
            else:
                return self.getToken(WFLParser.ENABLE, i)

        def DISABLE(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.DISABLE)
            else:
                return self.getToken(WFLParser.DISABLE, i)

        def PROGRAM(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.PROGRAM)
            else:
                return self.getToken(WFLParser.PROGRAM, i)

        def getRuleIndex(self):
            return WFLParser.RULE_dataSystemClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSystemClause" ):
                listener.enterDataSystemClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSystemClause" ):
                listener.exitDataSystemClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSystemClause" ):
                return visitor.visitDataSystemClause(self)
            else:
                return visitor.visitChildren(self)




    def dataSystemClause(self):

        localctx = WFLParser.DataSystemClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_dataSystemClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1154 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1136
                self.filePath()
                self.state = 1139
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==253:
                    self.state = 1137
                    self.match(WFLParser.ON)
                    self.state = 1138
                    self.storageUnit()


                self.state = 1141
                self.match(WFLParser.COLON)
                self.state = 1144
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 1142
                    self.match(WFLParser.Identifier)
                    pass
                elif token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442]:
                    self.state = 1143
                    self.taskAttribute()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1146
                self.match(WFLParser.COLON)
                self.state = 1152
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [69, 70]:
                    self.state = 1147
                    _la = self._input.LA(1)
                    if not(_la==69 or _la==70):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1148
                    _la = self._input.LA(1)
                    if not(_la==56 or _la==446):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1149
                    self.match(WFLParser.Identifier)
                    pass
                elif token in [54]:
                    self.state = 1150
                    self.match(WFLParser.QUIT)
                    self.state = 1151
                    self.match(WFLParser.Identifier)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1156 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193241698771857400) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & 5337044842969038851) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & -5133502405958044447) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & -31489968026910211) != 0) or ((((_la - 324)) & ~0x3f) == 0 and ((1 << (_la - 324)) & -1) != 0) or ((((_la - 388)) & ~0x3f) == 0 and ((1 << (_la - 388)) & 4414653535803671627) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SPEC(self):
            return self.getToken(WFLParser.SPEC, 0)

        def dataSpecificationAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataSpecificationAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataSpecificationAssignmentContext,i)


        def dataSpecificationSection(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataSpecificationSectionContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataSpecificationSectionContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecification" ):
                listener.enterDataSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecification" ):
                listener.exitDataSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecification" ):
                return visitor.visitDataSpecification(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecification(self):

        localctx = WFLParser.DataSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_dataSpecification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1158
            self.match(WFLParser.SPEC)
            self.state = 1161 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1161
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 1159
                    self.dataSpecificationAssignment()
                    pass

                elif la_ == 2:
                    self.state = 1160
                    self.dataSpecificationSection()
                    pass


                self.state = 1163 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 36029892235624448) != 0) or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 2327883808801) != 0) or ((((_la - 315)) & ~0x3f) == 0 and ((1 << (_la - 315)) & -1879048193) != 0) or ((((_la - 379)) & ~0x3f) == 0 and ((1 << (_la - 379)) & -8646911284551350273) != 0) or _la==446):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataSpecificationAttribute(self):
            return self.getTypedRuleContext(WFLParser.DataSpecificationAttributeContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def dataSpecificationValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataSpecificationValueContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataSpecificationValueContext,i)


        def DOT(self):
            return self.getToken(WFLParser.DOT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationAssignment" ):
                listener.enterDataSpecificationAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationAssignment" ):
                listener.exitDataSpecificationAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationAssignment" ):
                return visitor.visitDataSpecificationAssignment(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationAssignment(self):

        localctx = WFLParser.DataSpecificationAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_dataSpecificationAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1165
            self.dataSpecificationAttribute()
            self.state = 1166
            self.match(WFLParser.EQUAL)
            self.state = 1167
            self.dataSpecificationValue()
            self.state = 1172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1168
                self.match(WFLParser.COMMA)
                self.state = 1169
                self.dataSpecificationValue()
                self.state = 1174
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1175
            self.match(WFLParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataSpecificationSectionType(self):
            return self.getTypedRuleContext(WFLParser.DataSpecificationSectionTypeContext,0)


        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def dataSpecificationSectionName(self):
            return self.getTypedRuleContext(WFLParser.DataSpecificationSectionNameContext,0)


        def dataSpecificationAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataSpecificationAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataSpecificationAssignmentContext,i)


        def dataSpecificationEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataSpecificationEntryContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataSpecificationEntryContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationSection" ):
                listener.enterDataSpecificationSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationSection" ):
                listener.exitDataSpecificationSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationSection" ):
                return visitor.visitDataSpecificationSection(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationSection(self):

        localctx = WFLParser.DataSpecificationSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_dataSpecificationSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1177
            self.dataSpecificationSectionType()
            self.state = 1179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -1193241698771857400) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & 5337044842969038851) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & -5133502405958044447) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & -31489968026910211) != 0) or ((((_la - 324)) & ~0x3f) == 0 and ((1 << (_la - 324)) & -1) != 0) or ((((_la - 388)) & ~0x3f) == 0 and ((1 << (_la - 388)) & 4414653535803671627) != 0):
                self.state = 1178
                self.dataSpecificationSectionName()


            self.state = 1181
            self.match(WFLParser.COLON)
            self.state = 1184 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1184
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442, 446]:
                        self.state = 1182
                        self.dataSpecificationAssignment()
                        pass
                    elif token in [117]:
                        self.state = 1183
                        self.dataSpecificationEntry()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 1186 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTRY(self):
            return self.getToken(WFLParser.ENTRY, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def dataSpecificationAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataSpecificationAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataSpecificationAssignmentContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationEntry" ):
                listener.enterDataSpecificationEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationEntry" ):
                listener.exitDataSpecificationEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationEntry" ):
                return visitor.visitDataSpecificationEntry(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationEntry(self):

        localctx = WFLParser.DataSpecificationEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_dataSpecificationEntry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1188
            self.match(WFLParser.ENTRY)
            self.state = 1189
            self.match(WFLParser.Num)
            self.state = 1190
            self.match(WFLParser.LP)
            self.state = 1191
            self.match(WFLParser.Identifier)
            self.state = 1192
            self.match(WFLParser.RP)
            self.state = 1193
            self.match(WFLParser.COLON)
            self.state = 1195 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1194
                    self.dataSpecificationAssignment()

                else:
                    raise NoViableAltException(self)
                self.state = 1197 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationSectionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def DATASET(self):
            return self.getToken(WFLParser.DATASET, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationSectionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationSectionType" ):
                listener.enterDataSpecificationSectionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationSectionType" ):
                listener.exitDataSpecificationSectionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationSectionType" ):
                return visitor.visitDataSpecificationSectionType(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationSectionType(self):

        localctx = WFLParser.DataSpecificationSectionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_dataSpecificationSectionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1199
            _la = self._input.LA(1)
            if not(_la==55 or _la==446):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationSectionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationSectionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationSectionName" ):
                listener.enterDataSpecificationSectionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationSectionName" ):
                listener.exitDataSpecificationSectionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationSectionName" ):
                return visitor.visitDataSpecificationSectionName(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationSectionName(self):

        localctx = WFLParser.DataSpecificationSectionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_dataSpecificationSectionName)
        self._la = 0 # Token type
        try:
            self.state = 1215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1201
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1202
                self.filePath()
                self.state = 1213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==12:
                    self.state = 1203
                    self.match(WFLParser.LP)
                    self.state = 1204
                    self.match(WFLParser.Num)
                    self.state = 1209
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==4:
                        self.state = 1205
                        self.match(WFLParser.COMMA)
                        self.state = 1206
                        self.match(WFLParser.Num)
                        self.state = 1211
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1212
                    self.match(WFLParser.RP)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationAttribute" ):
                listener.enterDataSpecificationAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationAttribute" ):
                listener.exitDataSpecificationAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationAttribute" ):
                return visitor.visitDataSpecificationAttribute(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationAttribute(self):

        localctx = WFLParser.DataSpecificationAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_dataSpecificationAttribute)
        try:
            self.state = 1219
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1217
                self.match(WFLParser.Identifier)
                pass
            elif token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1218
                self.taskAttribute()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataSpecificationValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def NumCombineWithChar(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.NumCombineWithChar)
            else:
                return self.getToken(WFLParser.NumCombineWithChar, i)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_dataSpecificationValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataSpecificationValue" ):
                listener.enterDataSpecificationValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataSpecificationValue" ):
                listener.exitDataSpecificationValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataSpecificationValue" ):
                return visitor.visitDataSpecificationValue(self)
            else:
                return visitor.visitChildren(self)




    def dataSpecificationValue(self):

        localctx = WFLParser.DataSpecificationValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_dataSpecificationValue)
        self._la = 0 # Token type
        try:
            self.state = 1231
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1221
                self.filePath()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1222
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1223
                self.match(WFLParser.Num)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1224
                self.match(WFLParser.NumCombineWithChar)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1225
                self.match(WFLParser.LP)
                self.state = 1226
                _la = self._input.LA(1)
                if not(_la==447 or _la==448):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1227
                self.match(WFLParser.COMMA)
                self.state = 1228
                _la = self._input.LA(1)
                if not(_la==447 or _la==448):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1229
                self.match(WFLParser.RP)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1230
                self.booleanConstantExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataUseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def dataUseClauseComponent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataUseClauseComponentContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataUseClauseComponentContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_dataUseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataUseClause" ):
                listener.enterDataUseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataUseClause" ):
                listener.exitDataUseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataUseClause" ):
                return visitor.visitDataUseClause(self)
            else:
                return visitor.visitChildren(self)




    def dataUseClause(self):

        localctx = WFLParser.DataUseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_dataUseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1234 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1233
                self.dataUseClauseComponent()
                self.state = 1236 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 59)) & ~0x3f) == 0 and ((1 << (_la - 59)) & 9007199657394189) != 0) or ((((_la - 156)) & ~0x3f) == 0 and ((1 << (_la - 156)) & 4194307) != 0) or _la==244 or _la==343):
                    break

            self.state = 1238
            self.match(WFLParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataUseClauseComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useComponent(self):
            return self.getTypedRuleContext(WFLParser.UseComponentContext,0)


        def reportComponent(self):
            return self.getTypedRuleContext(WFLParser.ReportComponentContext,0)


        def sourceComponent(self):
            return self.getTypedRuleContext(WFLParser.SourceComponentContext,0)


        def sortByComponent(self):
            return self.getTypedRuleContext(WFLParser.SortByComponentContext,0)


        def breakComponent(self):
            return self.getTypedRuleContext(WFLParser.BreakComponentContext,0)


        def includeComponent(self):
            return self.getTypedRuleContext(WFLParser.IncludeComponentContext,0)


        def excludeComponent(self):
            return self.getTypedRuleContext(WFLParser.ExcludeComponentContext,0)


        def outputComponent(self):
            return self.getTypedRuleContext(WFLParser.OutputComponentContext,0)


        def reportsComponent(self):
            return self.getTypedRuleContext(WFLParser.ReportsComponentContext,0)


        def pageComponent(self):
            return self.getTypedRuleContext(WFLParser.PageComponentContext,0)


        def headingComponent(self):
            return self.getTypedRuleContext(WFLParser.HeadingComponentContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_dataUseClauseComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataUseClauseComponent" ):
                listener.enterDataUseClauseComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataUseClauseComponent" ):
                listener.exitDataUseClauseComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataUseClauseComponent" ):
                return visitor.visitDataUseClauseComponent(self)
            else:
                return visitor.visitChildren(self)




    def dataUseClauseComponent(self):

        localctx = WFLParser.DataUseClauseComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_dataUseClauseComponent)
        try:
            self.state = 1251
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [59]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1240
                self.useComponent()
                pass
            elif token in [157]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1241
                self.reportComponent()
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1242
                self.sourceComponent()
                pass
            elif token in [178]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1243
                self.sortByComponent()
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1244
                self.breakComponent()
                pass
            elif token in [112]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1245
                self.includeComponent()
                pass
            elif token in [244]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1246
                self.excludeComponent()
                pass
            elif token in [343]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1247
                self.outputComponent()
                pass
            elif token in [156]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1248
                self.reportsComponent()
                pass
            elif token in [87]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1249
                self.pageComponent()
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1250
                self.headingComponent()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HeadingComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEADING(self):
            return self.getToken(WFLParser.HEADING, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def IS(self):
            return self.getToken(WFLParser.IS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_headingComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeadingComponent" ):
                listener.enterHeadingComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeadingComponent" ):
                listener.exitHeadingComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeadingComponent" ):
                return visitor.visitHeadingComponent(self)
            else:
                return visitor.visitChildren(self)




    def headingComponent(self):

        localctx = WFLParser.HeadingComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_headingComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1253
            self.match(WFLParser.HEADING)
            self.state = 1255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==270:
                self.state = 1254
                self.match(WFLParser.IS)


            self.state = 1257
            self.match(WFLParser.LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PageComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAGE(self):
            return self.getToken(WFLParser.PAGE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def IS(self):
            return self.getToken(WFLParser.IS, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_pageComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPageComponent" ):
                listener.enterPageComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPageComponent" ):
                listener.exitPageComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPageComponent" ):
                return visitor.visitPageComponent(self)
            else:
                return visitor.visitChildren(self)




    def pageComponent(self):

        localctx = WFLParser.PageComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_pageComponent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1259
            self.match(WFLParser.PAGE)
            self.state = 1260
            self.match(WFLParser.Identifier)
            self.state = 1261
            self.match(WFLParser.IS)
            self.state = 1262
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(WFLParser.INCLUDE, 0)

        def IF(self):
            return self.getToken(WFLParser.IF, 0)

        def condition(self):
            return self.getTypedRuleContext(WFLParser.ConditionContext,0)


        def RECORD(self):
            return self.getToken(WFLParser.RECORD, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_includeComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeComponent" ):
                listener.enterIncludeComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeComponent" ):
                listener.exitIncludeComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeComponent" ):
                return visitor.visitIncludeComponent(self)
            else:
                return visitor.visitChildren(self)




    def includeComponent(self):

        localctx = WFLParser.IncludeComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_includeComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1264
            self.match(WFLParser.INCLUDE)
            self.state = 1266
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 1265
                self.match(WFLParser.RECORD)


            self.state = 1268
            self.match(WFLParser.IF)
            self.state = 1269
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExcludeComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLUDE(self):
            return self.getToken(WFLParser.EXCLUDE, 0)

        def IF(self):
            return self.getToken(WFLParser.IF, 0)

        def condition(self):
            return self.getTypedRuleContext(WFLParser.ConditionContext,0)


        def RECORD(self):
            return self.getToken(WFLParser.RECORD, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_excludeComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExcludeComponent" ):
                listener.enterExcludeComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExcludeComponent" ):
                listener.exitExcludeComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExcludeComponent" ):
                return visitor.visitExcludeComponent(self)
            else:
                return visitor.visitChildren(self)




    def excludeComponent(self):

        localctx = WFLParser.ExcludeComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_excludeComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1271
            self.match(WFLParser.EXCLUDE)
            self.state = 1273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==57:
                self.state = 1272
                self.match(WFLParser.RECORD)


            self.state = 1275
            self.match(WFLParser.IF)
            self.state = 1276
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OUTPUT(self):
            return self.getToken(WFLParser.OUTPUT, 0)

        def ITEMS(self):
            return self.getToken(WFLParser.ITEMS, 0)

        def ARE(self):
            return self.getToken(WFLParser.ARE, 0)

        def outputItems(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.OutputItemsContext)
            else:
                return self.getTypedRuleContext(WFLParser.OutputItemsContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_outputComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputComponent" ):
                listener.enterOutputComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputComponent" ):
                listener.exitOutputComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputComponent" ):
                return visitor.visitOutputComponent(self)
            else:
                return visitor.visitChildren(self)




    def outputComponent(self):

        localctx = WFLParser.OutputComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_outputComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1278
            self.match(WFLParser.OUTPUT)
            self.state = 1279
            self.match(WFLParser.ITEMS)
            self.state = 1280
            self.match(WFLParser.ARE)
            self.state = 1281
            self.outputItems()
            self.state = 1286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1282
                self.match(WFLParser.COMMA)
                self.state = 1283
                self.outputItems()
                self.state = 1288
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReportsComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPORTS(self):
            return self.getToken(WFLParser.REPORTS, 0)

        def ARE(self):
            return self.getToken(WFLParser.ARE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_reportsComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReportsComponent" ):
                listener.enterReportsComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReportsComponent" ):
                listener.exitReportsComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReportsComponent" ):
                return visitor.visitReportsComponent(self)
            else:
                return visitor.visitChildren(self)




    def reportsComponent(self):

        localctx = WFLParser.ReportsComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_reportsComponent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1289
            self.match(WFLParser.REPORTS)
            self.state = 1290
            self.match(WFLParser.ARE)
            self.state = 1291
            self.match(WFLParser.Identifier)
            self.state = 1292
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputItemsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def USERCODE(self):
            return self.getToken(WFLParser.USERCODE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def STARTTIME(self):
            return self.getToken(WFLParser.STARTTIME, 0)

        def MINUS(self):
            return self.getToken(WFLParser.MINUS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_outputItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputItems" ):
                listener.enterOutputItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputItems" ):
                listener.exitOutputItems(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputItems" ):
                return visitor.visitOutputItems(self)
            else:
                return visitor.visitChildren(self)




    def outputItems(self):

        localctx = WFLParser.OutputItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_outputItems)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 1294
                self.match(WFLParser.MINUS)


            self.state = 1301
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
            if la_ == 1:
                self.state = 1297
                self.taskAttribute()
                pass

            elif la_ == 2:
                self.state = 1298
                self.match(WFLParser.USERCODE)
                pass

            elif la_ == 3:
                self.state = 1299
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 4:
                self.state = 1300
                self.match(WFLParser.STARTTIME)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(WFLParser.USE, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def getRuleIndex(self):
            return WFLParser.RULE_useComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseComponent" ):
                listener.enterUseComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseComponent" ):
                listener.exitUseComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseComponent" ):
                return visitor.visitUseComponent(self)
            else:
                return visitor.visitChildren(self)




    def useComponent(self):

        localctx = WFLParser.UseComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_useComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1303
            self.match(WFLParser.USE)
            self.state = 1305 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1304
                _la = self._input.LA(1)
                if not(_la==446 or _la==447):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1307 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==446 or _la==447):
                    break

            self.state = 1311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 1309
                self.match(WFLParser.ON)
                self.state = 1310
                self.storageUnit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReportComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPORT(self):
            return self.getToken(WFLParser.REPORT, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_reportComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReportComponent" ):
                listener.enterReportComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReportComponent" ):
                listener.exitReportComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReportComponent" ):
                return visitor.visitReportComponent(self)
            else:
                return visitor.visitChildren(self)




    def reportComponent(self):

        localctx = WFLParser.ReportComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_reportComponent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1313
            self.match(WFLParser.REPORT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOURCE(self):
            return self.getToken(WFLParser.SOURCE, 0)

        def IS(self):
            return self.getToken(WFLParser.IS, 0)

        def JOBSUMMARY(self):
            return self.getToken(WFLParser.JOBSUMMARY, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_sourceComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceComponent" ):
                listener.enterSourceComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceComponent" ):
                listener.exitSourceComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceComponent" ):
                return visitor.visitSourceComponent(self)
            else:
                return visitor.visitChildren(self)




    def sourceComponent(self):

        localctx = WFLParser.SourceComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_sourceComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1315
            self.match(WFLParser.SOURCE)
            self.state = 1316
            self.match(WFLParser.IS)
            self.state = 1317
            _la = self._input.LA(1)
            if not(_la==351 or _la==446):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortByComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SORT(self):
            return self.getToken(WFLParser.SORT, 0)

        def BY(self):
            return self.getToken(WFLParser.BY, 0)

        def sortByParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.SortByParamContext)
            else:
                return self.getTypedRuleContext(WFLParser.SortByParamContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def ASCENDING(self):
            return self.getToken(WFLParser.ASCENDING, 0)

        def DESCENDING(self):
            return self.getToken(WFLParser.DESCENDING, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_sortByComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortByComponent" ):
                listener.enterSortByComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortByComponent" ):
                listener.exitSortByComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortByComponent" ):
                return visitor.visitSortByComponent(self)
            else:
                return visitor.visitChildren(self)




    def sortByComponent(self):

        localctx = WFLParser.SortByComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_sortByComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1319
            self.match(WFLParser.SORT)
            self.state = 1320
            self.match(WFLParser.BY)
            self.state = 1321
            self.sortByParam()
            self.state = 1326
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1322
                self.match(WFLParser.COMMA)
                self.state = 1323
                self.sortByParam()
                self.state = 1328
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1330
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==233 or _la==234:
                self.state = 1329
                _la = self._input.LA(1)
                if not(_la==233 or _la==234):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortByParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def USERCODE(self):
            return self.getToken(WFLParser.USERCODE, 0)

        def STARTTIME(self):
            return self.getToken(WFLParser.STARTTIME, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_sortByParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortByParam" ):
                listener.enterSortByParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortByParam" ):
                listener.exitSortByParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortByParam" ):
                return visitor.visitSortByParam(self)
            else:
                return visitor.visitChildren(self)




    def sortByParam(self):

        localctx = WFLParser.SortByParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_sortByParam)
        try:
            self.state = 1336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1332
                self.taskAttribute()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1333
                self.match(WFLParser.USERCODE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1334
                self.match(WFLParser.STARTTIME)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1335
                self.match(WFLParser.Identifier)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(WFLParser.BREAK, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def breakOnParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.BreakOnParamContext)
            else:
                return self.getTypedRuleContext(WFLParser.BreakOnParamContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def MINUS(self):
            return self.getToken(WFLParser.MINUS, 0)

        def totalling(self):
            return self.getTypedRuleContext(WFLParser.TotallingContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_breakComponent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakComponent" ):
                listener.enterBreakComponent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakComponent" ):
                listener.exitBreakComponent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakComponent" ):
                return visitor.visitBreakComponent(self)
            else:
                return visitor.visitChildren(self)




    def breakComponent(self):

        localctx = WFLParser.BreakComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_breakComponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1338
            self.match(WFLParser.BREAK)
            self.state = 1339
            self.match(WFLParser.ON)
            self.state = 1340
            self.breakOnParam()
            self.state = 1345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1341
                self.match(WFLParser.COMMA)
                self.state = 1342
                self.breakOnParam()
                self.state = 1347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 1348
                self.match(WFLParser.MINUS)


            self.state = 1352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==60:
                self.state = 1351
                self.totalling()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakOnParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def USERCODE(self):
            return self.getToken(WFLParser.USERCODE, 0)

        def TYPE(self):
            return self.getToken(WFLParser.TYPE, 0)

        def ACCESSCODE(self):
            return self.getToken(WFLParser.ACCESSCODE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_breakOnParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakOnParam" ):
                listener.enterBreakOnParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakOnParam" ):
                listener.exitBreakOnParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakOnParam" ):
                return visitor.visitBreakOnParam(self)
            else:
                return visitor.visitChildren(self)




    def breakOnParam(self):

        localctx = WFLParser.BreakOnParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_breakOnParam)
        try:
            self.state = 1359
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1354
                self.taskAttribute()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1355
                self.match(WFLParser.USERCODE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1356
                self.match(WFLParser.TYPE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1357
                self.match(WFLParser.ACCESSCODE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1358
                self.match(WFLParser.Identifier)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TotallingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOTALING(self):
            return self.getToken(WFLParser.TOTALING, 0)

        def totallingParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TotallingParamContext)
            else:
                return self.getTypedRuleContext(WFLParser.TotallingParamContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_totalling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotalling" ):
                listener.enterTotalling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotalling" ):
                listener.exitTotalling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotalling" ):
                return visitor.visitTotalling(self)
            else:
                return visitor.visitChildren(self)




    def totalling(self):

        localctx = WFLParser.TotallingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_totalling)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1361
            self.match(WFLParser.TOTALING)
            self.state = 1362
            self.totallingParam()
            self.state = 1367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1363
                self.match(WFLParser.COMMA)
                self.state = 1364
                self.totallingParam()
                self.state = 1369
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TotallingParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSEDTIME(self):
            return self.getToken(WFLParser.ELAPSEDTIME, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_totallingParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotallingParam" ):
                listener.enterTotallingParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotallingParam" ):
                listener.exitTotallingParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotallingParam" ):
                return visitor.visitTotallingParam(self)
            else:
                return visitor.visitChildren(self)




    def totallingParam(self):

        localctx = WFLParser.TotallingParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_totallingParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1370
            _la = self._input.LA(1)
            if not(_la==364 or _la==446):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE(self):
            return self.getToken(WFLParser.DATABASE, 0)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def otherDatabaseClauseInput(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.OtherDatabaseClauseInputContext)
            else:
                return self.getTypedRuleContext(WFLParser.OtherDatabaseClauseInputContext,i)


        def databaseMalnipulationOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DatabaseMalnipulationOptionsContext)
            else:
                return self.getTypedRuleContext(WFLParser.DatabaseMalnipulationOptionsContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_databaseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseClause" ):
                listener.enterDatabaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseClause" ):
                listener.exitDatabaseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseClause" ):
                return visitor.visitDatabaseClause(self)
            else:
                return visitor.visitChildren(self)




    def databaseClause(self):

        localctx = WFLParser.DatabaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_databaseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1372
            self.match(WFLParser.DATABASE)
            self.state = 1373
            self.match(WFLParser.COLON)
            self.state = 1374
            self.match(WFLParser.Identifier)
            self.state = 1378
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1375
                    self.otherDatabaseClauseInput() 
                self.state = 1380
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

            self.state = 1384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==75 or _la==446:
                self.state = 1381
                self.databaseMalnipulationOptions()
                self.state = 1386
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1388
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 1387
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseMalnipulationOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE(self):
            return self.getToken(WFLParser.UPDATE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_databaseMalnipulationOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseMalnipulationOptions" ):
                listener.enterDatabaseMalnipulationOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseMalnipulationOptions" ):
                listener.exitDatabaseMalnipulationOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseMalnipulationOptions" ):
                return visitor.visitDatabaseMalnipulationOptions(self)
            else:
                return visitor.visitChildren(self)




    def databaseMalnipulationOptions(self):

        localctx = WFLParser.DatabaseMalnipulationOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_databaseMalnipulationOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1390
            _la = self._input.LA(1)
            if not(_la==75 or _la==446):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherDatabaseClauseInputContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_otherDatabaseClauseInput

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOtherDatabaseClauseInput" ):
                listener.enterOtherDatabaseClauseInput(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOtherDatabaseClauseInput" ):
                listener.exitOtherDatabaseClauseInput(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOtherDatabaseClauseInput" ):
                return visitor.visitOtherDatabaseClauseInput(self)
            else:
                return visitor.visitChildren(self)




    def otherDatabaseClauseInput(self):

        localctx = WFLParser.OtherDatabaseClauseInputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_otherDatabaseClauseInput)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1392
            self.match(WFLParser.Identifier)
            self.state = 1393
            self.match(WFLParser.COLON)
            self.state = 1394
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datasetDbDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatasetDbDeclarationContext,0)


        def datasetDatasetDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatasetDatasetDeclarationContext,0)


        def datasetFileDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatasetFileDeclarationContext,0)


        def datasetRecordDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatasetRecordDeclarationContext,0)


        def datasetSourceDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatasetSourceDeclarationContext,0)


        def datasetLoadDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DatasetLoadDeclarationContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_datasetClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetClause" ):
                listener.enterDatasetClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetClause" ):
                listener.exitDatasetClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetClause" ):
                return visitor.visitDatasetClause(self)
            else:
                return visitor.visitChildren(self)




    def datasetClause(self):

        localctx = WFLParser.DatasetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_datasetClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1396
            self.datasetDbDeclaration()
            self.state = 1397
            self.datasetDatasetDeclaration()
            self.state = 1398
            self.datasetFileDeclaration()
            self.state = 1399
            self.datasetRecordDeclaration()
            self.state = 1400
            self.datasetSourceDeclaration()
            self.state = 1401
            self.datasetLoadDeclaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetDbDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DB(self):
            return self.getToken(WFLParser.DB, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_datasetDbDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetDbDeclaration" ):
                listener.enterDatasetDbDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetDbDeclaration" ):
                listener.exitDatasetDbDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetDbDeclaration" ):
                return visitor.visitDatasetDbDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def datasetDbDeclaration(self):

        localctx = WFLParser.DatasetDbDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_datasetDbDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1403
            self.match(WFLParser.DB)
            self.state = 1404
            self.match(WFLParser.Identifier)
            self.state = 1405
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetDatasetDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATASET(self):
            return self.getToken(WFLParser.DATASET, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_datasetDatasetDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetDatasetDeclaration" ):
                listener.enterDatasetDatasetDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetDatasetDeclaration" ):
                listener.exitDatasetDatasetDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetDatasetDeclaration" ):
                return visitor.visitDatasetDatasetDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def datasetDatasetDeclaration(self):

        localctx = WFLParser.DatasetDatasetDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_datasetDatasetDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1407
            self.match(WFLParser.DATASET)
            self.state = 1408
            self.match(WFLParser.Identifier)
            self.state = 1409
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetFileDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def fileAttribute(self):
            return self.getTypedRuleContext(WFLParser.FileAttributeContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_datasetFileDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetFileDeclaration" ):
                listener.enterDatasetFileDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetFileDeclaration" ):
                listener.exitDatasetFileDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetFileDeclaration" ):
                return visitor.visitDatasetFileDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def datasetFileDeclaration(self):

        localctx = WFLParser.DatasetFileDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_datasetFileDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1411
            self.match(WFLParser.FILE)
            self.state = 1412
            self.match(WFLParser.Identifier)
            self.state = 1413
            self.fileAttribute()
            self.state = 1414
            self.match(WFLParser.EQUAL)
            self.state = 1415
            self.filePath()
            self.state = 1418
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 1416
                self.match(WFLParser.ON)
                self.state = 1417
                self.storageUnit()


            self.state = 1420
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetRecordDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self):
            return self.getToken(WFLParser.RECORD, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_datasetRecordDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetRecordDeclaration" ):
                listener.enterDatasetRecordDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetRecordDeclaration" ):
                listener.exitDatasetRecordDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetRecordDeclaration" ):
                return visitor.visitDatasetRecordDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def datasetRecordDeclaration(self):

        localctx = WFLParser.DatasetRecordDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_datasetRecordDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1422
            self.match(WFLParser.RECORD)
            self.state = 1423
            self.match(WFLParser.Identifier)
            self.state = 1424
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetSourceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOURCE(self):
            return self.getToken(WFLParser.SOURCE, 0)

        def DATASET(self):
            return self.getToken(WFLParser.DATASET, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_datasetSourceDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetSourceDeclaration" ):
                listener.enterDatasetSourceDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetSourceDeclaration" ):
                listener.exitDatasetSourceDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetSourceDeclaration" ):
                return visitor.visitDatasetSourceDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def datasetSourceDeclaration(self):

        localctx = WFLParser.DatasetSourceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_datasetSourceDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1426
            self.match(WFLParser.SOURCE)
            self.state = 1427
            self.match(WFLParser.DATASET)
            self.state = 1428
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatasetLoadDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def LOAD(self):
            return self.getToken(WFLParser.LOAD, 0)

        def DUMP(self):
            return self.getToken(WFLParser.DUMP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_datasetLoadDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatasetLoadDeclaration" ):
                listener.enterDatasetLoadDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatasetLoadDeclaration" ):
                listener.exitDatasetLoadDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatasetLoadDeclaration" ):
                return visitor.visitDatasetLoadDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def datasetLoadDeclaration(self):

        localctx = WFLParser.DatasetLoadDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_datasetLoadDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1430
            _la = self._input.LA(1)
            if not(_la==63 or _la==92):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1431
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataUserAndAccessCodeListClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER(self):
            return self.getToken(WFLParser.USER, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def ACCESSCODELIST(self):
            return self.getToken(WFLParser.ACCESSCODELIST, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def PLUS(self):
            return self.getToken(WFLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(WFLParser.MINUS, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_dataUserAndAccessCodeListClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataUserAndAccessCodeListClause" ):
                listener.enterDataUserAndAccessCodeListClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataUserAndAccessCodeListClause" ):
                listener.exitDataUserAndAccessCodeListClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataUserAndAccessCodeListClause" ):
                return visitor.visitDataUserAndAccessCodeListClause(self)
            else:
                return visitor.visitChildren(self)




    def dataUserAndAccessCodeListClause(self):

        localctx = WFLParser.DataUserAndAccessCodeListClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_dataUserAndAccessCodeListClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1433
            self.match(WFLParser.USER)
            self.state = 1434
            self.match(WFLParser.EQUAL)
            self.state = 1437
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.state = 1435
                self.match(WFLParser.Identifier)
                pass
            elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                self.state = 1436
                self.charDataKeyword()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1439
            self.match(WFLParser.ACCESSCODELIST)
            self.state = 1440
            _la = self._input.LA(1)
            if not(_la==25 or _la==26):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1441
            self.filePath()
            self.state = 1442
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetMergeLabelsintableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def SET(self):
            return self.getToken(WFLParser.SET, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def LABELSINTABLE(self):
            return self.getToken(WFLParser.LABELSINTABLE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_setMergeLabelsintable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetMergeLabelsintable" ):
                listener.enterSetMergeLabelsintable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetMergeLabelsintable" ):
                listener.exitSetMergeLabelsintable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetMergeLabelsintable" ):
                return visitor.visitSetMergeLabelsintable(self)
            else:
                return visitor.visitChildren(self)




    def setMergeLabelsintable(self):

        localctx = WFLParser.SetMergeLabelsintableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_setMergeLabelsintable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1444
            self.match(WFLParser.DOLLAR)
            self.state = 1445
            self.match(WFLParser.SET)
            self.state = 1446
            self.match(WFLParser.Identifier)
            self.state = 1447
            self.match(WFLParser.LABELSINTABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetMergeResetListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def SET(self):
            return self.getToken(WFLParser.SET, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def RESET(self):
            return self.getToken(WFLParser.RESET, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_setMergeResetList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetMergeResetList" ):
                listener.enterSetMergeResetList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetMergeResetList" ):
                listener.exitSetMergeResetList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetMergeResetList" ):
                return visitor.visitSetMergeResetList(self)
            else:
                return visitor.visitChildren(self)




    def setMergeResetList(self):

        localctx = WFLParser.SetMergeResetListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_setMergeResetList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1449
            self.match(WFLParser.DOLLAR)
            self.state = 1450
            self.match(WFLParser.SET)
            self.state = 1451
            self.match(WFLParser.Identifier)
            self.state = 1452
            self.match(WFLParser.RESET)
            self.state = 1453
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE(self):
            return self.getToken(WFLParser.UPDATE, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_updateClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdateClause" ):
                listener.enterUpdateClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdateClause" ):
                listener.exitUpdateClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateClause" ):
                return visitor.visitUpdateClause(self)
            else:
                return visitor.visitChildren(self)




    def updateClause(self):

        localctx = WFLParser.UpdateClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_updateClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1455
            self.match(WFLParser.UPDATE)
            self.state = 1456
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResetZipClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def RESET(self):
            return self.getToken(WFLParser.RESET, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_resetZipClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResetZipClause" ):
                listener.enterResetZipClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResetZipClause" ):
                listener.exitResetZipClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetZipClause" ):
                return visitor.visitResetZipClause(self)
            else:
                return visitor.visitChildren(self)




    def resetZipClause(self):

        localctx = WFLParser.ResetZipClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_resetZipClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1458
            self.match(WFLParser.DOLLAR)
            self.state = 1459
            self.match(WFLParser.RESET)
            self.state = 1460
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GlobalAndResourseSettingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def globalConfig(self):
            return self.getTypedRuleContext(WFLParser.GlobalConfigContext,0)


        def internalFileConfig(self):
            return self.getTypedRuleContext(WFLParser.InternalFileConfigContext,0)


        def allowedCoreConfig(self):
            return self.getTypedRuleContext(WFLParser.AllowedCoreConfigContext,0)


        def taskAttributeAssignment(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,0)


        def nopostdumpConfig(self):
            return self.getTypedRuleContext(WFLParser.NopostdumpConfigContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_globalAndResourseSetting

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGlobalAndResourseSetting" ):
                listener.enterGlobalAndResourseSetting(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGlobalAndResourseSetting" ):
                listener.exitGlobalAndResourseSetting(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGlobalAndResourseSetting" ):
                return visitor.visitGlobalAndResourseSetting(self)
            else:
                return visitor.visitChildren(self)




    def globalAndResourseSetting(self):

        localctx = WFLParser.GlobalAndResourseSettingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_globalAndResourseSetting)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1467
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [101]:
                self.state = 1462
                self.globalConfig()
                pass
            elif token in [102]:
                self.state = 1463
                self.internalFileConfig()
                pass
            elif token in [103]:
                self.state = 1464
                self.allowedCoreConfig()
                pass
            elif token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442]:
                self.state = 1465
                self.taskAttributeAssignment()
                pass
            elif token in [76]:
                self.state = 1466
                self.nopostdumpConfig()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1469
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NopostdumpConfigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOPOSTDUMP(self):
            return self.getToken(WFLParser.NOPOSTDUMP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_nopostdumpConfig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNopostdumpConfig" ):
                listener.enterNopostdumpConfig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNopostdumpConfig" ):
                listener.exitNopostdumpConfig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNopostdumpConfig" ):
                return visitor.visitNopostdumpConfig(self)
            else:
                return visitor.visitChildren(self)




    def nopostdumpConfig(self):

        localctx = WFLParser.NopostdumpConfigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_nopostdumpConfig)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1471
            self.match(WFLParser.NOPOSTDUMP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GlobalConfigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GLOBAL(self):
            return self.getToken(WFLParser.GLOBAL, 0)

        def ONLINE(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.ONLINE)
            else:
                return self.getToken(WFLParser.ONLINE, i)

        def OFFLINE(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.OFFLINE)
            else:
                return self.getToken(WFLParser.OFFLINE, i)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_globalConfig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGlobalConfig" ):
                listener.enterGlobalConfig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGlobalConfig" ):
                listener.exitGlobalConfig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGlobalConfig" ):
                return visitor.visitGlobalConfig(self)
            else:
                return visitor.visitChildren(self)




    def globalConfig(self):

        localctx = WFLParser.GlobalConfigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_globalConfig)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1473
            self.match(WFLParser.GLOBAL)
            self.state = 1474
            _la = self._input.LA(1)
            if not(_la==93 or _la==94 or _la==446):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1477
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 1475
                self.match(WFLParser.SEMICOLON)
                self.state = 1476
                _la = self._input.LA(1)
                if not(_la==93 or _la==94):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InternalFileConfigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERNAL(self):
            return self.getToken(WFLParser.INTERNAL, 0)

        def FILES(self):
            return self.getToken(WFLParser.FILES, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def FAMILYNAME(self):
            return self.getToken(WFLParser.FAMILYNAME, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_internalFileConfig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInternalFileConfig" ):
                listener.enterInternalFileConfig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInternalFileConfig" ):
                listener.exitInternalFileConfig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInternalFileConfig" ):
                return visitor.visitInternalFileConfig(self)
            else:
                return visitor.visitChildren(self)




    def internalFileConfig(self):

        localctx = WFLParser.InternalFileConfigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_internalFileConfig)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1479
            self.match(WFLParser.INTERNAL)
            self.state = 1480
            self.match(WFLParser.FILES)
            self.state = 1481
            self.match(WFLParser.LP)
            self.state = 1482
            self.match(WFLParser.FAMILYNAME)
            self.state = 1483
            self.match(WFLParser.EQUAL)
            self.state = 1484
            self.match(WFLParser.Identifier)
            self.state = 1485
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllowedCoreConfigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLOWEDCORE(self):
            return self.getToken(WFLParser.ALLOWEDCORE, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_allowedCoreConfig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllowedCoreConfig" ):
                listener.enterAllowedCoreConfig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllowedCoreConfig" ):
                listener.exitAllowedCoreConfig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAllowedCoreConfig" ):
                return visitor.visitAllowedCoreConfig(self)
            else:
                return visitor.visitChildren(self)




    def allowedCoreConfig(self):

        localctx = WFLParser.AllowedCoreConfigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_allowedCoreConfig)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1487
            self.match(WFLParser.ALLOWEDCORE)
            self.state = 1488
            self.match(WFLParser.EQUAL)
            self.state = 1489
            self.match(WFLParser.Num)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetListZipClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def SET(self):
            return self.getToken(WFLParser.SET, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def getRuleIndex(self):
            return WFLParser.RULE_setListZipClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetListZipClause" ):
                listener.enterSetListZipClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetListZipClause" ):
                listener.exitSetListZipClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetListZipClause" ):
                return visitor.visitSetListZipClause(self)
            else:
                return visitor.visitChildren(self)




    def setListZipClause(self):

        localctx = WFLParser.SetListZipClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_setListZipClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1491
            self.match(WFLParser.DOLLAR)
            self.state = 1492
            self.match(WFLParser.SET)
            self.state = 1493
            self.match(WFLParser.Identifier)
            self.state = 1494
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetListClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def SET(self):
            return self.getToken(WFLParser.SET, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_setListClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetListClause" ):
                listener.enterSetListClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetListClause" ):
                listener.exitSetListClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetListClause" ):
                return visitor.visitSetListClause(self)
            else:
                return visitor.visitChildren(self)




    def setListClause(self):

        localctx = WFLParser.SetListClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_setListClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1496
            self.match(WFLParser.DOLLAR)
            self.state = 1497
            self.match(WFLParser.SET)
            self.state = 1498
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenerateBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERATE(self):
            return self.getToken(WFLParser.GENERATE, 0)

        def generateParameters(self):
            return self.getTypedRuleContext(WFLParser.GenerateParametersContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_generateBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerateBlock" ):
                listener.enterGenerateBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerateBlock" ):
                listener.exitGenerateBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerateBlock" ):
                return visitor.visitGenerateBlock(self)
            else:
                return visitor.visitChildren(self)




    def generateBlock(self):

        localctx = WFLParser.GenerateBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_generateBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1500
            self.match(WFLParser.GENERATE)
            self.state = 1501
            self.generateParameters()
            self.state = 1502
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenerateParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generateNonCopyParameters(self):
            return self.getTypedRuleContext(WFLParser.GenerateNonCopyParametersContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def generateCopyParameters(self):
            return self.getTypedRuleContext(WFLParser.GenerateCopyParametersContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_generateParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerateParameters" ):
                listener.enterGenerateParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerateParameters" ):
                listener.exitGenerateParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerateParameters" ):
                return visitor.visitGenerateParameters(self)
            else:
                return visitor.visitChildren(self)




    def generateParameters(self):

        localctx = WFLParser.GenerateParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_generateParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1504
            self.generateNonCopyParameters()
            self.state = 1507
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                self.state = 1505
                self.match(WFLParser.SEMICOLON)
                self.state = 1506
                self.generateCopyParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenerateNonCopyParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generateNonCopyParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.GenerateNonCopyParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.GenerateNonCopyParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_generateNonCopyParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerateNonCopyParameters" ):
                listener.enterGenerateNonCopyParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerateNonCopyParameters" ):
                listener.exitGenerateNonCopyParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerateNonCopyParameters" ):
                return visitor.visitGenerateNonCopyParameters(self)
            else:
                return visitor.visitChildren(self)




    def generateNonCopyParameters(self):

        localctx = WFLParser.GenerateNonCopyParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_generateNonCopyParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1509
            self.generateNonCopyParameter()
            self.state = 1514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1510
                self.match(WFLParser.COMMA)
                self.state = 1511
                self.generateNonCopyParameter()
                self.state = 1516
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenerateNonCopyParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def orderByClause(self):
            return self.getTypedRuleContext(WFLParser.OrderByClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_generateNonCopyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerateNonCopyParameter" ):
                listener.enterGenerateNonCopyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerateNonCopyParameter" ):
                listener.exitGenerateNonCopyParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerateNonCopyParameter" ):
                return visitor.visitGenerateNonCopyParameter(self)
            else:
                return visitor.visitChildren(self)




    def generateNonCopyParameter(self):

        localctx = WFLParser.GenerateNonCopyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_generateNonCopyParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1517
            self.match(WFLParser.Identifier)
            self.state = 1519
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 1518
                self.orderByClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenerateCopyParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def generateCopyParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.GenerateCopyParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.GenerateCopyParameterContext,i)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def COPY(self):
            return self.getToken(WFLParser.COPY, 0)

        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_generateCopyParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerateCopyParameters" ):
                listener.enterGenerateCopyParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerateCopyParameters" ):
                listener.exitGenerateCopyParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerateCopyParameters" ):
                return visitor.visitGenerateCopyParameters(self)
            else:
                return visitor.visitChildren(self)




    def generateCopyParameters(self):

        localctx = WFLParser.GenerateCopyParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_generateCopyParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1521
            self.generateCopyParameter()
            self.state = 1526
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1522
                self.match(WFLParser.COMMA)
                self.state = 1523
                self.generateCopyParameter()
                self.state = 1528
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1529
            self.match(WFLParser.LP)
            self.state = 1530
            self.match(WFLParser.COPY)
            self.state = 1531
            self.match(WFLParser.TO)
            self.state = 1532
            self.storageUnit()
            self.state = 1533
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenerateCopyParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def orderByClause(self):
            return self.getTypedRuleContext(WFLParser.OrderByClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_generateCopyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenerateCopyParameter" ):
                listener.enterGenerateCopyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenerateCopyParameter" ):
                listener.exitGenerateCopyParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenerateCopyParameter" ):
                return visitor.visitGenerateCopyParameter(self)
            else:
                return visitor.visitChildren(self)




    def generateCopyParameter(self):

        localctx = WFLParser.GenerateCopyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_generateCopyParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1535
            self.match(WFLParser.Identifier)
            self.state = 1537
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 1536
                self.orderByClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderByClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(WFLParser.ORDER, 0)

        def BY(self):
            return self.getToken(WFLParser.BY, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_orderByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderByClause" ):
                listener.enterOrderByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderByClause" ):
                listener.exitOrderByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderByClause" ):
                return visitor.visitOrderByClause(self)
            else:
                return visitor.visitChildren(self)




    def orderByClause(self):

        localctx = WFLParser.OrderByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_orderByClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1539
            self.match(WFLParser.ORDER)
            self.state = 1540
            self.match(WFLParser.BY)
            self.state = 1541
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DB(self):
            return self.getToken(WFLParser.DB, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def OPTIONS(self):
            return self.getToken(WFLParser.OPTIONS, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def databaseOptions(self):
            return self.getTypedRuleContext(WFLParser.DatabaseOptionsContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def OFFLINE(self):
            return self.getToken(WFLParser.OFFLINE, 0)

        def ONLINE(self):
            return self.getToken(WFLParser.ONLINE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_databaseDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseDeclaration" ):
                listener.enterDatabaseDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseDeclaration" ):
                listener.exitDatabaseDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseDeclaration" ):
                return visitor.visitDatabaseDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def databaseDeclaration(self):

        localctx = WFLParser.DatabaseDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_databaseDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1543
            self.match(WFLParser.DB)
            self.state = 1544
            self.match(WFLParser.EQUAL)
            self.state = 1545
            self.filePath()
            self.state = 1548
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 1546
                self.match(WFLParser.ON)
                self.state = 1547
                self.storageUnit()


            self.state = 1555
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==91:
                self.state = 1550
                self.match(WFLParser.OPTIONS)
                self.state = 1551
                self.match(WFLParser.LP)
                self.state = 1552
                self.databaseOptions()
                self.state = 1553
                self.match(WFLParser.RP)


            self.state = 1558
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.state = 1557
                _la = self._input.LA(1)
                if not(_la==93 or _la==94):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def databaseOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DatabaseOptionContext)
            else:
                return self.getTypedRuleContext(WFLParser.DatabaseOptionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_databaseOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseOptions" ):
                listener.enterDatabaseOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseOptions" ):
                listener.exitDatabaseOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseOptions" ):
                return visitor.visitDatabaseOptions(self)
            else:
                return visitor.visitChildren(self)




    def databaseOptions(self):

        localctx = WFLParser.DatabaseOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_databaseOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1560
            self.databaseOption()
            self.state = 1565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1561
                self.match(WFLParser.COMMA)
                self.state = 1562
                self.databaseOption()
                self.state = 1567
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def addOption(self):
            return self.getTypedRuleContext(WFLParser.AddOptionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_databaseOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseOption" ):
                listener.enterDatabaseOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseOption" ):
                listener.exitDatabaseOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseOption" ):
                return visitor.visitDatabaseOption(self)
            else:
                return visitor.visitChildren(self)




    def databaseOption(self):

        localctx = WFLParser.DatabaseOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_databaseOption)
        self._la = 0 # Token type
        try:
            self.state = 1573
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1568
                self.match(WFLParser.Identifier)
                self.state = 1569
                self.match(WFLParser.EQUAL)
                self.state = 1570
                _la = self._input.LA(1)
                if not(((((_la - 446)) & ~0x3f) == 0 and ((1 << (_la - 446)) & 11) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1571
                self.match(WFLParser.Identifier)
                self.state = 1572
                self.addOption()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DumpDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DUMP(self):
            return self.getToken(WFLParser.DUMP, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def dumpParameters(self):
            return self.getTypedRuleContext(WFLParser.DumpParametersContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def ONLINE(self):
            return self.getToken(WFLParser.ONLINE, 0)

        def OFFLINE(self):
            return self.getToken(WFLParser.OFFLINE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dumpDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDumpDeclaration" ):
                listener.enterDumpDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDumpDeclaration" ):
                listener.exitDumpDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDumpDeclaration" ):
                return visitor.visitDumpDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def dumpDeclaration(self):

        localctx = WFLParser.DumpDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_dumpDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1576
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==93 or _la==94:
                self.state = 1575
                _la = self._input.LA(1)
                if not(_la==93 or _la==94):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1578
            self.match(WFLParser.DUMP)
            self.state = 1579
            self.match(WFLParser.EQUAL)
            self.state = 1580
            self.match(WFLParser.TO)
            self.state = 1581
            self.filePath()
            self.state = 1584
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 1582
                self.match(WFLParser.ON)
                self.state = 1583
                self.storageUnit()


            self.state = 1590
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 1586
                self.match(WFLParser.LP)
                self.state = 1587
                self.dumpParameters()
                self.state = 1588
                self.match(WFLParser.RP)


            self.state = 1593
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 1592
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DumpParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dumpParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DumpParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.DumpParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_dumpParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDumpParameters" ):
                listener.enterDumpParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDumpParameters" ):
                listener.exitDumpParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDumpParameters" ):
                return visitor.visitDumpParameters(self)
            else:
                return visitor.visitChildren(self)




    def dumpParameters(self):

        localctx = WFLParser.DumpParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_dumpParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1595
            self.dumpParameter()
            self.state = 1600
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1596
                self.match(WFLParser.COMMA)
                self.state = 1597
                self.dumpParameter()
                self.state = 1602
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DumpParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def fileAttribute(self):
            return self.getTypedRuleContext(WFLParser.FileAttributeContext,0)


        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LITERAL)
            else:
                return self.getToken(WFLParser.LITERAL, i)

        def NumCombineWithChar(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.NumCombineWithChar)
            else:
                return self.getToken(WFLParser.NumCombineWithChar, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_dumpParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDumpParameter" ):
                listener.enterDumpParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDumpParameter" ):
                listener.exitDumpParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDumpParameter" ):
                return visitor.visitDumpParameter(self)
            else:
                return visitor.visitChildren(self)




    def dumpParameter(self):

        localctx = WFLParser.DumpParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_dumpParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1606
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
            if la_ == 1:
                self.state = 1603
                self.fileAttribute()
                pass

            elif la_ == 2:
                self.state = 1604
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 3:
                self.state = 1605
                self.charDataKeyword()
                pass


            self.state = 1611
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 1608
                self.match(WFLParser.LP)
                self.state = 1609
                self.match(WFLParser.Num)
                self.state = 1610
                self.match(WFLParser.RP)


            self.state = 1613
            self.match(WFLParser.EQUAL)

            self.state = 1614
            _la = self._input.LA(1)
            if not(((((_la - 446)) & ~0x3f) == 0 and ((1 << (_la - 446)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1619
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,112,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1615
                    self.match(WFLParser.COMMA)
                    self.state = 1616
                    _la = self._input.LA(1)
                    if not(((((_la - 446)) & ~0x3f) == 0 and ((1 << (_la - 446)) & 15) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1621
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,112,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(WFLParser.DOLLAR, 0)

        def INCLUDE(self):
            return self.getToken(WFLParser.INCLUDE, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_includeDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclaration" ):
                listener.enterIncludeDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclaration" ):
                listener.exitIncludeDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclaration" ):
                return visitor.visitIncludeDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclaration(self):

        localctx = WFLParser.IncludeDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_includeDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1622
            self.match(WFLParser.DOLLAR)
            self.state = 1623
            self.match(WFLParser.INCLUDE)
            self.state = 1624
            self.filePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TASK(self):
            return self.getToken(WFLParser.TASK, 0)

        def taskIdentifierDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskIdentifierDeclarationContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskIdentifierDeclarationContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_taskDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskDeclaration" ):
                listener.enterTaskDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskDeclaration" ):
                listener.exitTaskDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskDeclaration" ):
                return visitor.visitTaskDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def taskDeclaration(self):

        localctx = WFLParser.TaskDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_taskDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1626
            self.match(WFLParser.TASK)
            self.state = 1627
            self.taskIdentifierDeclaration()
            self.state = 1632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1628
                self.match(WFLParser.COMMA)
                self.state = 1629
                self.taskIdentifierDeclaration()
                self.state = 1634
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1635
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskIdentifierDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def taskIdentifierAssigments(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierAssigmentsContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def myselfTaskAssignment(self):
            return self.getTypedRuleContext(WFLParser.MyselfTaskAssignmentContext,0)


        def myjobTaskAssignment(self):
            return self.getTypedRuleContext(WFLParser.MyjobTaskAssignmentContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_taskIdentifierDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskIdentifierDeclaration" ):
                listener.enterTaskIdentifierDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskIdentifierDeclaration" ):
                listener.exitTaskIdentifierDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskIdentifierDeclaration" ):
                return visitor.visitTaskIdentifierDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def taskIdentifierDeclaration(self):

        localctx = WFLParser.TaskIdentifierDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_taskIdentifierDeclaration)
        self._la = 0 # Token type
        try:
            self.state = 1646
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1637
                self.taskIdentifier()
                self.state = 1642
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==12:
                    self.state = 1638
                    self.match(WFLParser.LP)
                    self.state = 1639
                    self.taskIdentifierAssigments()
                    self.state = 1640
                    self.match(WFLParser.RP)


                pass
            elif token in [396]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1644
                self.myselfTaskAssignment()
                pass
            elif token in [395]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1645
                self.myjobTaskAssignment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MyselfTaskAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MYSELF(self):
            return self.getToken(WFLParser.MYSELF, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def FAMILY(self):
            return self.getToken(WFLParser.FAMILY, 0)

        def reservedKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ReservedKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,i)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def ONLY(self):
            return self.getToken(WFLParser.ONLY, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_myselfTaskAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMyselfTaskAssignment" ):
                listener.enterMyselfTaskAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMyselfTaskAssignment" ):
                listener.exitMyselfTaskAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMyselfTaskAssignment" ):
                return visitor.visitMyselfTaskAssignment(self)
            else:
                return visitor.visitChildren(self)




    def myselfTaskAssignment(self):

        localctx = WFLParser.MyselfTaskAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_myselfTaskAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1648
            self.match(WFLParser.MYSELF)
            self.state = 1649
            self.match(WFLParser.LP)
            self.state = 1650
            self.match(WFLParser.FAMILY)
            self.state = 1651
            self.reservedKeyword()
            self.state = 1652
            self.match(WFLParser.EQUAL)
            self.state = 1655
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [201, 209, 211, 219]:
                self.state = 1653
                self.reservedKeyword()
                pass
            elif token in [446]:
                self.state = 1654
                self.storageUnit()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1658
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==394:
                self.state = 1657
                self.match(WFLParser.ONLY)


            self.state = 1660
            self.match(WFLParser.RP)
            self.state = 1662
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                self.state = 1661
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MyjobTaskAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MYJOB(self):
            return self.getToken(WFLParser.MYJOB, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def JOBSUMMARY(self):
            return self.getToken(WFLParser.JOBSUMMARY, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def FAMILY(self):
            return self.getToken(WFLParser.FAMILY, 0)

        def reservedKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ReservedKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,i)


        def ACCESSCODE(self):
            return self.getToken(WFLParser.ACCESSCODE, 0)

        def JOBNUMBER(self):
            return self.getToken(WFLParser.JOBNUMBER, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def ONLY(self):
            return self.getToken(WFLParser.ONLY, 0)

        def OTHERWISE(self):
            return self.getToken(WFLParser.OTHERWISE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_myjobTaskAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMyjobTaskAssignment" ):
                listener.enterMyjobTaskAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMyjobTaskAssignment" ):
                listener.exitMyjobTaskAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMyjobTaskAssignment" ):
                return visitor.visitMyjobTaskAssignment(self)
            else:
                return visitor.visitChildren(self)




    def myjobTaskAssignment(self):

        localctx = WFLParser.MyjobTaskAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_myjobTaskAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1664
            self.match(WFLParser.MYJOB)
            self.state = 1665
            self.match(WFLParser.LP)
            self.state = 1686
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [192, 208, 334]:
                self.state = 1670
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [208]:
                    self.state = 1666
                    self.match(WFLParser.FAMILY)
                    self.state = 1667
                    self.reservedKeyword()
                    pass
                elif token in [192]:
                    self.state = 1668
                    self.match(WFLParser.ACCESSCODE)
                    pass
                elif token in [334]:
                    self.state = 1669
                    self.match(WFLParser.JOBNUMBER)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1672
                self.match(WFLParser.EQUAL)
                self.state = 1676
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                if la_ == 1:
                    self.state = 1673
                    self.reservedKeyword()
                    pass

                elif la_ == 2:
                    self.state = 1674
                    self.storageUnit()
                    pass

                elif la_ == 3:
                    self.state = 1675
                    self.filePath()
                    pass


                self.state = 1681
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [394]:
                    self.state = 1678
                    self.match(WFLParser.ONLY)
                    pass
                elif token in [218]:
                    self.state = 1679
                    self.match(WFLParser.OTHERWISE)
                    self.state = 1680
                    self.reservedKeyword()
                    pass
                elif token in [13]:
                    pass
                else:
                    pass
                pass
            elif token in [351]:
                self.state = 1683
                self.match(WFLParser.JOBSUMMARY)
                self.state = 1684
                self.match(WFLParser.EQUAL)
                self.state = 1685
                self.match(WFLParser.Identifier)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1688
            self.match(WFLParser.RP)
            self.state = 1690
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
            if la_ == 1:
                self.state = 1689
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_taskIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskIdentifier" ):
                listener.enterTaskIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskIdentifier" ):
                listener.exitTaskIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskIdentifier" ):
                return visitor.visitTaskIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def taskIdentifier(self):

        localctx = WFLParser.TaskIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_taskIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1692
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskIdentifierAssigmentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskIdentifierAssigment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskIdentifierAssigmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskIdentifierAssigmentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_taskIdentifierAssigments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskIdentifierAssigments" ):
                listener.enterTaskIdentifierAssigments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskIdentifierAssigments" ):
                listener.exitTaskIdentifierAssigments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskIdentifierAssigments" ):
                return visitor.visitTaskIdentifierAssigments(self)
            else:
                return visitor.visitChildren(self)




    def taskIdentifierAssigments(self):

        localctx = WFLParser.TaskIdentifierAssigmentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_taskIdentifierAssigments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1694
            self.taskIdentifierAssigment()
            self.state = 1699
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1695
                self.match(WFLParser.COMMA)
                self.state = 1696
                self.taskIdentifierAssigment()
                self.state = 1701
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskIdentifierAssigmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskAttributeAssignment(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,0)


        def fileEquation(self):
            return self.getTypedRuleContext(WFLParser.FileEquationContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_taskIdentifierAssigment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskIdentifierAssigment" ):
                listener.enterTaskIdentifierAssigment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskIdentifierAssigment" ):
                listener.exitTaskIdentifierAssigment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskIdentifierAssigment" ):
                return visitor.visitTaskIdentifierAssigment(self)
            else:
                return visitor.visitChildren(self)




    def taskIdentifierAssigment(self):

        localctx = WFLParser.TaskIdentifierAssigmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_taskIdentifierAssigment)
        try:
            self.state = 1704
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1702
                self.taskAttributeAssignment()
                pass
            elif token in [237]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1703
                self.fileEquation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileAttributeAssignmentContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_fileEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileEquation" ):
                listener.enterFileEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileEquation" ):
                listener.exitFileEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileEquation" ):
                return visitor.visitFileEquation(self)
            else:
                return visitor.visitChildren(self)




    def fileEquation(self):

        localctx = WFLParser.FileEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_fileEquation)
        self._la = 0 # Token type
        try:
            self.state = 1760
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1706
                self.match(WFLParser.FILE)
                self.state = 1710
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
                if la_ == 1:
                    self.state = 1707
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 2:
                    self.state = 1708
                    self.charDataKeyword()
                    pass

                elif la_ == 3:
                    self.state = 1709
                    self.filePath()
                    pass


                self.state = 1723
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
                if la_ == 1:
                    self.state = 1712
                    self.match(WFLParser.LP)
                    self.state = 1713
                    self.fileAttributeAssignment()
                    self.state = 1718
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==4:
                        self.state = 1714
                        self.match(WFLParser.COMMA)
                        self.state = 1715
                        self.fileAttributeAssignment()
                        self.state = 1720
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1721
                    self.match(WFLParser.RP)


                self.state = 1726
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 1725
                    self.match(WFLParser.SEMICOLON)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1728
                self.match(WFLParser.FILE)
                self.state = 1731
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 1729
                    self.match(WFLParser.Identifier)
                    pass
                elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                    self.state = 1730
                    self.charDataKeyword()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1733
                self.match(WFLParser.EQUAL)
                self.state = 1734
                self.filePath()
                self.state = 1737
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                if la_ == 1:
                    self.state = 1735
                    self.match(WFLParser.ON)
                    self.state = 1736
                    self.storageUnit()


                self.state = 1740
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
                if la_ == 1:
                    self.state = 1739
                    self.match(WFLParser.SEMICOLON)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1742
                self.match(WFLParser.FILE)
                self.state = 1745
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 1743
                    self.fileIdentifier()
                    pass
                elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                    self.state = 1744
                    self.charDataKeyword()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1747
                self.match(WFLParser.LP)
                self.state = 1748
                self.fileAttributeAssignment()
                self.state = 1753
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 1749
                    self.match(WFLParser.COMMA)
                    self.state = 1750
                    self.fileAttributeAssignment()
                    self.state = 1755
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1756
                self.match(WFLParser.RP)
                self.state = 1758
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
                if la_ == 1:
                    self.state = 1757
                    self.match(WFLParser.SEMICOLON)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileAttributeAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fileAttribute(self):
            return self.getTypedRuleContext(WFLParser.FileAttributeContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def fileAttributeValue(self):
            return self.getTypedRuleContext(WFLParser.FileAttributeValueContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_fileAttributeAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileAttributeAssignment" ):
                listener.enterFileAttributeAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileAttributeAssignment" ):
                listener.exitFileAttributeAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileAttributeAssignment" ):
                return visitor.visitFileAttributeAssignment(self)
            else:
                return visitor.visitChildren(self)




    def fileAttributeAssignment(self):

        localctx = WFLParser.FileAttributeAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_fileAttributeAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1762
            self.fileAttribute()
            self.state = 1765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 1763
                self.match(WFLParser.EQUAL)
                self.state = 1764
                self.fileAttributeValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.BooleanFileAttributeContext,0)


        def integerFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.IntegerFileAttributeContext,0)


        def stringFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.StringFileAttributeContext,0)


        def titleFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.TitleFileAttributeContext,0)


        def blockSizeFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.BlockSizeFileAttributeContext,0)


        def fileNameFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.FileNameFileAttributeContext,0)


        def longFileNameFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.LongFileNameFileAttributeContext,0)


        def longTitleFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.LongTitleFileAttributeContext,0)


        def mnemonicFileAttribute(self):
            return self.getTypedRuleContext(WFLParser.MnemonicFileAttributeContext,0)


        def deviceKindAssigment(self):
            return self.getTypedRuleContext(WFLParser.DeviceKindAssigmentContext,0)


        def serialNumberAssigment(self):
            return self.getTypedRuleContext(WFLParser.SerialNumberAssigmentContext,0)


        def LOCKEDFILE(self):
            return self.getToken(WFLParser.LOCKEDFILE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileAttribute" ):
                listener.enterFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileAttribute" ):
                listener.exitFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileAttribute" ):
                return visitor.visitFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def fileAttribute(self):

        localctx = WFLParser.FileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_fileAttribute)
        try:
            self.state = 1779
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1767
                self.booleanFileAttribute()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1768
                self.integerFileAttribute()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1769
                self.stringFileAttribute()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1770
                self.titleFileAttribute()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1771
                self.blockSizeFileAttribute()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1772
                self.fileNameFileAttribute()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1773
                self.longFileNameFileAttribute()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1774
                self.longTitleFileAttribute()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1775
                self.mnemonicFileAttribute()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1776
                self.deviceKindAssigment()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1777
                self.serialNumberAssigment()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1778
                self.match(WFLParser.LOCKEDFILE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEPENDENTSPECS(self):
            return self.getToken(WFLParser.DEPENDENTSPECS, 0)

        def OPEN(self):
            return self.getToken(WFLParser.OPEN, 0)

        def NEWFILE(self):
            return self.getToken(WFLParser.NEWFILE, 0)

        def EXCLUSIVE(self):
            return self.getToken(WFLParser.EXCLUSIVE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFileAttribute" ):
                listener.enterBooleanFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFileAttribute" ):
                listener.exitBooleanFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFileAttribute" ):
                return visitor.visitBooleanFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def booleanFileAttribute(self):

        localctx = WFLParser.BooleanFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_booleanFileAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1781
            _la = self._input.LA(1)
            if not(_la==68 or ((((_la - 433)) & ~0x3f) == 0 and ((1 << (_la - 433)) & 2051) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXRECSIZE(self):
            return self.getToken(WFLParser.MAXRECSIZE, 0)

        def SERIALNO(self):
            return self.getToken(WFLParser.SERIALNO, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_integerFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerFileAttribute" ):
                listener.enterIntegerFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerFileAttribute" ):
                listener.exitIntegerFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerFileAttribute" ):
                return visitor.visitIntegerFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def integerFileAttribute(self):

        localctx = WFLParser.IntegerFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_integerFileAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1783
            _la = self._input.LA(1)
            if not(_la==397 or _la==398):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PATHNAME(self):
            return self.getToken(WFLParser.PATHNAME, 0)

        def LICENSEKEY(self):
            return self.getToken(WFLParser.LICENSEKEY, 0)

        def TRANSFORM(self):
            return self.getToken(WFLParser.TRANSFORM, 0)

        def WARNINGS(self):
            return self.getToken(WFLParser.WARNINGS, 0)

        def AFTER(self):
            return self.getToken(WFLParser.AFTER, 0)

        def DESTINATION(self):
            return self.getToken(WFLParser.DESTINATION, 0)

        def FORMID(self):
            return self.getToken(WFLParser.FORMID, 0)

        def NOTE(self):
            return self.getToken(WFLParser.NOTE, 0)

        def RELEASEID(self):
            return self.getToken(WFLParser.RELEASEID, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringFileAttribute" ):
                listener.enterStringFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringFileAttribute" ):
                listener.exitStringFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringFileAttribute" ):
                return visitor.visitStringFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def stringFileAttribute(self):

        localctx = WFLParser.StringFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_stringFileAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1785
            _la = self._input.LA(1)
            if not(_la==99 or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TitleFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TITLE(self):
            return self.getToken(WFLParser.TITLE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_titleFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTitleFileAttribute" ):
                listener.enterTitleFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTitleFileAttribute" ):
                listener.exitTitleFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTitleFileAttribute" ):
                return visitor.visitTitleFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def titleFileAttribute(self):

        localctx = WFLParser.TitleFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_titleFileAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1787
            self.match(WFLParser.TITLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockSizeFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCKSIZE(self):
            return self.getToken(WFLParser.BLOCKSIZE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_blockSizeFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockSizeFileAttribute" ):
                listener.enterBlockSizeFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockSizeFileAttribute" ):
                listener.exitBlockSizeFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockSizeFileAttribute" ):
                return visitor.visitBlockSizeFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def blockSizeFileAttribute(self):

        localctx = WFLParser.BlockSizeFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_blockSizeFileAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1789
            self.match(WFLParser.BLOCKSIZE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileNameFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILENAME(self):
            return self.getToken(WFLParser.FILENAME, 0)

        def FAMILYOWNER(self):
            return self.getToken(WFLParser.FAMILYOWNER, 0)

        def PRINTCHARGE(self):
            return self.getToken(WFLParser.PRINTCHARGE, 0)

        def STATIONLIST(self):
            return self.getToken(WFLParser.STATIONLIST, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fileNameFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileNameFileAttribute" ):
                listener.enterFileNameFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileNameFileAttribute" ):
                listener.exitFileNameFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileNameFileAttribute" ):
                return visitor.visitFileNameFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def fileNameFileAttribute(self):

        localctx = WFLParser.FileNameFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_fileNameFileAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1791
            _la = self._input.LA(1)
            if not(((((_la - 403)) & ~0x3f) == 0 and ((1 << (_la - 403)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LongFileNameFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LFILENAME(self):
            return self.getToken(WFLParser.LFILENAME, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_longFileNameFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLongFileNameFileAttribute" ):
                listener.enterLongFileNameFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLongFileNameFileAttribute" ):
                listener.exitLongFileNameFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLongFileNameFileAttribute" ):
                return visitor.visitLongFileNameFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def longFileNameFileAttribute(self):

        localctx = WFLParser.LongFileNameFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_longFileNameFileAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1793
            self.match(WFLParser.LFILENAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LongTitleFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LTITLE(self):
            return self.getToken(WFLParser.LTITLE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_longTitleFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLongTitleFileAttribute" ):
                listener.enterLongTitleFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLongTitleFileAttribute" ):
                listener.exitLongTitleFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLongTitleFileAttribute" ):
                return visitor.visitLongTitleFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def longTitleFileAttribute(self):

        localctx = WFLParser.LongTitleFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_longTitleFileAttribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1795
            self.match(WFLParser.LTITLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MnemonicFileAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def APPLICATIONGROUP(self):
            return self.getToken(WFLParser.APPLICATIONGROUP, 0)

        def FAMILYNAME(self):
            return self.getToken(WFLParser.FAMILYNAME, 0)

        def HOSTNAME(self):
            return self.getToken(WFLParser.HOSTNAME, 0)

        def INTNAME(self):
            return self.getToken(WFLParser.INTNAME, 0)

        def MYHOST(self):
            return self.getToken(WFLParser.MYHOST, 0)

        def MYHOSTGROUP(self):
            return self.getToken(WFLParser.MYHOSTGROUP, 0)

        def SCRATCHPOOL(self):
            return self.getToken(WFLParser.SCRATCHPOOL, 0)

        def YOURHOST(self):
            return self.getToken(WFLParser.YOURHOST, 0)

        def YOURHOSTGROUP(self):
            return self.getToken(WFLParser.YOURHOSTGROUP, 0)

        def YOURUSERCODE(self):
            return self.getToken(WFLParser.YOURUSERCODE, 0)

        def USERBACKUPNAME(self):
            return self.getToken(WFLParser.USERBACKUPNAME, 0)

        def DENSITY(self):
            return self.getToken(WFLParser.DENSITY, 0)

        def BLOCKSTRUCTURE(self):
            return self.getToken(WFLParser.BLOCKSTRUCTURE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_mnemonicFileAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMnemonicFileAttribute" ):
                listener.enterMnemonicFileAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMnemonicFileAttribute" ):
                listener.exitMnemonicFileAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMnemonicFileAttribute" ):
                return visitor.visitMnemonicFileAttribute(self)
            else:
                return visitor.visitChildren(self)




    def mnemonicFileAttribute(self):

        localctx = WFLParser.MnemonicFileAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_mnemonicFileAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1797
            _la = self._input.LA(1)
            if not(_la==133 or _la==249 or _la==283 or ((((_la - 409)) & ~0x3f) == 0 and ((1 << (_la - 409)) & 8589935103) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeviceKindAssigmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEVICEKIND(self):
            return self.getToken(WFLParser.DEVICEKIND, 0)

        def KIND(self):
            return self.getToken(WFLParser.KIND, 0)

        def FILEKIND(self):
            return self.getToken(WFLParser.FILEKIND, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_deviceKindAssigment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeviceKindAssigment" ):
                listener.enterDeviceKindAssigment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeviceKindAssigment" ):
                listener.exitDeviceKindAssigment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeviceKindAssigment" ):
                return visitor.visitDeviceKindAssigment(self)
            else:
                return visitor.visitChildren(self)




    def deviceKindAssigment(self):

        localctx = WFLParser.DeviceKindAssigmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_deviceKindAssigment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1799
            _la = self._input.LA(1)
            if not(_la==104 or _la==209 or _la==443):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SerialNumberAssigmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERIALNO(self):
            return self.getToken(WFLParser.SERIALNO, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_serialNumberAssigment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSerialNumberAssigment" ):
                listener.enterSerialNumberAssigment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSerialNumberAssigment" ):
                listener.exitSerialNumberAssigment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSerialNumberAssigment" ):
                return visitor.visitSerialNumberAssigment(self)
            else:
                return visitor.visitChildren(self)




    def serialNumberAssigment(self):

        localctx = WFLParser.SerialNumberAssigmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_serialNumberAssigment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1801
            self.match(WFLParser.SERIALNO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileAttributeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LITERAL)
            else:
                return self.getToken(WFLParser.LITERAL, i)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def realConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.RealConstantExpressionContext,0)


        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def fileReferencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileReferencedVariableContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,i)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_fileAttributeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileAttributeValue" ):
                listener.enterFileAttributeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileAttributeValue" ):
                listener.exitFileAttributeValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileAttributeValue" ):
                return visitor.visitFileAttributeValue(self)
            else:
                return visitor.visitChildren(self)




    def fileAttributeValue(self):

        localctx = WFLParser.FileAttributeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_fileAttributeValue)
        self._la = 0 # Token type
        try:
            self.state = 1836
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,144,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1803
                self.match(WFLParser.Num)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1804
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1805
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1806
                self.booleanConstantExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1807
                self.realConstantExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1808
                self.stringConstantExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1809
                self.filePath()
                self.state = 1815
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==253:
                    self.state = 1810
                    self.match(WFLParser.ON)
                    self.state = 1813
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [446]:
                        self.state = 1811
                        self.storageUnit()
                        pass
                    elif token in [201, 209, 211, 219]:
                        self.state = 1812
                        self.reservedKeyword()
                        pass
                    else:
                        raise NoViableAltException(self)



                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1817
                self.reservedKeyword()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1818
                self.fileReferencedVariable()
                self.state = 1824
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==253:
                    self.state = 1819
                    self.match(WFLParser.ON)
                    self.state = 1822
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [446]:
                        self.state = 1820
                        self.storageUnit()
                        pass
                    elif token in [18]:
                        self.state = 1821
                        self.fileReferencedVariable()
                        pass
                    else:
                        raise NoViableAltException(self)



                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1826
                self.match(WFLParser.LP)
                self.state = 1827
                self.match(WFLParser.LITERAL)
                self.state = 1832
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 1828
                    self.match(WFLParser.COMMA)
                    self.state = 1829
                    self.match(WFLParser.LITERAL)
                    self.state = 1834
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1835
                self.match(WFLParser.RP)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskAttributeAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def OTHERWISE(self):
            return self.getToken(WFLParser.OTHERWISE, 0)

        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def taskAttributeValue(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeValueContext,0)


        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def myselfMethod(self):
            return self.getTypedRuleContext(WFLParser.MyselfMethodContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_taskAttributeAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskAttributeAssignment" ):
                listener.enterTaskAttributeAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskAttributeAssignment" ):
                listener.exitTaskAttributeAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskAttributeAssignment" ):
                return visitor.visitTaskAttributeAssignment(self)
            else:
                return visitor.visitChildren(self)




    def taskAttributeAssignment(self):

        localctx = WFLParser.TaskAttributeAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_taskAttributeAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1838
            self.taskAttribute()
            self.state = 1855
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 1839
                self.match(WFLParser.EQUAL)
                self.state = 1853
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
                if la_ == 1:
                    self.state = 1840
                    self.taskAttributeValue()
                    pass

                elif la_ == 2:
                    self.state = 1841
                    self.match(WFLParser.EMPTYSTRING)
                    pass

                elif la_ == 3:
                    self.state = 1842
                    self.match(WFLParser.LP)
                    self.state = 1843
                    self.match(WFLParser.Identifier)
                    self.state = 1848
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==4:
                        self.state = 1844
                        self.match(WFLParser.COMMA)
                        self.state = 1845
                        self.match(WFLParser.Identifier)
                        self.state = 1850
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1851
                    self.match(WFLParser.RP)
                    pass

                elif la_ == 4:
                    self.state = 1852
                    self.myselfMethod()
                    pass




            self.state = 1859
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==218:
                self.state = 1857
                self.match(WFLParser.OTHERWISE)
                self.state = 1858
                self.reservedKeyword()


            self.state = 1862
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.state = 1861
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHARGE(self):
            return self.getToken(WFLParser.CHARGE, 0)

        def USERCODE(self):
            return self.getToken(WFLParser.USERCODE, 0)

        def HOSTNAME(self):
            return self.getToken(WFLParser.HOSTNAME, 0)

        def AUTOSWITCHTOMARC(self):
            return self.getToken(WFLParser.AUTOSWITCHTOMARC, 0)

        def DESTSTATION(self):
            return self.getToken(WFLParser.DESTSTATION, 0)

        def DISPLAYONLYTOMCS(self):
            return self.getToken(WFLParser.DISPLAYONLYTOMCS, 0)

        def LANGUAGE(self):
            return self.getToken(WFLParser.LANGUAGE, 0)

        def ORGUNIT(self):
            return self.getToken(WFLParser.ORGUNIT, 0)

        def SOURCEKIND(self):
            return self.getToken(WFLParser.SOURCEKIND, 0)

        def SOURCESTATION(self):
            return self.getToken(WFLParser.SOURCESTATION, 0)

        def STATION(self):
            return self.getToken(WFLParser.STATION, 0)

        def STATIONNAME(self):
            return self.getToken(WFLParser.STATIONNAME, 0)

        def TANKING(self):
            return self.getToken(WFLParser.TANKING, 0)

        def ITINERARY(self):
            return self.getToken(WFLParser.ITINERARY, 0)

        def OPTION(self):
            return self.getToken(WFLParser.OPTION, 0)

        def TADS(self):
            return self.getToken(WFLParser.TADS, 0)

        def TASKFILE(self):
            return self.getToken(WFLParser.TASKFILE, 0)

        def CURRENTDIRECTORY(self):
            return self.getToken(WFLParser.CURRENTDIRECTORY, 0)

        def DATABASE(self):
            return self.getToken(WFLParser.DATABASE, 0)

        def DATAPATH(self):
            return self.getToken(WFLParser.DATAPATH, 0)

        def EXECUTEPATH(self):
            return self.getToken(WFLParser.EXECUTEPATH, 0)

        def FAMILY(self):
            return self.getToken(WFLParser.FAMILY, 0)

        def FILEACCESSRULE(self):
            return self.getToken(WFLParser.FILEACCESSRULE, 0)

        def JOBNUMBER(self):
            return self.getToken(WFLParser.JOBNUMBER, 0)

        def MIXNUMBER(self):
            return self.getToken(WFLParser.MIXNUMBER, 0)

        def NAME(self):
            return self.getToken(WFLParser.NAME, 0)

        def MPID(self):
            return self.getToken(WFLParser.MPID, 0)

        def WORKLOADGROUP(self):
            return self.getToken(WFLParser.WORKLOADGROUP, 0)

        def AX(self):
            return self.getToken(WFLParser.AX, 0)

        def LOCKED(self):
            return self.getToken(WFLParser.LOCKED, 0)

        def PARTNEREXISTS(self):
            return self.getToken(WFLParser.PARTNEREXISTS, 0)

        def STATUS(self):
            return self.getToken(WFLParser.STATUS, 0)

        def SW1(self):
            return self.getToken(WFLParser.SW1, 0)

        def SW2(self):
            return self.getToken(WFLParser.SW2, 0)

        def SW3(self):
            return self.getToken(WFLParser.SW3, 0)

        def SW4(self):
            return self.getToken(WFLParser.SW4, 0)

        def SW5(self):
            return self.getToken(WFLParser.SW5, 0)

        def SW6(self):
            return self.getToken(WFLParser.SW6, 0)

        def SW7(self):
            return self.getToken(WFLParser.SW7, 0)

        def SW8(self):
            return self.getToken(WFLParser.SW8, 0)

        def TARGET(self):
            return self.getToken(WFLParser.TARGET, 0)

        def TASKLIMIT(self):
            return self.getToken(WFLParser.TASKLIMIT, 0)

        def TASKSTRING(self):
            return self.getToken(WFLParser.TASKSTRING, 0)

        def TASKVALUE(self):
            return self.getToken(WFLParser.TASKVALUE, 0)

        def TYPE(self):
            return self.getToken(WFLParser.TYPE, 0)

        def JOBSUMMARY(self):
            return self.getToken(WFLParser.JOBSUMMARY, 0)

        def JOBSUMMARYTITLE(self):
            return self.getToken(WFLParser.JOBSUMMARYTITLE, 0)

        def NOJOBSUMMARYIO(self):
            return self.getToken(WFLParser.NOJOBSUMMARYIO, 0)

        def LIBRARY(self):
            return self.getToken(WFLParser.LIBRARY, 0)

        def LIBRARYSTATE(self):
            return self.getToken(WFLParser.LIBRARYSTATE, 0)

        def LIBRARYUSERS(self):
            return self.getToken(WFLParser.LIBRARYUSERS, 0)

        def CORE(self):
            return self.getToken(WFLParser.CORE, 0)

        def STACKLIMIT(self):
            return self.getToken(WFLParser.STACKLIMIT, 0)

        def STACKSIZE(self):
            return self.getToken(WFLParser.STACKSIZE, 0)

        def BACKUPFAMILY(self):
            return self.getToken(WFLParser.BACKUPFAMILY, 0)

        def BDNAME(self):
            return self.getToken(WFLParser.BDNAME, 0)

        def PRINTDEFAULTS(self):
            return self.getToken(WFLParser.PRINTDEFAULTS, 0)

        def ACCUMIOTIME(self):
            return self.getToken(WFLParser.ACCUMIOTIME, 0)

        def ACCUMPROCTIME(self):
            return self.getToken(WFLParser.ACCUMPROCTIME, 0)

        def ELAPSEDTIME(self):
            return self.getToken(WFLParser.ELAPSEDTIME, 0)

        def INITPBITCOUNT(self):
            return self.getToken(WFLParser.INITPBITCOUNT, 0)

        def INITPBITTIME(self):
            return self.getToken(WFLParser.INITPBITTIME, 0)

        def OTHERPBITCOUNT(self):
            return self.getToken(WFLParser.OTHERPBITCOUNT, 0)

        def OTHERPBITTIME(self):
            return self.getToken(WFLParser.OTHERPBITTIME, 0)

        def TEMPFILEMBYTES(self):
            return self.getToken(WFLParser.TEMPFILEMBYTES, 0)

        def ELAPSEDLIMIT(self):
            return self.getToken(WFLParser.ELAPSEDLIMIT, 0)

        def MAXIOTIME(self):
            return self.getToken(WFLParser.MAXIOTIME, 0)

        def MAXLINES(self):
            return self.getToken(WFLParser.MAXLINES, 0)

        def MAXPROCTIME(self):
            return self.getToken(WFLParser.MAXPROCTIME, 0)

        def MAXWAIT(self):
            return self.getToken(WFLParser.MAXWAIT, 0)

        def PRIORITY(self):
            return self.getToken(WFLParser.PRIORITY, 0)

        def RESOURCE(self):
            return self.getToken(WFLParser.RESOURCE, 0)

        def SAVEMEMORYLIMIT(self):
            return self.getToken(WFLParser.SAVEMEMORYLIMIT, 0)

        def TEMPFILELIMIT(self):
            return self.getToken(WFLParser.TEMPFILELIMIT, 0)

        def TOTALMEMORYLIMIT(self):
            return self.getToken(WFLParser.TOTALMEMORYLIMIT, 0)

        def WAITLIMIT(self):
            return self.getToken(WFLParser.WAITLIMIT, 0)

        def BRCLASS(self):
            return self.getToken(WFLParser.BRCLASS, 0)

        def CHECKPOINTABLE(self):
            return self.getToken(WFLParser.CHECKPOINTABLE, 0)

        def RESTART(self):
            return self.getToken(WFLParser.RESTART, 0)

        def RESTARTED(self):
            return self.getToken(WFLParser.RESTARTED, 0)

        def ACCESSCODE(self):
            return self.getToken(WFLParser.ACCESSCODE, 0)

        def DECKGROUPNO(self):
            return self.getToken(WFLParser.DECKGROUPNO, 0)

        def ERROR(self):
            return self.getToken(WFLParser.ERROR, 0)

        def HISTORY(self):
            return self.getToken(WFLParser.HISTORY, 0)

        def HISTORYCAUSE(self):
            return self.getToken(WFLParser.HISTORYCAUSE, 0)

        def HISTORYTYPE(self):
            return self.getToken(WFLParser.HISTORYTYPE, 0)

        def HSPARAMSIZE(self):
            return self.getToken(WFLParser.HSPARAMSIZE, 0)

        def STACKHISTORY(self):
            return self.getToken(WFLParser.STACKHISTORY, 0)

        def STOPPOINT(self):
            return self.getToken(WFLParser.STOPPOINT, 0)

        def SUPPRESSWARNING(self):
            return self.getToken(WFLParser.SUPPRESSWARNING, 0)

        def TASKWARNINGS(self):
            return self.getToken(WFLParser.TASKWARNINGS, 0)

        def FAMILYDISK(self):
            return self.getToken(WFLParser.FAMILYDISK, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_taskAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskAttribute" ):
                listener.enterTaskAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskAttribute" ):
                listener.exitTaskAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskAttribute" ):
                return visitor.visitTaskAttribute(self)
            else:
                return visitor.visitChildren(self)




    def taskAttribute(self):

        localctx = WFLParser.TaskAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_taskAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1864
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1095216660480) != 0) or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 2327883808801) != 0) or ((((_la - 315)) & ~0x3f) == 0 and ((1 << (_la - 315)) & -1879048193) != 0) or ((((_la - 379)) & ~0x3f) == 0 and ((1 << (_la - 379)) & -8646911284551350273) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskAttributeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def realConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.RealConstantExpressionContext,0)


        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_taskAttributeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskAttributeValue" ):
                listener.enterTaskAttributeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskAttributeValue" ):
                listener.exitTaskAttributeValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskAttributeValue" ):
                return visitor.visitTaskAttributeValue(self)
            else:
                return visitor.visitChildren(self)




    def taskAttributeValue(self):

        localctx = WFLParser.TaskAttributeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_taskAttributeValue)
        try:
            self.state = 1872
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1866
                self.match(WFLParser.Num)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1867
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1868
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1869
                self.booleanConstantExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1870
                self.realConstantExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1871
                self.stringConstantExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def fileDeclarationElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileDeclarationElementContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileDeclarationElementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_fileDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileDeclaration" ):
                listener.enterFileDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileDeclaration" ):
                listener.exitFileDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileDeclaration" ):
                return visitor.visitFileDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def fileDeclaration(self):

        localctx = WFLParser.FileDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_fileDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1874
            self.match(WFLParser.FILE)
            self.state = 1875
            self.fileDeclarationElement()
            self.state = 1880
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1876
                self.match(WFLParser.COMMA)
                self.state = 1877
                self.fileDeclarationElement()
                self.state = 1882
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1883
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileDeclarationElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileAttributeAssignmentContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_fileDeclarationElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileDeclarationElement" ):
                listener.enterFileDeclarationElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileDeclarationElement" ):
                listener.exitFileDeclarationElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileDeclarationElement" ):
                return visitor.visitFileDeclarationElement(self)
            else:
                return visitor.visitChildren(self)




    def fileDeclarationElement(self):

        localctx = WFLParser.FileDeclarationElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_fileDeclarationElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1885
            self.match(WFLParser.Identifier)
            self.state = 1897
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 1886
                self.match(WFLParser.LP)
                self.state = 1887
                self.fileAttributeAssignment()
                self.state = 1892
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 1888
                    self.match(WFLParser.COMMA)
                    self.state = 1889
                    self.fileAttributeAssignment()
                    self.state = 1894
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1895
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(WFLParser.BOOLEAN, 0)

        def booleanDeclarationElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.BooleanDeclarationElementContext)
            else:
                return self.getTypedRuleContext(WFLParser.BooleanDeclarationElementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDeclaration" ):
                listener.enterBooleanDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDeclaration" ):
                listener.exitBooleanDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDeclaration" ):
                return visitor.visitBooleanDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def booleanDeclaration(self):

        localctx = WFLParser.BooleanDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_booleanDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1899
            self.match(WFLParser.BOOLEAN)
            self.state = 1900
            self.booleanDeclarationElement()
            self.state = 1905
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1901
                self.match(WFLParser.COMMA)
                self.state = 1902
                self.booleanDeclarationElement()
                self.state = 1907
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1908
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDeclarationElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_booleanDeclarationElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDeclarationElement" ):
                listener.enterBooleanDeclarationElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDeclarationElement" ):
                listener.exitBooleanDeclarationElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDeclarationElement" ):
                return visitor.visitBooleanDeclarationElement(self)
            else:
                return visitor.visitChildren(self)




    def booleanDeclarationElement(self):

        localctx = WFLParser.BooleanDeclarationElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_booleanDeclarationElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1910
            self.match(WFLParser.Identifier)
            self.state = 1913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 1911
                self.match(WFLParser.ASSIGN)
                self.state = 1912
                self.booleanConstantExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanConstantExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(WFLParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(WFLParser.FALSE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanConstantExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanConstantExpression" ):
                listener.enterBooleanConstantExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanConstantExpression" ):
                listener.exitBooleanConstantExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanConstantExpression" ):
                return visitor.visitBooleanConstantExpression(self)
            else:
                return visitor.visitChildren(self)




    def booleanConstantExpression(self):

        localctx = WFLParser.BooleanConstantExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_booleanConstantExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1915
            _la = self._input.LA(1)
            if not(_la==239 or _la==245 or _la==446):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(WFLParser.INTEGER, 0)

        def integerDeclarationElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.IntegerDeclarationElementContext)
            else:
                return self.getTypedRuleContext(WFLParser.IntegerDeclarationElementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_integerDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerDeclaration" ):
                listener.enterIntegerDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerDeclaration" ):
                listener.exitIntegerDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerDeclaration" ):
                return visitor.visitIntegerDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def integerDeclaration(self):

        localctx = WFLParser.IntegerDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_integerDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1917
            self.match(WFLParser.INTEGER)
            self.state = 1918
            self.integerDeclarationElement()
            self.state = 1923
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1919
                self.match(WFLParser.COMMA)
                self.state = 1920
                self.integerDeclarationElement()
                self.state = 1925
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1926
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerDeclarationElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def integerConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_integerDeclarationElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerDeclarationElement" ):
                listener.enterIntegerDeclarationElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerDeclarationElement" ):
                listener.exitIntegerDeclarationElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerDeclarationElement" ):
                return visitor.visitIntegerDeclarationElement(self)
            else:
                return visitor.visitChildren(self)




    def integerDeclarationElement(self):

        localctx = WFLParser.IntegerDeclarationElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_integerDeclarationElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1928
            self.match(WFLParser.Identifier)
            self.state = 1931
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 1929
                self.match(WFLParser.ASSIGN)
                self.state = 1930
                self.integerConstantExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerConstantExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def parameterReference(self):
            return self.getTypedRuleContext(WFLParser.ParameterReferenceContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_integerConstantExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerConstantExpression" ):
                listener.enterIntegerConstantExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerConstantExpression" ):
                listener.exitIntegerConstantExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerConstantExpression" ):
                return visitor.visitIntegerConstantExpression(self)
            else:
                return visitor.visitChildren(self)




    def integerConstantExpression(self):

        localctx = WFLParser.IntegerConstantExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_integerConstantExpression)
        try:
            self.state = 1936
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,158,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1933
                self.match(WFLParser.Num)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1934
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1935
                self.parameterReference()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL(self):
            return self.getToken(WFLParser.REAL, 0)

        def realDeclarationElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.RealDeclarationElementContext)
            else:
                return self.getTypedRuleContext(WFLParser.RealDeclarationElementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_realDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealDeclaration" ):
                listener.enterRealDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealDeclaration" ):
                listener.exitRealDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealDeclaration" ):
                return visitor.visitRealDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def realDeclaration(self):

        localctx = WFLParser.RealDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_realDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1938
            self.match(WFLParser.REAL)
            self.state = 1939
            self.realDeclarationElement()
            self.state = 1944
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1940
                self.match(WFLParser.COMMA)
                self.state = 1941
                self.realDeclarationElement()
                self.state = 1946
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1947
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealDeclarationElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def realConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.RealConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_realDeclarationElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealDeclarationElement" ):
                listener.enterRealDeclarationElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealDeclarationElement" ):
                listener.exitRealDeclarationElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealDeclarationElement" ):
                return visitor.visitRealDeclarationElement(self)
            else:
                return visitor.visitChildren(self)




    def realDeclarationElement(self):

        localctx = WFLParser.RealDeclarationElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_realDeclarationElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1949
            self.match(WFLParser.Identifier)
            self.state = 1952
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 1950
                self.match(WFLParser.ASSIGN)
                self.state = 1951
                self.realConstantExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealConstantExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def DOT(self):
            return self.getToken(WFLParser.DOT, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def parameterReference(self):
            return self.getTypedRuleContext(WFLParser.ParameterReferenceContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_realConstantExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealConstantExpression" ):
                listener.enterRealConstantExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealConstantExpression" ):
                listener.exitRealConstantExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealConstantExpression" ):
                return visitor.visitRealConstantExpression(self)
            else:
                return visitor.visitChildren(self)




    def realConstantExpression(self):

        localctx = WFLParser.RealConstantExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_realConstantExpression)
        self._la = 0 # Token type
        try:
            self.state = 1961
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1954
                self.match(WFLParser.Num)
                self.state = 1957
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19:
                    self.state = 1955
                    self.match(WFLParser.DOT)
                    self.state = 1956
                    self.match(WFLParser.Num)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1959
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1960
                self.parameterReference()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def stringDeclarationElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StringDeclarationElementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StringDeclarationElementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_stringDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringDeclaration" ):
                listener.enterStringDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringDeclaration" ):
                listener.exitStringDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringDeclaration" ):
                return visitor.visitStringDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def stringDeclaration(self):

        localctx = WFLParser.StringDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_stringDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1963
            self.match(WFLParser.STRING)
            self.state = 1964
            self.stringDeclarationElement()
            self.state = 1969
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 1965
                self.match(WFLParser.COMMA)
                self.state = 1966
                self.stringDeclarationElement()
                self.state = 1971
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1972
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringDeclarationElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_stringDeclarationElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringDeclarationElement" ):
                listener.enterStringDeclarationElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringDeclarationElement" ):
                listener.exitStringDeclarationElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringDeclarationElement" ):
                return visitor.visitStringDeclarationElement(self)
            else:
                return visitor.visitChildren(self)




    def stringDeclarationElement(self):

        localctx = WFLParser.StringDeclarationElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_stringDeclarationElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1976
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.state = 1974
                self.match(WFLParser.Identifier)
                pass
            elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                self.state = 1975
                self.charDataKeyword()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1980
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 1978
                self.match(WFLParser.ASSIGN)
                self.state = 1979
                self.stringConstantExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringConstantExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryStringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.PrimaryStringExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.PrimaryStringExpressionContext,i)


        def AMPERSAND(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.AMPERSAND)
            else:
                return self.getToken(WFLParser.AMPERSAND, i)

        def getRuleIndex(self):
            return WFLParser.RULE_stringConstantExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringConstantExpression" ):
                listener.enterStringConstantExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringConstantExpression" ):
                listener.exitStringConstantExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringConstantExpression" ):
                return visitor.visitStringConstantExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringConstantExpression(self):

        localctx = WFLParser.StringConstantExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_stringConstantExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1982
            self.primaryStringExpression()
            self.state = 1987
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 1983
                self.match(WFLParser.AMPERSAND)
                self.state = 1984
                self.primaryStringExpression()
                self.state = 1989
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryStringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def parameterReference(self):
            return self.getTypedRuleContext(WFLParser.ParameterReferenceContext,0)


        def stringFunction(self):
            return self.getTypedRuleContext(WFLParser.StringFunctionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_primaryStringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryStringExpression" ):
                listener.enterPrimaryStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryStringExpression" ):
                listener.exitPrimaryStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryStringExpression" ):
                return visitor.visitPrimaryStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def primaryStringExpression(self):

        localctx = WFLParser.PrimaryStringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_primaryStringExpression)
        try:
            self.state = 1995
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1990
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1991
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1992
                self.parameterReference()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1993
                self.stringFunction()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1994
                self.stringExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringFunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def STAR(self):
            return self.getToken(WFLParser.STAR, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringFunction" ):
                listener.enterStringFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringFunction" ):
                listener.exitStringFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringFunction" ):
                return visitor.visitStringFunction(self)
            else:
                return visitor.visitChildren(self)




    def stringFunction(self):

        localctx = WFLParser.StringFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_stringFunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1997
            self.match(WFLParser.STRING)
            self.state = 1998
            self.match(WFLParser.LP)
            self.state = 1999
            _la = self._input.LA(1)
            if not(_la==446 or _la==447):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2002
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 2000
                self.match(WFLParser.COMMA)
                self.state = 2001
                self.match(WFLParser.STAR)


            self.state = 2004
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_parameterReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterReference" ):
                listener.enterParameterReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterReference" ):
                listener.exitParameterReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterReference" ):
                return visitor.visitParameterReference(self)
            else:
                return visitor.visitChildren(self)




    def parameterReference(self):

        localctx = WFLParser.ParameterReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_parameterReference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2006
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTANT(self):
            return self.getToken(WFLParser.CONSTANT, 0)

        def constantDeclarationElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ConstantDeclarationElementContext)
            else:
                return self.getTypedRuleContext(WFLParser.ConstantDeclarationElementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_constantDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantDeclaration" ):
                listener.enterConstantDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantDeclaration" ):
                listener.exitConstantDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantDeclaration" ):
                return visitor.visitConstantDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def constantDeclaration(self):

        localctx = WFLParser.ConstantDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_constantDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2008
            self.match(WFLParser.CONSTANT)
            self.state = 2009
            self.constantDeclarationElement()
            self.state = 2014
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2010
                self.match(WFLParser.COMMA)
                self.state = 2011
                self.constantDeclarationElement()
                self.state = 2016
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2017
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantDeclarationElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanConstantDeclaration(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantDeclarationContext,0)


        def integerConstantDeclaration(self):
            return self.getTypedRuleContext(WFLParser.IntegerConstantDeclarationContext,0)


        def realConstantDeclaration(self):
            return self.getTypedRuleContext(WFLParser.RealConstantDeclarationContext,0)


        def stringConstantDeclaration(self):
            return self.getTypedRuleContext(WFLParser.StringConstantDeclarationContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_constantDeclarationElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantDeclarationElement" ):
                listener.enterConstantDeclarationElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantDeclarationElement" ):
                listener.exitConstantDeclarationElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantDeclarationElement" ):
                return visitor.visitConstantDeclarationElement(self)
            else:
                return visitor.visitChildren(self)




    def constantDeclarationElement(self):

        localctx = WFLParser.ConstantDeclarationElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_constantDeclarationElement)
        try:
            self.state = 2023
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2019
                self.booleanConstantDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2020
                self.integerConstantDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2021
                self.realConstantDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2022
                self.stringConstantDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanConstantDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_booleanConstantDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanConstantDeclaration" ):
                listener.enterBooleanConstantDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanConstantDeclaration" ):
                listener.exitBooleanConstantDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanConstantDeclaration" ):
                return visitor.visitBooleanConstantDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def booleanConstantDeclaration(self):

        localctx = WFLParser.BooleanConstantDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_booleanConstantDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2025
            self.match(WFLParser.Identifier)
            self.state = 2026
            self.match(WFLParser.EQUAL)
            self.state = 2027
            self.booleanConstantExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerConstantDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def integerConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_integerConstantDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerConstantDeclaration" ):
                listener.enterIntegerConstantDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerConstantDeclaration" ):
                listener.exitIntegerConstantDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerConstantDeclaration" ):
                return visitor.visitIntegerConstantDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def integerConstantDeclaration(self):

        localctx = WFLParser.IntegerConstantDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_integerConstantDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2029
            self.match(WFLParser.Identifier)
            self.state = 2030
            self.match(WFLParser.EQUAL)
            self.state = 2031
            self.integerConstantExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealConstantDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def realConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.RealConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_realConstantDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealConstantDeclaration" ):
                listener.enterRealConstantDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealConstantDeclaration" ):
                listener.exitRealConstantDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealConstantDeclaration" ):
                return visitor.visitRealConstantDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def realConstantDeclaration(self):

        localctx = WFLParser.RealConstantDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_realConstantDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2033
            self.match(WFLParser.Identifier)
            self.state = 2034
            self.match(WFLParser.EQUAL)
            self.state = 2035
            self.realConstantExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringConstantDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_stringConstantDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringConstantDeclaration" ):
                listener.enterStringConstantDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringConstantDeclaration" ):
                listener.exitStringConstantDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringConstantDeclaration" ):
                return visitor.visitStringConstantDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def stringConstantDeclaration(self):

        localctx = WFLParser.StringConstantDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_stringConstantDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2037
            self.match(WFLParser.Identifier)
            self.state = 2038
            self.match(WFLParser.EQUAL)
            self.state = 2039
            self.stringConstantExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBROUTINE(self):
            return self.getToken(WFLParser.SUBROUTINE, 0)

        def subroutineName(self):
            return self.getTypedRuleContext(WFLParser.SubroutineNameContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def statement(self):
            return self.getTypedRuleContext(WFLParser.StatementContext,0)


        def subroutineBlock(self):
            return self.getTypedRuleContext(WFLParser.SubroutineBlockContext,0)


        def subroutineParameters(self):
            return self.getTypedRuleContext(WFLParser.SubroutineParametersContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subroutineDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineDeclaration" ):
                listener.enterSubroutineDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineDeclaration" ):
                listener.exitSubroutineDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineDeclaration" ):
                return visitor.visitSubroutineDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def subroutineDeclaration(self):

        localctx = WFLParser.SubroutineDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_subroutineDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2041
            self.match(WFLParser.SUBROUTINE)
            self.state = 2042
            self.subroutineName()
            self.state = 2044
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 2043
                self.subroutineParameters()


            self.state = 2046
            self.match(WFLParser.SEMICOLON)
            self.state = 2049
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.state = 2047
                self.statement()
                pass

            elif la_ == 2:
                self.state = 2048
                self.subroutineBlock()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def compilerName(self):
            return self.getTypedRuleContext(WFLParser.CompilerNameContext,0)


        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subroutineName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineName" ):
                listener.enterSubroutineName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineName" ):
                listener.exitSubroutineName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineName" ):
                return visitor.visitSubroutineName(self)
            else:
                return visitor.visitChildren(self)




    def subroutineName(self):

        localctx = WFLParser.SubroutineNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_subroutineName)
        try:
            self.state = 2054
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,173,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2051
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2052
                self.compilerName()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2053
                self.charDataKeyword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def subroutineParameterList(self):
            return self.getTypedRuleContext(WFLParser.SubroutineParameterListContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_subroutineParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineParameters" ):
                listener.enterSubroutineParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineParameters" ):
                listener.exitSubroutineParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineParameters" ):
                return visitor.visitSubroutineParameters(self)
            else:
                return visitor.visitChildren(self)




    def subroutineParameters(self):

        localctx = WFLParser.SubroutineParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_subroutineParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2056
            self.match(WFLParser.LP)
            self.state = 2057
            self.subroutineParameterList()
            self.state = 2058
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subroutineParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.SubroutineParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.SubroutineParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_subroutineParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineParameterList" ):
                listener.enterSubroutineParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineParameterList" ):
                listener.exitSubroutineParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineParameterList" ):
                return visitor.visitSubroutineParameterList(self)
            else:
                return visitor.visitChildren(self)




    def subroutineParameterList(self):

        localctx = WFLParser.SubroutineParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_subroutineParameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2060
            self.subroutineParameter()
            self.state = 2065
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2061
                self.match(WFLParser.COMMA)
                self.state = 2062
                self.subroutineParameter()
                self.state = 2067
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanParameter(self):
            return self.getTypedRuleContext(WFLParser.BooleanParameterContext,0)


        def integerParameter(self):
            return self.getTypedRuleContext(WFLParser.IntegerParameterContext,0)


        def realParameter(self):
            return self.getTypedRuleContext(WFLParser.RealParameterContext,0)


        def stringParameter(self):
            return self.getTypedRuleContext(WFLParser.StringParameterContext,0)


        def fileParameter(self):
            return self.getTypedRuleContext(WFLParser.FileParameterContext,0)


        def taskParameter(self):
            return self.getTypedRuleContext(WFLParser.TaskParameterContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subroutineParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineParameter" ):
                listener.enterSubroutineParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineParameter" ):
                listener.exitSubroutineParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineParameter" ):
                return visitor.visitSubroutineParameter(self)
            else:
                return visitor.visitChildren(self)




    def subroutineParameter(self):

        localctx = WFLParser.SubroutineParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_subroutineParameter)
        try:
            self.state = 2074
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [230]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2068
                self.booleanParameter()
                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2069
                self.integerParameter()
                pass
            elif token in [231]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2070
                self.realParameter()
                pass
            elif token in [235]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2071
                self.stringParameter()
                pass
            elif token in [237]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2072
                self.fileParameter()
                pass
            elif token in [238]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2073
                self.taskParameter()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(WFLParser.BOOLEAN, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def VALUE(self):
            return self.getToken(WFLParser.VALUE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanParameter" ):
                listener.enterBooleanParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanParameter" ):
                listener.exitBooleanParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanParameter" ):
                return visitor.visitBooleanParameter(self)
            else:
                return visitor.visitChildren(self)




    def booleanParameter(self):

        localctx = WFLParser.BooleanParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_booleanParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2076
            self.match(WFLParser.BOOLEAN)
            self.state = 2077
            self.match(WFLParser.Identifier)
            self.state = 2079
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 2078
                self.match(WFLParser.VALUE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(WFLParser.INTEGER, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def VALUE(self):
            return self.getToken(WFLParser.VALUE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_integerParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerParameter" ):
                listener.enterIntegerParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerParameter" ):
                listener.exitIntegerParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerParameter" ):
                return visitor.visitIntegerParameter(self)
            else:
                return visitor.visitChildren(self)




    def integerParameter(self):

        localctx = WFLParser.IntegerParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_integerParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2081
            self.match(WFLParser.INTEGER)
            self.state = 2082
            self.match(WFLParser.Identifier)
            self.state = 2084
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 2083
                self.match(WFLParser.VALUE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL(self):
            return self.getToken(WFLParser.REAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def VALUE(self):
            return self.getToken(WFLParser.VALUE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealParameter" ):
                listener.enterRealParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealParameter" ):
                listener.exitRealParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealParameter" ):
                return visitor.visitRealParameter(self)
            else:
                return visitor.visitChildren(self)




    def realParameter(self):

        localctx = WFLParser.RealParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_realParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2086
            self.match(WFLParser.REAL)
            self.state = 2087
            self.match(WFLParser.Identifier)
            self.state = 2089
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 2088
                self.match(WFLParser.VALUE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def VALUE(self):
            return self.getToken(WFLParser.VALUE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringParameter" ):
                listener.enterStringParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringParameter" ):
                listener.exitStringParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringParameter" ):
                return visitor.visitStringParameter(self)
            else:
                return visitor.visitChildren(self)




    def stringParameter(self):

        localctx = WFLParser.StringParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_stringParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2091
            self.match(WFLParser.STRING)
            self.state = 2094
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.state = 2092
                self.match(WFLParser.Identifier)
                pass
            elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                self.state = 2093
                self.charDataKeyword()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2097
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 2096
                self.match(WFLParser.VALUE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fileParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileParameter" ):
                listener.enterFileParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileParameter" ):
                listener.exitFileParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileParameter" ):
                return visitor.visitFileParameter(self)
            else:
                return visitor.visitChildren(self)




    def fileParameter(self):

        localctx = WFLParser.FileParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_fileParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2099
            self.match(WFLParser.FILE)
            self.state = 2100
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TASK(self):
            return self.getToken(WFLParser.TASK, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_taskParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskParameter" ):
                listener.enterTaskParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskParameter" ):
                listener.exitTaskParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskParameter" ):
                return visitor.visitTaskParameter(self)
            else:
                return visitor.visitChildren(self)




    def taskParameter(self):

        localctx = WFLParser.TaskParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_taskParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2102
            self.match(WFLParser.TASK)
            self.state = 2103
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def declarations(self):
            return self.getTypedRuleContext(WFLParser.DeclarationsContext,0)


        def statements(self):
            return self.getTypedRuleContext(WFLParser.StatementsContext,0)


        def subroutineName(self):
            return self.getTypedRuleContext(WFLParser.SubroutineNameContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subroutineBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineBlock" ):
                listener.enterSubroutineBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineBlock" ):
                listener.exitSubroutineBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineBlock" ):
                return visitor.visitSubroutineBlock(self)
            else:
                return visitor.visitChildren(self)




    def subroutineBlock(self):

        localctx = WFLParser.SubroutineBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_subroutineBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2105
            self.match(WFLParser.BEGIN)
            self.state = 2107
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
            if la_ == 1:
                self.state = 2106
                self.declarations()


            self.state = 2110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0):
                self.state = 2109
                self.statements()


            self.state = 2112
            self.match(WFLParser.END)
            self.state = 2114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 40)) & ~0x3f) == 0 and ((1 << (_la - 40)) & -2163192673824968481) != 0) or ((((_la - 105)) & ~0x3f) == 0 and ((1 << (_la - 105)) & 2251799914897153) != 0) or ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & -8427922648553221121) != 0) or ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & 2308791369004309601) != 0) or ((((_la - 312)) & ~0x3f) == 0 and ((1 << (_la - 312)) & 281765021220865) != 0) or ((((_la - 391)) & ~0x3f) == 0 and ((1 << (_la - 391)) & 45035996407922825) != 0):
                self.state = 2113
                self.subroutineName()


            self.state = 2116
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileReferencedVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASH(self):
            return self.getToken(WFLParser.HASH, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fileReferencedVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileReferencedVariable" ):
                listener.enterFileReferencedVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileReferencedVariable" ):
                listener.exitFileReferencedVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileReferencedVariable" ):
                return visitor.visitFileReferencedVariable(self)
            else:
                return visitor.visitChildren(self)




    def fileReferencedVariable(self):

        localctx = WFLParser.FileReferencedVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_fileReferencedVariable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2118
            self.match(WFLParser.HASH)
            self.state = 2120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 2119
                self.match(WFLParser.LP)


            self.state = 2124
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,185,self._ctx)
            if la_ == 1:
                self.state = 2122
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 2123
                self.stringExpression()
                pass


            self.state = 2127
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,186,self._ctx)
            if la_ == 1:
                self.state = 2126
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelIdentifer(self):
            return self.getTypedRuleContext(WFLParser.LabelIdentiferContext,0)


        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = WFLParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2129
            self.labelIdentifer()
            self.state = 2130
            self.match(WFLParser.COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_statements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatements" ):
                listener.enterStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatements" ):
                listener.exitStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatements" ):
                return visitor.visitStatements(self)
            else:
                return visitor.visitChildren(self)




    def statements(self):

        localctx = WFLParser.StatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_statements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2133 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2132
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 2135 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,187,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compileStatement(self):
            return self.getTypedRuleContext(WFLParser.CompileStatementContext,0)


        def runStatement(self):
            return self.getTypedRuleContext(WFLParser.RunStatementContext,0)


        def displayStatement(self):
            return self.getTypedRuleContext(WFLParser.DisplayStatementContext,0)


        def initializeStatement(self):
            return self.getTypedRuleContext(WFLParser.InitializeStatementContext,0)


        def abortStatement(self):
            return self.getTypedRuleContext(WFLParser.AbortStatementContext,0)


        def waitStatement(self):
            return self.getTypedRuleContext(WFLParser.WaitStatementContext,0)


        def addStatement(self):
            return self.getTypedRuleContext(WFLParser.AddStatementContext,0)


        def processStatement(self):
            return self.getTypedRuleContext(WFLParser.ProcessStatementContext,0)


        def assignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.AssignmentStatementContext,0)


        def startStatement(self):
            return self.getTypedRuleContext(WFLParser.StartStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(WFLParser.IfStatementContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(WFLParser.DoStatementContext,0)


        def whileStatement(self):
            return self.getTypedRuleContext(WFLParser.WhileStatementContext,0)


        def caseStatement(self):
            return self.getTypedRuleContext(WFLParser.CaseStatementContext,0)


        def alterStatement(self):
            return self.getTypedRuleContext(WFLParser.AlterStatementContext,0)


        def changeStatement(self):
            return self.getTypedRuleContext(WFLParser.ChangeStatementContext,0)


        def crunchStatement(self):
            return self.getTypedRuleContext(WFLParser.CrunchStatementContext,0)


        def goStatement(self):
            return self.getTypedRuleContext(WFLParser.GoStatementContext,0)


        def modifyStatement(self):
            return self.getTypedRuleContext(WFLParser.ModifyStatementContext,0)


        def removeStatement(self):
            return self.getTypedRuleContext(WFLParser.RemoveStatementContext,0)


        def onStatement(self):
            return self.getTypedRuleContext(WFLParser.OnStatementContext,0)


        def openStatement(self):
            return self.getTypedRuleContext(WFLParser.OpenStatementContext,0)


        def lockStatement(self):
            return self.getTypedRuleContext(WFLParser.LockStatementContext,0)


        def releaseStatement(self):
            return self.getTypedRuleContext(WFLParser.ReleaseStatementContext,0)


        def replaceStatement(self):
            return self.getTypedRuleContext(WFLParser.ReplaceStatementContext,0)


        def subroutineInvocationStatement(self):
            return self.getTypedRuleContext(WFLParser.SubroutineInvocationStatementContext,0)


        def copyStatement(self):
            return self.getTypedRuleContext(WFLParser.CopyStatementContext,0)


        def copyAndRemoveStatement(self):
            return self.getTypedRuleContext(WFLParser.CopyAndRemoveStatementContext,0)


        def copyAndCompareStatement(self):
            return self.getTypedRuleContext(WFLParser.CopyAndCompareStatementContext,0)


        def label(self):
            return self.getTypedRuleContext(WFLParser.LabelContext,0)


        def myselfTaskAssignment(self):
            return self.getTypedRuleContext(WFLParser.MyselfTaskAssignmentContext,0)


        def myjobTaskAssignment(self):
            return self.getTypedRuleContext(WFLParser.MyjobTaskAssignmentContext,0)


        def printStatement(self):
            return self.getTypedRuleContext(WFLParser.PrintStatementContext,0)


        def wrapAndCompressStatement(self):
            return self.getTypedRuleContext(WFLParser.WrapAndCompressStatementContext,0)


        def dataDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DataDeclarationContext,0)


        def startAndWaitStatement(self):
            return self.getTypedRuleContext(WFLParser.StartAndWaitStatementContext,0)


        def stackLimitAttribute(self):
            return self.getTypedRuleContext(WFLParser.StackLimitAttributeContext,0)


        def userAttribute(self):
            return self.getTypedRuleContext(WFLParser.UserAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = WFLParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_statement)
        try:
            self.state = 2175
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2137
                self.compileStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2138
                self.runStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2139
                self.displayStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2140
                self.initializeStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2141
                self.abortStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2142
                self.waitStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2143
                self.addStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2144
                self.processStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2145
                self.assignmentStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2146
                self.startStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2147
                self.ifStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2148
                self.doStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2149
                self.whileStatement()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 2150
                self.caseStatement()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 2151
                self.alterStatement()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 2152
                self.changeStatement()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 2153
                self.crunchStatement()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 2154
                self.goStatement()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 2155
                self.modifyStatement()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 2156
                self.removeStatement()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 2157
                self.onStatement()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 2158
                self.openStatement()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 2159
                self.lockStatement()
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 2160
                self.releaseStatement()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 2161
                self.replaceStatement()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 2162
                self.subroutineInvocationStatement()
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 2163
                self.copyStatement()
                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 2164
                self.copyAndRemoveStatement()
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 2165
                self.copyAndCompareStatement()
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 2166
                self.label()
                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 2167
                self.myselfTaskAssignment()
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 2168
                self.myjobTaskAssignment()
                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 2169
                self.printStatement()
                pass

            elif la_ == 34:
                self.enterOuterAlt(localctx, 34)
                self.state = 2170
                self.wrapAndCompressStatement()
                pass

            elif la_ == 35:
                self.enterOuterAlt(localctx, 35)
                self.state = 2171
                self.dataDeclaration()
                pass

            elif la_ == 36:
                self.enterOuterAlt(localctx, 36)
                self.state = 2172
                self.startAndWaitStatement()
                pass

            elif la_ == 37:
                self.enterOuterAlt(localctx, 37)
                self.state = 2173
                self.stackLimitAttribute()
                pass

            elif la_ == 38:
                self.enterOuterAlt(localctx, 38)
                self.state = 2174
                self.userAttribute()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartAndWaitStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START(self):
            return self.getToken(WFLParser.START, 0)

        def AND(self):
            return self.getToken(WFLParser.AND, 0)

        def WAIT(self):
            return self.getToken(WFLParser.WAIT, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def runParameterList(self):
            return self.getTypedRuleContext(WFLParser.RunParameterListContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_startAndWaitStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartAndWaitStatement" ):
                listener.enterStartAndWaitStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartAndWaitStatement" ):
                listener.exitStartAndWaitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartAndWaitStatement" ):
                return visitor.visitStartAndWaitStatement(self)
            else:
                return visitor.visitChildren(self)




    def startAndWaitStatement(self):

        localctx = WFLParser.StartAndWaitStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_startAndWaitStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2177
            self.match(WFLParser.START)
            self.state = 2178
            self.match(WFLParser.AND)
            self.state = 2179
            self.match(WFLParser.WAIT)
            self.state = 2180
            self.filePath()
            self.state = 2181
            self.runParameterList()
            self.state = 2182
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WrapAndCompressStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WRAP(self):
            return self.getToken(WFLParser.WRAP, 0)

        def AMPERSAND(self):
            return self.getToken(WFLParser.AMPERSAND, 0)

        def COMPRESS(self):
            return self.getToken(WFLParser.COMPRESS, 0)

        def wrapAndCompressFrom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.WrapAndCompressFromContext)
            else:
                return self.getTypedRuleContext(WFLParser.WrapAndCompressFromContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def intoClause(self):
            return self.getTypedRuleContext(WFLParser.IntoClauseContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def toClause(self):
            return self.getTypedRuleContext(WFLParser.ToClauseContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_wrapAndCompressStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWrapAndCompressStatement" ):
                listener.enterWrapAndCompressStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWrapAndCompressStatement" ):
                listener.exitWrapAndCompressStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWrapAndCompressStatement" ):
                return visitor.visitWrapAndCompressStatement(self)
            else:
                return visitor.visitChildren(self)




    def wrapAndCompressStatement(self):

        localctx = WFLParser.WrapAndCompressStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_wrapAndCompressStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2184
            self.match(WFLParser.WRAP)
            self.state = 2185
            self.match(WFLParser.AMPERSAND)
            self.state = 2186
            self.match(WFLParser.COMPRESS)
            self.state = 2187
            self.wrapAndCompressFrom()
            self.state = 2192
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2188
                self.match(WFLParser.COMMA)
                self.state = 2189
                self.wrapAndCompressFrom()
                self.state = 2194
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2195
            self.intoClause()
            self.state = 2197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 2196
                self.fromClause()


            self.state = 2200
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 2199
                self.toClause()


            self.state = 2206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2202
                self.match(WFLParser.LS)
                self.state = 2203
                self.taskIdentifier()
                self.state = 2204
                self.match(WFLParser.RS)


            self.state = 2208
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WrapAndCompressFromContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def fileReferencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileReferencedVariableContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,i)


        def EQUAL(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.EQUAL)
            else:
                return self.getToken(WFLParser.EQUAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def copyAsClause(self):
            return self.getTypedRuleContext(WFLParser.CopyAsClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_wrapAndCompressFrom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWrapAndCompressFrom" ):
                listener.enterWrapAndCompressFrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWrapAndCompressFrom" ):
                listener.exitWrapAndCompressFrom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWrapAndCompressFrom" ):
                return visitor.visitWrapAndCompressFrom(self)
            else:
                return visitor.visitChildren(self)




    def wrapAndCompressFrom(self):

        localctx = WFLParser.WrapAndCompressFromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_wrapAndCompressFrom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2213
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,193,self._ctx)
            if la_ == 1:
                self.state = 2210
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2211
                self.fileReferencedVariable()
                pass

            elif la_ == 3:
                self.state = 2212
                self.match(WFLParser.EQUAL)
                pass


            self.state = 2223
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,195,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2215
                    self.match(WFLParser.COMMA)
                    self.state = 2219
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,194,self._ctx)
                    if la_ == 1:
                        self.state = 2216
                        self.filePath()
                        pass

                    elif la_ == 2:
                        self.state = 2217
                        self.fileReferencedVariable()
                        pass

                    elif la_ == 3:
                        self.state = 2218
                        self.match(WFLParser.EQUAL)
                        pass

             
                self.state = 2225
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,195,self._ctx)

            self.state = 2227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==189:
                self.state = 2226
                self.copyAsClause()


            self.state = 2230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 2229
                self.fromClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINT(self):
            return self.getToken(WFLParser.PRINT, 0)

        def printSpecification(self):
            return self.getTypedRuleContext(WFLParser.PrintSpecificationContext,0)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def printDefault(self):
            return self.getTypedRuleContext(WFLParser.PrintDefaultContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_printStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintStatement" ):
                listener.enterPrintStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintStatement" ):
                listener.exitPrintStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintStatement" ):
                return visitor.visitPrintStatement(self)
            else:
                return visitor.visitChildren(self)




    def printStatement(self):

        localctx = WFLParser.PrintStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_printStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2232
            self.match(WFLParser.PRINT)
            self.state = 2233
            self.printSpecification()
            self.state = 2234
            self.match(WFLParser.SEMICOLON)
            self.state = 2235
            self.printDefault()
            self.state = 2236
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def fileReferencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileReferencedVariableContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_printSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintSpecification" ):
                listener.enterPrintSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintSpecification" ):
                listener.exitPrintSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintSpecification" ):
                return visitor.visitPrintSpecification(self)
            else:
                return visitor.visitChildren(self)




    def printSpecification(self):

        localctx = WFLParser.PrintSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_printSpecification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2240
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
            if la_ == 1:
                self.state = 2238
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2239
                self.fileReferencedVariable()
                pass


            self.state = 2249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2242
                self.match(WFLParser.COMMA)
                self.state = 2245
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
                if la_ == 1:
                    self.state = 2243
                    self.filePath()
                    pass

                elif la_ == 2:
                    self.state = 2244
                    self.fileReferencedVariable()
                    pass


                self.state = 2251
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2252
                self.match(WFLParser.LS)
                self.state = 2253
                self.taskIdentifier()
                self.state = 2254
                self.match(WFLParser.RS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintDefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINTDEFAULTS(self):
            return self.getToken(WFLParser.PRINTDEFAULTS, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def printDefaultParameters(self):
            return self.getTypedRuleContext(WFLParser.PrintDefaultParametersContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_printDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintDefault" ):
                listener.enterPrintDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintDefault" ):
                listener.exitPrintDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintDefault" ):
                return visitor.visitPrintDefault(self)
            else:
                return visitor.visitChildren(self)




    def printDefault(self):

        localctx = WFLParser.PrintDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_printDefault)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2258
            self.match(WFLParser.PRINTDEFAULTS)
            self.state = 2259
            self.match(WFLParser.EQUAL)
            self.state = 2264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 2260
                self.match(WFLParser.LP)
                self.state = 2261
                self.printDefaultParameters()
                self.state = 2262
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintDefaultParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def printDefaultParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.PrintDefaultParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.PrintDefaultParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_printDefaultParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintDefaultParameters" ):
                listener.enterPrintDefaultParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintDefaultParameters" ):
                listener.exitPrintDefaultParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintDefaultParameters" ):
                return visitor.visitPrintDefaultParameters(self)
            else:
                return visitor.visitChildren(self)




    def printDefaultParameters(self):

        localctx = WFLParser.PrintDefaultParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_printDefaultParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2274
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==113 or _la==419 or _la==422:
                self.state = 2266
                self.printDefaultParameter()
                self.state = 2271
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 2267
                    self.match(WFLParser.COMMA)
                    self.state = 2268
                    self.printDefaultParameter()
                    self.state = 2273
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintDefaultParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def printAttribute(self):
            return self.getTypedRuleContext(WFLParser.PrintAttributeContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def printAttributeValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.PrintAttributeValueContext)
            else:
                return self.getTypedRuleContext(WFLParser.PrintAttributeValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_printDefaultParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintDefaultParameter" ):
                listener.enterPrintDefaultParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintDefaultParameter" ):
                listener.exitPrintDefaultParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintDefaultParameter" ):
                return visitor.visitPrintDefaultParameter(self)
            else:
                return visitor.visitChildren(self)




    def printDefaultParameter(self):

        localctx = WFLParser.PrintDefaultParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_printDefaultParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2276
            self.printAttribute()
            self.state = 2277
            self.match(WFLParser.EQUAL)
            self.state = 2278
            self.printAttributeValue()
            self.state = 2283
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,205,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2279
                    self.match(WFLParser.COMMA)
                    self.state = 2280
                    self.printAttributeValue() 
                self.state = 2285
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,205,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintAttributeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def realConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.RealConstantExpressionContext,0)


        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_printAttributeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintAttributeValue" ):
                listener.enterPrintAttributeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintAttributeValue" ):
                listener.exitPrintAttributeValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintAttributeValue" ):
                return visitor.visitPrintAttributeValue(self)
            else:
                return visitor.visitChildren(self)




    def printAttributeValue(self):

        localctx = WFLParser.PrintAttributeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_printAttributeValue)
        try:
            self.state = 2294
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2286
                self.match(WFLParser.Num)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2287
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2288
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2289
                self.booleanConstantExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2290
                self.realConstantExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2291
                self.stringConstantExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2292
                self.filePath()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2293
                self.fileReferencedVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DESTINATION(self):
            return self.getToken(WFLParser.DESTINATION, 0)

        def NOTE(self):
            return self.getToken(WFLParser.NOTE, 0)

        def PRINTPARTIAL(self):
            return self.getToken(WFLParser.PRINTPARTIAL, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_printAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintAttribute" ):
                listener.enterPrintAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintAttribute" ):
                listener.exitPrintAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintAttribute" ):
                return visitor.visitPrintAttribute(self)
            else:
                return visitor.visitChildren(self)




    def printAttribute(self):

        localctx = WFLParser.PrintAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_printAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2296
            _la = self._input.LA(1)
            if not(_la==113 or _la==419 or _la==422):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyAndCompareStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COPY(self):
            return self.getToken(WFLParser.COPY, 0)

        def AMPERSAND(self):
            return self.getToken(WFLParser.AMPERSAND, 0)

        def COMPARE(self):
            return self.getToken(WFLParser.COMPARE, 0)

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def fileReferencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileReferencedVariableContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def toClause(self):
            return self.getTypedRuleContext(WFLParser.ToClauseContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_copyAndCompareStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyAndCompareStatement" ):
                listener.enterCopyAndCompareStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyAndCompareStatement" ):
                listener.exitCopyAndCompareStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyAndCompareStatement" ):
                return visitor.visitCopyAndCompareStatement(self)
            else:
                return visitor.visitChildren(self)




    def copyAndCompareStatement(self):

        localctx = WFLParser.CopyAndCompareStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_copyAndCompareStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2298
            self.match(WFLParser.COPY)
            self.state = 2299
            self.match(WFLParser.AMPERSAND)
            self.state = 2300
            self.match(WFLParser.COMPARE)
            self.state = 2304
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
            if la_ == 1:
                self.state = 2302
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2303
                self.fileReferencedVariable()
                pass


            self.state = 2313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2306
                self.match(WFLParser.COMMA)
                self.state = 2309
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
                if la_ == 1:
                    self.state = 2307
                    self.filePath()
                    pass

                elif la_ == 2:
                    self.state = 2308
                    self.fileReferencedVariable()
                    pass


                self.state = 2315
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2317
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 2316
                self.fromClause()


            self.state = 2320
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 2319
                self.toClause()


            self.state = 2326
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2322
                self.match(WFLParser.LS)
                self.state = 2323
                self.taskIdentifier()
                self.state = 2324
                self.match(WFLParser.RS)


            self.state = 2328
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyAndRemoveStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COPY(self):
            return self.getToken(WFLParser.COPY, 0)

        def AMPERSAND(self):
            return self.getToken(WFLParser.AMPERSAND, 0)

        def REMOVE(self):
            return self.getToken(WFLParser.REMOVE, 0)

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def fileReferencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileReferencedVariableContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def toClause(self):
            return self.getTypedRuleContext(WFLParser.ToClauseContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_copyAndRemoveStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyAndRemoveStatement" ):
                listener.enterCopyAndRemoveStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyAndRemoveStatement" ):
                listener.exitCopyAndRemoveStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyAndRemoveStatement" ):
                return visitor.visitCopyAndRemoveStatement(self)
            else:
                return visitor.visitChildren(self)




    def copyAndRemoveStatement(self):

        localctx = WFLParser.CopyAndRemoveStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_copyAndRemoveStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2330
            self.match(WFLParser.COPY)
            self.state = 2331
            self.match(WFLParser.AMPERSAND)
            self.state = 2332
            self.match(WFLParser.REMOVE)
            self.state = 2336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
            if la_ == 1:
                self.state = 2334
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2335
                self.fileReferencedVariable()
                pass


            self.state = 2345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2338
                self.match(WFLParser.COMMA)
                self.state = 2341
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
                if la_ == 1:
                    self.state = 2339
                    self.filePath()
                    pass

                elif la_ == 2:
                    self.state = 2340
                    self.fileReferencedVariable()
                    pass


                self.state = 2347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 2348
                self.fromClause()


            self.state = 2352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 2351
                self.toClause()


            self.state = 2358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2354
                self.match(WFLParser.LS)
                self.state = 2355
                self.taskIdentifier()
                self.state = 2356
                self.match(WFLParser.RS)


            self.state = 2360
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COPY(self):
            return self.getToken(WFLParser.COPY, 0)

        def copyFromClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CopyFromClauseContext)
            else:
                return self.getTypedRuleContext(WFLParser.CopyFromClauseContext,i)


        def QMARK(self):
            return self.getToken(WFLParser.QMARK, 0)

        def copyProtocol(self):
            return self.getTypedRuleContext(WFLParser.CopyProtocolContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def toClause(self):
            return self.getTypedRuleContext(WFLParser.ToClauseContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_copyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyStatement" ):
                listener.enterCopyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyStatement" ):
                listener.exitCopyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyStatement" ):
                return visitor.visitCopyStatement(self)
            else:
                return visitor.visitChildren(self)




    def copyStatement(self):

        localctx = WFLParser.CopyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_copyStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 2362
                self.match(WFLParser.QMARK)


            self.state = 2365
            self.match(WFLParser.COPY)
            self.state = 2367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2366
                self.copyProtocol()


            self.state = 2369
            self.copyFromClause()
            self.state = 2374
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2370
                self.match(WFLParser.COMMA)
                self.state = 2371
                self.copyFromClause()
                self.state = 2376
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2378
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
            if la_ == 1:
                self.state = 2377
                self.toClause()


            self.state = 2384
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,223,self._ctx)
            if la_ == 1:
                self.state = 2380
                self.match(WFLParser.LS)
                self.state = 2381
                self.taskIdentifier()
                self.state = 2382
                self.match(WFLParser.RS)


            self.state = 2387
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,224,self._ctx)
            if la_ == 1:
                self.state = 2386
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyProtocolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_copyProtocol

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyProtocol" ):
                listener.enterCopyProtocol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyProtocol" ):
                listener.exitCopyProtocol(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyProtocol" ):
                return visitor.visitCopyProtocol(self)
            else:
                return visitor.visitChildren(self)




    def copyProtocol(self):

        localctx = WFLParser.CopyProtocolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_copyProtocol)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2389
            self.match(WFLParser.LS)
            self.state = 2390
            self.match(WFLParser.Identifier)
            self.state = 2391
            self.match(WFLParser.RS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyFromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def copyAsClause(self):
            return self.getTypedRuleContext(WFLParser.CopyAsClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_copyFromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyFromClause" ):
                listener.enterCopyFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyFromClause" ):
                listener.exitCopyFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyFromClause" ):
                return visitor.visitCopyFromClause(self)
            else:
                return visitor.visitChildren(self)




    def copyFromClause(self):

        localctx = WFLParser.CopyFromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_copyFromClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,225,self._ctx)
            if la_ == 1:
                self.state = 2393
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2394
                self.fileReferencedVariable()
                pass

            elif la_ == 3:
                self.state = 2395
                self.match(WFLParser.EQUAL)
                pass


            self.state = 2402
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,226,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2398
                    self.match(WFLParser.COMMA)

                    self.state = 2399
                    self.filePath() 
                self.state = 2404
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,226,self._ctx)

            self.state = 2406
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,227,self._ctx)
            if la_ == 1:
                self.state = 2405
                self.copyAsClause()


            self.state = 2409
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 2408
                self.fromClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyAsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AS(self):
            return self.getToken(WFLParser.AS, 0)

        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_copyAsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyAsClause" ):
                listener.enterCopyAsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyAsClause" ):
                listener.exitCopyAsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyAsClause" ):
                return visitor.visitCopyAsClause(self)
            else:
                return visitor.visitChildren(self)




    def copyAsClause(self):

        localctx = WFLParser.CopyAsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_copyAsClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2411
            self.match(WFLParser.AS)
            self.state = 2415
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,229,self._ctx)
            if la_ == 1:
                self.state = 2412
                self.fileReferencedVariable()
                pass

            elif la_ == 2:
                self.state = 2413
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 3:
                self.state = 2414
                self.filePath()
                pass


            self.state = 2422
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                self.state = 2417
                self.match(WFLParser.LP)
                self.state = 2418
                self.match(WFLParser.Identifier)
                self.state = 2419
                self.match(WFLParser.EQUAL)
                self.state = 2420
                self.match(WFLParser.Identifier)
                self.state = 2421
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPILE(self):
            return self.getToken(WFLParser.COMPILE, 0)

        def BIND(self):
            return self.getToken(WFLParser.BIND, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.ON)
            else:
                return self.getToken(WFLParser.ON, i)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def WITH(self):
            return self.getToken(WFLParser.WITH, 0)

        def compilerName(self):
            return self.getTypedRuleContext(WFLParser.CompilerNameContext,0)


        def compilerTitle(self):
            return self.getTypedRuleContext(WFLParser.CompilerTitleContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def taskIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskIdentifierContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def SYNTAX(self):
            return self.getToken(WFLParser.SYNTAX, 0)

        def LIBRARY(self):
            return self.getToken(WFLParser.LIBRARY, 0)

        def GO(self):
            return self.getToken(WFLParser.GO, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def compilerTaskEquationList(self):
            return self.getTypedRuleContext(WFLParser.CompilerTaskEquationListContext,0)


        def familyName(self):
            return self.getTypedRuleContext(WFLParser.FamilyNameContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_compileStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompileStatement" ):
                listener.enterCompileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompileStatement" ):
                listener.exitCompileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompileStatement" ):
                return visitor.visitCompileStatement(self)
            else:
                return visitor.visitChildren(self)




    def compileStatement(self):

        localctx = WFLParser.CompileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_compileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2424
            _la = self._input.LA(1)
            if not(_la==195 or _la==291):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2427
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,231,self._ctx)
            if la_ == 1:
                self.state = 2425
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2426
                self.fileReferencedVariable()
                pass


            self.state = 2431
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,232,self._ctx)
            if la_ == 1:
                self.state = 2429
                self.match(WFLParser.ON)
                self.state = 2430
                self.storageUnit()


            self.state = 2441
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,234,self._ctx)
            if la_ == 1:
                self.state = 2433
                self.match(WFLParser.WITH)
                self.state = 2434
                self.compilerName()
                self.state = 2437
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
                if la_ == 1:
                    self.state = 2435
                    self.match(WFLParser.ON)
                    self.state = 2436
                    self.familyName()



            elif la_ == 2:
                self.state = 2439
                self.match(WFLParser.WITH)
                self.state = 2440
                self.compilerTitle()


            self.state = 2447
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,235,self._ctx)
            if la_ == 1:
                self.state = 2443
                self.match(WFLParser.LP)
                self.state = 2444
                self.taskIdentifier()
                self.state = 2445
                self.match(WFLParser.RP)


            self.state = 2453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,236,self._ctx)
            if la_ == 1:
                self.state = 2449
                self.match(WFLParser.LS)
                self.state = 2450
                self.taskIdentifier()
                self.state = 2451
                self.match(WFLParser.RS)


            self.state = 2460
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,237,self._ctx)
            if la_ == 1:
                self.state = 2455
                self.match(WFLParser.SYNTAX)

            elif la_ == 2:
                self.state = 2456
                self.match(WFLParser.LIBRARY)

            elif la_ == 3:
                self.state = 2457
                self.match(WFLParser.GO)

            elif la_ == 4:
                self.state = 2458
                self.match(WFLParser.LIBRARY)
                self.state = 2459
                self.match(WFLParser.GO)


            self.state = 2463
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
            if la_ == 1:
                self.state = 2462
                self.match(WFLParser.SEMICOLON)


            self.state = 2466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==196:
                self.state = 2465
                self.compilerTaskEquationList()


            self.state = 2469
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,240,self._ctx)
            if la_ == 1:
                self.state = 2468
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompilerTaskEquationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPILER(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMPILER)
            else:
                return self.getToken(WFLParser.COMPILER, i)

        def taskAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,i)


        def fileEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileEquationContext,i)


        def libraryEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.LibraryEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.LibraryEquationContext,i)


        def databaseEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DatabaseEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.DatabaseEquationContext,i)


        def dataDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DataDeclarationContext)
            else:
                return self.getTypedRuleContext(WFLParser.DataDeclarationContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_compilerTaskEquationList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilerTaskEquationList" ):
                listener.enterCompilerTaskEquationList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilerTaskEquationList" ):
                listener.exitCompilerTaskEquationList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilerTaskEquationList" ):
                return visitor.visitCompilerTaskEquationList(self)
            else:
                return visitor.visitChildren(self)




    def compilerTaskEquationList(self):

        localctx = WFLParser.CompilerTaskEquationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_compilerTaskEquationList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2479 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2471
                self.match(WFLParser.COMPILER)
                self.state = 2477
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
                if la_ == 1:
                    self.state = 2472
                    self.taskAttributeAssignment()
                    pass

                elif la_ == 2:
                    self.state = 2473
                    self.fileEquation()
                    pass

                elif la_ == 3:
                    self.state = 2474
                    self.libraryEquation()
                    pass

                elif la_ == 4:
                    self.state = 2475
                    self.databaseEquation()
                    pass

                elif la_ == 5:
                    self.state = 2476
                    self.dataDeclaration()
                    pass


                self.state = 2481 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==196):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LibraryEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIBRARY(self):
            return self.getToken(WFLParser.LIBRARY, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileAttributeAssignmentContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_libraryEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLibraryEquation" ):
                listener.enterLibraryEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLibraryEquation" ):
                listener.exitLibraryEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLibraryEquation" ):
                return visitor.visitLibraryEquation(self)
            else:
                return visitor.visitChildren(self)




    def libraryEquation(self):

        localctx = WFLParser.LibraryEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_libraryEquation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2483
            self.match(WFLParser.LIBRARY)
            self.state = 2484
            self.filePath()
            self.state = 2496
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,244,self._ctx)
            if la_ == 1:
                self.state = 2485
                self.match(WFLParser.LP)
                self.state = 2486
                self.fileAttributeAssignment()
                self.state = 2491
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 2487
                    self.match(WFLParser.COMMA)
                    self.state = 2488
                    self.fileAttributeAssignment()
                    self.state = 2493
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2494
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseEquationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE(self):
            return self.getToken(WFLParser.DATABASE, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileAttributeAssignmentContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_databaseEquation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabaseEquation" ):
                listener.enterDatabaseEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabaseEquation" ):
                listener.exitDatabaseEquation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabaseEquation" ):
                return visitor.visitDatabaseEquation(self)
            else:
                return visitor.visitChildren(self)




    def databaseEquation(self):

        localctx = WFLParser.DatabaseEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_databaseEquation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2498
            self.match(WFLParser.DATABASE)
            self.state = 2499
            self.filePath()
            self.state = 2511
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,246,self._ctx)
            if la_ == 1:
                self.state = 2500
                self.match(WFLParser.LP)
                self.state = 2501
                self.fileAttributeAssignment()
                self.state = 2506
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 2502
                    self.match(WFLParser.COMMA)
                    self.state = 2503
                    self.fileAttributeAssignment()
                    self.state = 2508
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2509
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompilerNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALGOL(self):
            return self.getToken(WFLParser.ALGOL, 0)

        def BINDER(self):
            return self.getToken(WFLParser.BINDER, 0)

        def CC(self):
            return self.getToken(WFLParser.CC, 0)

        def COBOL74(self):
            return self.getToken(WFLParser.COBOL74, 0)

        def COBOL85(self):
            return self.getToken(WFLParser.COBOL85, 0)

        def DCALGOL(self):
            return self.getToken(WFLParser.DCALGOL, 0)

        def DMALGOL(self):
            return self.getToken(WFLParser.DMALGOL, 0)

        def FORTRAN77(self):
            return self.getToken(WFLParser.FORTRAN77, 0)

        def MODULA2(self):
            return self.getToken(WFLParser.MODULA2, 0)

        def NDLII(self):
            return self.getToken(WFLParser.NDLII, 0)

        def NEWP(self):
            return self.getToken(WFLParser.NEWP, 0)

        def PASCAL(self):
            return self.getToken(WFLParser.PASCAL, 0)

        def RPG(self):
            return self.getToken(WFLParser.RPG, 0)

        def SORT(self):
            return self.getToken(WFLParser.SORT, 0)

        def LCOBOL74(self):
            return self.getToken(WFLParser.LCOBOL74, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_compilerName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilerName" ):
                listener.enterCompilerName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilerName" ):
                listener.exitCompilerName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilerName" ):
                return visitor.visitCompilerName(self)
            else:
                return visitor.visitChildren(self)




    def compilerName(self):

        localctx = WFLParser.CompilerNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_compilerName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2513
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 34084860461056) != 0) or ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 1023) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompilerTitleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_compilerTitle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilerTitle" ):
                listener.enterCompilerTitle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilerTitle" ):
                listener.exitCompilerTitle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilerTitle" ):
                return visitor.visitCompilerTitle(self)
            else:
                return visitor.visitChildren(self)




    def compilerTitle(self):

        localctx = WFLParser.CompilerTitleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_compilerTitle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2515
            self.filePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FamilyNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_familyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFamilyName" ):
                listener.enterFamilyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFamilyName" ):
                listener.exitFamilyName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFamilyName" ):
                return visitor.visitFamilyName(self)
            else:
                return visitor.visitChildren(self)




    def familyName(self):

        localctx = WFLParser.FamilyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_familyName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2517
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RunStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def RUN(self):
            return self.getToken(WFLParser.RUN, 0)

        def EXECUTE(self):
            return self.getToken(WFLParser.EXECUTE, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def runParameterList(self):
            return self.getTypedRuleContext(WFLParser.RunParameterListContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def taskIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskIdentifierContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def taskEquationList(self):
            return self.getTypedRuleContext(WFLParser.TaskEquationListContext,0)


        def localDataSpecification(self):
            return self.getTypedRuleContext(WFLParser.LocalDataSpecificationContext,0)


        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_runStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRunStatement" ):
                listener.enterRunStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRunStatement" ):
                listener.exitRunStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRunStatement" ):
                return visitor.visitRunStatement(self)
            else:
                return visitor.visitChildren(self)




    def runStatement(self):

        localctx = WFLParser.RunStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_runStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2519
            _la = self._input.LA(1)
            if not(_la==190 or _la==213):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2522
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,247,self._ctx)
            if la_ == 1:
                self.state = 2520
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 2521
                self.fileReferencedVariable()
                pass


            self.state = 2529
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 2524
                self.match(WFLParser.ON)
                self.state = 2527
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 2525
                    self.storageUnit()
                    pass
                elif token in [201, 209, 211, 219]:
                    self.state = 2526
                    self.reservedKeyword()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 2532
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,250,self._ctx)
            if la_ == 1:
                self.state = 2531
                self.runParameterList()


            self.state = 2538
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 2534
                self.match(WFLParser.LP)
                self.state = 2535
                self.taskIdentifier()
                self.state = 2536
                self.match(WFLParser.RP)


            self.state = 2541
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,252,self._ctx)
            if la_ == 1:
                self.state = 2540
                self.match(WFLParser.SEMICOLON)


            self.state = 2547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2543
                self.match(WFLParser.LS)
                self.state = 2544
                self.taskIdentifier()
                self.state = 2545
                self.match(WFLParser.RS)


            self.state = 2549
            self.match(WFLParser.SEMICOLON)
            self.state = 2551
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
            if la_ == 1:
                self.state = 2550
                self.taskEquationList()


            self.state = 2554
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,255,self._ctx)
            if la_ == 1:
                self.state = 2553
                self.localDataSpecification()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalDataSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EBCDIC(self):
            return self.getToken(WFLParser.EBCDIC, 0)

        def CARD(self):
            return self.getToken(WFLParser.CARD, 0)

        def FILES(self):
            return self.getToken(WFLParser.FILES, 0)

        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def FROM(self):
            return self.getToken(WFLParser.FROM, 0)

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def LOCKDECK(self):
            return self.getToken(WFLParser.LOCKDECK, 0)

        def DECKLABEL(self):
            return self.getToken(WFLParser.DECKLABEL, 0)

        def JOBSYMBOL(self):
            return self.getToken(WFLParser.JOBSYMBOL, 0)

        def NOSUMMARY(self):
            return self.getToken(WFLParser.NOSUMMARY, 0)

        def CLASS(self):
            return self.getToken(WFLParser.CLASS, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def TASKFAULT(self):
            return self.getToken(WFLParser.TASKFAULT, 0)

        def QMARK(self):
            return self.getToken(WFLParser.QMARK, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def date(self):
            return self.getTypedRuleContext(WFLParser.DateContext,0)


        def ALL(self):
            return self.getToken(WFLParser.ALL, 0)

        def fileAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileAttributeAssignmentContext,i)


        def excludeClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ExcludeClauseContext)
            else:
                return self.getTypedRuleContext(WFLParser.ExcludeClauseContext,i)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def NOZ(self):
            return self.getToken(WFLParser.NOZ, 0)

        def ACCESSED(self):
            return self.getToken(WFLParser.ACCESSED, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def BEFORE(self):
            return self.getToken(WFLParser.BEFORE, 0)

        def AFTER(self):
            return self.getToken(WFLParser.AFTER, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def dataDeclaration(self):
            return self.getTypedRuleContext(WFLParser.DataDeclarationContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_localDataSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalDataSpecification" ):
                listener.enterLocalDataSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalDataSpecification" ):
                listener.exitLocalDataSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocalDataSpecification" ):
                return visitor.visitLocalDataSpecification(self)
            else:
                return visitor.visitChildren(self)




    def localDataSpecification(self):

        localctx = WFLParser.LocalDataSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_localDataSpecification)
        self._la = 0 # Token type
        try:
            self.state = 2617
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [206]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2556
                self.match(WFLParser.EBCDIC)
                self.state = 2557
                self.match(WFLParser.CARD)
                self.state = 2561
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==52 or _la==446:
                    self.state = 2558
                    _la = self._input.LA(1)
                    if not(_la==52 or _la==446):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2559
                    _la = self._input.LA(1)
                    if not(_la==53 or _la==418):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2560
                    self.date()


                self.state = 2564
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==80:
                    self.state = 2563
                    self.match(WFLParser.ALL)


                self.state = 2566
                self.match(WFLParser.FILES)
                self.state = 2567
                self.match(WFLParser.LP)
                self.state = 2570
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,258,self._ctx)
                if la_ == 1:
                    self.state = 2568
                    self.filePath()
                    pass

                elif la_ == 2:
                    self.state = 2569
                    self.match(WFLParser.EQUAL)
                    pass


                self.state = 2572
                self.match(WFLParser.FROM)
                self.state = 2573
                self.filePath()
                self.state = 2574
                self.match(WFLParser.RP)
                self.state = 2575
                self.match(WFLParser.TO)
                self.state = 2576
                self.filePath()
                self.state = 2590
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==12:
                    self.state = 2577
                    self.match(WFLParser.LP)
                    self.state = 2578
                    self.fileAttributeAssignment()
                    self.state = 2583
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==4:
                        self.state = 2579
                        self.match(WFLParser.COMMA)
                        self.state = 2580
                        self.fileAttributeAssignment()
                        self.state = 2585
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 2586
                    self.match(WFLParser.RP)
                    self.state = 2592
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2596
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==244:
                    self.state = 2593
                    self.excludeClause()
                    self.state = 2598
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2599
                self.match(WFLParser.LOCKDECK)
                self.state = 2600
                self.match(WFLParser.DECKLABEL)
                self.state = 2601
                self.filePath()
                self.state = 2604
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==253:
                    self.state = 2602
                    self.match(WFLParser.ON)
                    self.state = 2603
                    self.storageUnit()


                self.state = 2606
                self.match(WFLParser.JOBSYMBOL)
                self.state = 2607
                self.match(WFLParser.NOSUMMARY)
                self.state = 2608
                self.match(WFLParser.CLASS)
                self.state = 2609
                self.match(WFLParser.Num)
                self.state = 2610
                self.match(WFLParser.TASKFAULT)
                self.state = 2612
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==72:
                    self.state = 2611
                    self.match(WFLParser.NOZ)


                self.state = 2614
                self.match(WFLParser.QMARK)
                pass
            elif token in [22, 200]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2616
                self.dataDeclaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExcludeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLUDE(self):
            return self.getToken(WFLParser.EXCLUDE, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def FILEKIND(self):
            return self.getToken(WFLParser.FILEKIND, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def charDataKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CharDataKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,i)


        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.FROM)
            else:
                return self.getToken(WFLParser.FROM, i)

        def storageUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StorageUnitContext)
            else:
                return self.getTypedRuleContext(WFLParser.StorageUnitContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_excludeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExcludeClause" ):
                listener.enterExcludeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExcludeClause" ):
                listener.exitExcludeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExcludeClause" ):
                return visitor.visitExcludeClause(self)
            else:
                return visitor.visitChildren(self)




    def excludeClause(self):

        localctx = WFLParser.ExcludeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_excludeClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2619
            self.match(WFLParser.EXCLUDE)
            self.state = 2621
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==104:
                self.state = 2620
                self.match(WFLParser.FILEKIND)


            self.state = 2623
            self.match(WFLParser.LP)

            self.state = 2631
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,267,self._ctx)
            if la_ == 1:
                self.state = 2624
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 2625
                self.charDataKeyword()
                pass

            elif la_ == 3:
                self.state = 2626
                self.filePath()
                self.state = 2629
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==216:
                    self.state = 2627
                    self.match(WFLParser.FROM)
                    self.state = 2628
                    self.storageUnit()


                pass


            self.state = 2645
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2633
                self.match(WFLParser.COMMA)
                self.state = 2641
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,269,self._ctx)
                if la_ == 1:
                    self.state = 2634
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 2:
                    self.state = 2635
                    self.charDataKeyword()
                    pass

                elif la_ == 3:
                    self.state = 2636
                    self.filePath()
                    self.state = 2639
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==216:
                        self.state = 2637
                        self.match(WFLParser.FROM)
                        self.state = 2638
                        self.storageUnit()


                    pass


                self.state = 2647
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2648
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RunParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def runParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.RunParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.RunParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_runParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRunParameterList" ):
                listener.enterRunParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRunParameterList" ):
                listener.exitRunParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRunParameterList" ):
                return visitor.visitRunParameterList(self)
            else:
                return visitor.visitChildren(self)




    def runParameterList(self):

        localctx = WFLParser.RunParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_runParameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2650
            self.match(WFLParser.LP)
            self.state = 2659
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -1193242795020382204) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & 1162210178972516359) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & -5132357677434780511) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & 4538828987859453) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 833165931065641073) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 3026190337) != 0):
                self.state = 2651
                self.runParameter()
                self.state = 2656
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 2652
                    self.match(WFLParser.COMMA)
                    self.state = 2653
                    self.runParameter()
                    self.state = 2658
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 2661
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RunParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def REFERENCE(self):
            return self.getToken(WFLParser.REFERENCE, 0)

        def MYJOB(self):
            return self.getToken(WFLParser.MYJOB, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def NAME(self):
            return self.getToken(WFLParser.NAME, 0)

        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_runParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRunParameter" ):
                listener.enterRunParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRunParameter" ):
                listener.exitRunParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRunParameter" ):
                return visitor.visitRunParameter(self)
            else:
                return visitor.visitChildren(self)




    def runParameter(self):

        localctx = WFLParser.RunParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_runParameter)
        try:
            self.state = 2674
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,273,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2663
                self.realExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2664
                self.integerExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2665
                self.booleanConstantExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2666
                self.stringExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2667
                self.match(WFLParser.Identifier)
                self.state = 2668
                self.match(WFLParser.REFERENCE)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2669
                self.match(WFLParser.MYJOB)
                self.state = 2670
                self.match(WFLParser.LP)

                self.state = 2671
                self.match(WFLParser.NAME)
                self.state = 2672
                self.match(WFLParser.RP)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2673
                self.fileReferencedVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Num)
            else:
                return self.getToken(WFLParser.Num, i)

        def DOT(self):
            return self.getToken(WFLParser.DOT, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealExpression" ):
                listener.enterRealExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealExpression" ):
                listener.exitRealExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealExpression" ):
                return visitor.visitRealExpression(self)
            else:
                return visitor.visitChildren(self)




    def realExpression(self):

        localctx = WFLParser.RealExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_realExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2676
            self.match(WFLParser.Num)
            self.state = 2679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 2677
                self.match(WFLParser.DOT)
                self.state = 2678
                self.match(WFLParser.Num)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def calcExpression(self):
            return self.getTypedRuleContext(WFLParser.CalcExpressionContext,0)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def integerTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.IntegerTaskAttributeContext,0)


        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def integerMethod(self):
            return self.getTypedRuleContext(WFLParser.IntegerMethodContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_integerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerExpression" ):
                listener.enterIntegerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerExpression" ):
                listener.exitIntegerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerExpression" ):
                return visitor.visitIntegerExpression(self)
            else:
                return visitor.visitChildren(self)




    def integerExpression(self):

        localctx = WFLParser.IntegerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_integerExpression)
        try:
            self.state = 2693
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,276,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2681
                self.match(WFLParser.Num)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2682
                self.calcExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2683
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2684
                self.taskIdentifier()
                self.state = 2685
                self.match(WFLParser.LP)
                self.state = 2688
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,275,self._ctx)
                if la_ == 1:
                    self.state = 2686
                    self.integerTaskAttribute()
                    pass

                elif la_ == 2:
                    self.state = 2687
                    self.taskAttribute()
                    pass


                self.state = 2690
                self.match(WFLParser.RP)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2692
                self.integerMethod()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerIntegerMethod(self):
            return self.getTypedRuleContext(WFLParser.IntegerIntegerMethodContext,0)


        def myselfMethod(self):
            return self.getTypedRuleContext(WFLParser.MyselfMethodContext,0)


        def myjobMethod(self):
            return self.getTypedRuleContext(WFLParser.MyjobMethodContext,0)


        def otherIntegerMethod(self):
            return self.getTypedRuleContext(WFLParser.OtherIntegerMethodContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_integerMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerMethod" ):
                listener.enterIntegerMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerMethod" ):
                listener.exitIntegerMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerMethod" ):
                return visitor.visitIntegerMethod(self)
            else:
                return visitor.visitChildren(self)




    def integerMethod(self):

        localctx = WFLParser.IntegerMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_integerMethod)
        try:
            self.state = 2699
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [64, 232]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2695
                self.integerIntegerMethod()
                pass
            elif token in [396]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2696
                self.myselfMethod()
                pass
            elif token in [395]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2697
                self.myjobMethod()
                pass
            elif token in [446]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2698
                self.otherIntegerMethod()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherIntegerMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_otherIntegerMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOtherIntegerMethod" ):
                listener.enterOtherIntegerMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOtherIntegerMethod" ):
                listener.exitOtherIntegerMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOtherIntegerMethod" ):
                return visitor.visitOtherIntegerMethod(self)
            else:
                return visitor.visitChildren(self)




    def otherIntegerMethod(self):

        localctx = WFLParser.OtherIntegerMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_otherIntegerMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2701
            self.match(WFLParser.Identifier)
            self.state = 2702
            self.match(WFLParser.LP)
            self.state = 2705
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,278,self._ctx)
            if la_ == 1:
                self.state = 2703
                self.integerExpression()
                pass

            elif la_ == 2:
                self.state = 2704
                self.stringExpression()
                pass


            self.state = 2707
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerIntegerMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(WFLParser.INTEGER, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def DECIMAL(self):
            return self.getToken(WFLParser.DECIMAL, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_integerIntegerMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerIntegerMethod" ):
                listener.enterIntegerIntegerMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerIntegerMethod" ):
                listener.exitIntegerIntegerMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerIntegerMethod" ):
                return visitor.visitIntegerIntegerMethod(self)
            else:
                return visitor.visitChildren(self)




    def integerIntegerMethod(self):

        localctx = WFLParser.IntegerIntegerMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_integerIntegerMethod)
        try:
            self.state = 2719
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [232]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2709
                self.match(WFLParser.INTEGER)
                self.state = 2710
                self.match(WFLParser.LP)
                self.state = 2711
                self.integerExpression()
                self.state = 2712
                self.match(WFLParser.RP)
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2714
                self.match(WFLParser.DECIMAL)
                self.state = 2715
                self.match(WFLParser.LP)
                self.state = 2716
                self.stringExpression()
                self.state = 2717
                self.match(WFLParser.RP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalcExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def calcExpressionTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CalcExpressionTermContext)
            else:
                return self.getTypedRuleContext(WFLParser.CalcExpressionTermContext,i)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.PLUS)
            else:
                return self.getToken(WFLParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.MINUS)
            else:
                return self.getToken(WFLParser.MINUS, i)

        def getRuleIndex(self):
            return WFLParser.RULE_calcExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCalcExpression" ):
                listener.enterCalcExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCalcExpression" ):
                listener.exitCalcExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalcExpression" ):
                return visitor.visitCalcExpression(self)
            else:
                return visitor.visitChildren(self)




    def calcExpression(self):

        localctx = WFLParser.CalcExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_calcExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2722
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,280,self._ctx)
            if la_ == 1:
                self.state = 2721
                self.match(WFLParser.LP)


            self.state = 2724
            self.calcExpressionTerm()
            self.state = 2729
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==25 or _la==26:
                self.state = 2725
                _la = self._input.LA(1)
                if not(_la==25 or _la==26):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2726
                self.calcExpressionTerm()
                self.state = 2731
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2733
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,282,self._ctx)
            if la_ == 1:
                self.state = 2732
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalcExpressionTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def calcExpressionFactor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CalcExpressionFactorContext)
            else:
                return self.getTypedRuleContext(WFLParser.CalcExpressionFactorContext,i)


        def STAR(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.STAR)
            else:
                return self.getToken(WFLParser.STAR, i)

        def SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SLASH)
            else:
                return self.getToken(WFLParser.SLASH, i)

        def MOD(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.MOD)
            else:
                return self.getToken(WFLParser.MOD, i)

        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.DIV)
            else:
                return self.getToken(WFLParser.DIV, i)

        def getRuleIndex(self):
            return WFLParser.RULE_calcExpressionTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCalcExpressionTerm" ):
                listener.enterCalcExpressionTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCalcExpressionTerm" ):
                listener.exitCalcExpressionTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalcExpressionTerm" ):
                return visitor.visitCalcExpressionTerm(self)
            else:
                return visitor.visitChildren(self)




    def calcExpressionTerm(self):

        localctx = WFLParser.CalcExpressionTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_calcExpressionTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2735
            self.calcExpressionFactor()
            self.state = 2740
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,283,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2736
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 140737891008512) != 0) or _la==312):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2737
                    self.calcExpressionFactor() 
                self.state = 2742
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,283,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalcExpressionFactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def integerMethod(self):
            return self.getTypedRuleContext(WFLParser.IntegerMethodContext,0)


        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def calcExpression(self):
            return self.getTypedRuleContext(WFLParser.CalcExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_calcExpressionFactor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCalcExpressionFactor" ):
                listener.enterCalcExpressionFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCalcExpressionFactor" ):
                listener.exitCalcExpressionFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalcExpressionFactor" ):
                return visitor.visitCalcExpressionFactor(self)
            else:
                return visitor.visitChildren(self)




    def calcExpressionFactor(self):

        localctx = WFLParser.CalcExpressionFactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_calcExpressionFactor)
        try:
            self.state = 2755
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,284,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2743
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2744
                self.match(WFLParser.Num)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2745
                self.integerMethod()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2746
                self.taskIdentifier()
                self.state = 2747
                self.match(WFLParser.LP)
                self.state = 2748
                self.taskAttribute()
                self.state = 2749
                self.match(WFLParser.RP)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2751
                self.match(WFLParser.LP)
                self.state = 2752
                self.calcExpression()
                self.state = 2753
                self.match(WFLParser.RP)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def stringIdentifier(self):
            return self.getTypedRuleContext(WFLParser.StringIdentifierContext,0)


        def stringMethod(self):
            return self.getTypedRuleContext(WFLParser.StringMethodContext,0)


        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = WFLParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_stringExpression)
        try:
            self.state = 2761
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,285,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2757
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2758
                self.stringIdentifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2759
                self.stringMethod()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2760
                self.match(WFLParser.EMPTYSTRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def headMethod(self):
            return self.getTypedRuleContext(WFLParser.HeadMethodContext,0)


        def tailMethod(self):
            return self.getTypedRuleContext(WFLParser.TailMethodContext,0)


        def concatMethod(self):
            return self.getTypedRuleContext(WFLParser.ConcatMethodContext,0)


        def stringStringMethod(self):
            return self.getTypedRuleContext(WFLParser.StringStringMethodContext,0)


        def subStringMethod(self):
            return self.getTypedRuleContext(WFLParser.SubStringMethodContext,0)


        def takeMethod(self):
            return self.getTypedRuleContext(WFLParser.TakeMethodContext,0)


        def dropMethod(self):
            return self.getTypedRuleContext(WFLParser.DropMethodContext,0)


        def myselfMethod(self):
            return self.getTypedRuleContext(WFLParser.MyselfMethodContext,0)


        def timeDateMethod(self):
            return self.getTypedRuleContext(WFLParser.TimeDateMethodContext,0)


        def acceptMethod(self):
            return self.getTypedRuleContext(WFLParser.AcceptMethodContext,0)


        def otherStringMethod(self):
            return self.getTypedRuleContext(WFLParser.OtherStringMethodContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_stringMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringMethod" ):
                listener.enterStringMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringMethod" ):
                listener.exitStringMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringMethod" ):
                return visitor.visitStringMethod(self)
            else:
                return visitor.visitChildren(self)




    def stringMethod(self):

        localctx = WFLParser.StringMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_stringMethod)
        try:
            self.state = 2774
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,286,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2763
                self.headMethod()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2764
                self.tailMethod()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2765
                self.concatMethod()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2766
                self.stringStringMethod()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2767
                self.subStringMethod()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2768
                self.takeMethod()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2769
                self.dropMethod()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2770
                self.myselfMethod()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2771
                self.timeDateMethod()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2772
                self.acceptMethod()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2773
                self.otherStringMethod()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherStringMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def fileAttribute(self):
            return self.getTypedRuleContext(WFLParser.FileAttributeContext,0)


        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_otherStringMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOtherStringMethod" ):
                listener.enterOtherStringMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOtherStringMethod" ):
                listener.exitOtherStringMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOtherStringMethod" ):
                return visitor.visitOtherStringMethod(self)
            else:
                return visitor.visitChildren(self)




    def otherStringMethod(self):

        localctx = WFLParser.OtherStringMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_otherStringMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2776
            self.match(WFLParser.Identifier)
            self.state = 2777
            self.match(WFLParser.LP)
            self.state = 2781
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
            if la_ == 1:
                self.state = 2778
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 2779
                self.fileAttribute()
                pass

            elif la_ == 3:
                self.state = 2780
                self.taskAttribute()
                pass


            self.state = 2783
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AcceptMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCEPT(self):
            return self.getToken(WFLParser.ACCEPT, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_acceptMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceptMethod" ):
                listener.enterAcceptMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceptMethod" ):
                listener.exitAcceptMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAcceptMethod" ):
                return visitor.visitAcceptMethod(self)
            else:
                return visitor.visitChildren(self)




    def acceptMethod(self):

        localctx = WFLParser.AcceptMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_acceptMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2785
            self.match(WFLParser.ACCEPT)
            self.state = 2786
            self.match(WFLParser.LP)
            self.state = 2787
            self.stringExpression()
            self.state = 2788
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeDateMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIMEDATE(self):
            return self.getToken(WFLParser.TIMEDATE, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def timeDateParameter(self):
            return self.getTypedRuleContext(WFLParser.TimeDateParameterContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_timeDateMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeDateMethod" ):
                listener.enterTimeDateMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeDateMethod" ):
                listener.exitTimeDateMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeDateMethod" ):
                return visitor.visitTimeDateMethod(self)
            else:
                return visitor.visitChildren(self)




    def timeDateMethod(self):

        localctx = WFLParser.TimeDateMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_timeDateMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2790
            self.match(WFLParser.TIMEDATE)
            self.state = 2791
            self.match(WFLParser.LP)
            self.state = 2792
            self.timeDateParameter()
            self.state = 2793
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeDateParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YYMMDD(self):
            return self.getToken(WFLParser.YYMMDD, 0)

        def HHMMSS(self):
            return self.getToken(WFLParser.HHMMSS, 0)

        def YYYYMMDD(self):
            return self.getToken(WFLParser.YYYYMMDD, 0)

        def MMDDYY(self):
            return self.getToken(WFLParser.MMDDYY, 0)

        def MMDDYYYY(self):
            return self.getToken(WFLParser.MMDDYYYY, 0)

        def DAYNUMBER(self):
            return self.getToken(WFLParser.DAYNUMBER, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def YYYYMMDDHHMMSS(self):
            return self.getToken(WFLParser.YYYYMMDDHHMMSS, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_timeDateParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeDateParameter" ):
                listener.enterTimeDateParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeDateParameter" ):
                listener.exitTimeDateParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeDateParameter" ):
                return visitor.visitTimeDateParameter(self)
            else:
                return visitor.visitChildren(self)




    def timeDateParameter(self):

        localctx = WFLParser.TimeDateParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_timeDateParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2795
            _la = self._input.LA(1)
            if not(((((_la - 123)) & ~0x3f) == 0 and ((1 << (_la - 123)) & 191) != 0) or _la==449):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MyselfMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MYSELF(self):
            return self.getToken(WFLParser.MYSELF, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def HOSTNAME(self):
            return self.getToken(WFLParser.HOSTNAME, 0)

        def JOBNUMBER(self):
            return self.getToken(WFLParser.JOBNUMBER, 0)

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_myselfMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMyselfMethod" ):
                listener.enterMyselfMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMyselfMethod" ):
                listener.exitMyselfMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMyselfMethod" ):
                return visitor.visitMyselfMethod(self)
            else:
                return visitor.visitChildren(self)




    def myselfMethod(self):

        localctx = WFLParser.MyselfMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_myselfMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2797
            self.match(WFLParser.MYSELF)
            self.state = 2798
            self.match(WFLParser.LP)
            self.state = 2803
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,288,self._ctx)
            if la_ == 1:
                self.state = 2799
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 2800
                self.match(WFLParser.HOSTNAME)
                pass

            elif la_ == 3:
                self.state = 2801
                self.match(WFLParser.JOBNUMBER)
                pass

            elif la_ == 4:
                self.state = 2802
                self.taskAttribute()
                pass


            self.state = 2805
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MyjobMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MYJOB(self):
            return self.getToken(WFLParser.MYJOB, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def HOSTNAME(self):
            return self.getToken(WFLParser.HOSTNAME, 0)

        def JOBNUMBER(self):
            return self.getToken(WFLParser.JOBNUMBER, 0)

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_myjobMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMyjobMethod" ):
                listener.enterMyjobMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMyjobMethod" ):
                listener.exitMyjobMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMyjobMethod" ):
                return visitor.visitMyjobMethod(self)
            else:
                return visitor.visitChildren(self)




    def myjobMethod(self):

        localctx = WFLParser.MyjobMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_myjobMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2807
            self.match(WFLParser.MYJOB)
            self.state = 2808
            self.match(WFLParser.LP)
            self.state = 2813
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,289,self._ctx)
            if la_ == 1:
                self.state = 2809
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 2810
                self.match(WFLParser.HOSTNAME)
                pass

            elif la_ == 3:
                self.state = 2811
                self.match(WFLParser.JOBNUMBER)
                pass

            elif la_ == 4:
                self.state = 2812
                self.taskAttribute()
                pass


            self.state = 2815
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TakeMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TAKE(self):
            return self.getToken(WFLParser.TAKE, 0)

        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_takeMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTakeMethod" ):
                listener.enterTakeMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTakeMethod" ):
                listener.exitTakeMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTakeMethod" ):
                return visitor.visitTakeMethod(self)
            else:
                return visitor.visitChildren(self)




    def takeMethod(self):

        localctx = WFLParser.TakeMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_takeMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2817
            self.match(WFLParser.TAKE)
            self.state = 2818
            self.match(WFLParser.LP)

            self.state = 2820
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 2819
                self.match(WFLParser.LP)


            self.state = 2822
            self.stringExpression()
            self.state = 2824
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 2823
                self.match(WFLParser.RP)


            self.state = 2826
            self.match(WFLParser.COMMA)
            self.state = 2827
            self.integerExpression()
            self.state = 2828
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DropMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP(self):
            return self.getToken(WFLParser.DROP, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_dropMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDropMethod" ):
                listener.enterDropMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDropMethod" ):
                listener.exitDropMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropMethod" ):
                return visitor.visitDropMethod(self)
            else:
                return visitor.visitChildren(self)




    def dropMethod(self):

        localctx = WFLParser.DropMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_dropMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2830
            self.match(WFLParser.DROP)
            self.state = 2831
            self.match(WFLParser.LP)
            self.state = 2832
            self.stringExpression()
            self.state = 2833
            self.match(WFLParser.COMMA)
            self.state = 2834
            self.integerExpression()
            self.state = 2835
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubStringMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def stringIdentifier(self):
            return self.getTypedRuleContext(WFLParser.StringIdentifierContext,0)


        def MYJOB(self):
            return self.getToken(WFLParser.MYJOB, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subStringMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubStringMethod" ):
                listener.enterSubStringMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubStringMethod" ):
                listener.exitSubStringMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubStringMethod" ):
                return visitor.visitSubStringMethod(self)
            else:
                return visitor.visitChildren(self)




    def subStringMethod(self):

        localctx = WFLParser.SubStringMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_subStringMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2839
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444, 446]:
                self.state = 2837
                self.stringIdentifier()
                pass
            elif token in [395]:
                self.state = 2838
                self.match(WFLParser.MYJOB)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2841
            self.match(WFLParser.LP)
            self.state = 2845
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
            if la_ == 1:
                self.state = 2842
                self.integerExpression()
                pass

            elif la_ == 2:
                self.state = 2843
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 3:
                self.state = 2844
                self.taskAttribute()
                pass


            self.state = 2847
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringStringMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def integerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.IntegerExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,i)


        def STAR(self):
            return self.getToken(WFLParser.STAR, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringStringMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringStringMethod" ):
                listener.enterStringStringMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringStringMethod" ):
                listener.exitStringStringMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringStringMethod" ):
                return visitor.visitStringStringMethod(self)
            else:
                return visitor.visitChildren(self)




    def stringStringMethod(self):

        localctx = WFLParser.StringStringMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_stringStringMethod)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2849
            self.match(WFLParser.STRING)
            self.state = 2850
            self.match(WFLParser.LP)
            self.state = 2853
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,294,self._ctx)
            if la_ == 1:
                self.state = 2851
                self.stringExpression()
                pass

            elif la_ == 2:
                self.state = 2852
                self.integerExpression()
                pass


            self.state = 2855
            self.match(WFLParser.COMMA)
            self.state = 2858
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [12, 64, 232, 395, 396, 446, 447]:
                self.state = 2856
                self.integerExpression()
                pass
            elif token in [28]:
                self.state = 2857
                self.match(WFLParser.STAR)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2860
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HeadMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEAD(self):
            return self.getToken(WFLParser.HEAD, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def headParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.HeadParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.HeadParameterContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_headMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeadMethod" ):
                listener.enterHeadMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeadMethod" ):
                listener.exitHeadMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeadMethod" ):
                return visitor.visitHeadMethod(self)
            else:
                return visitor.visitChildren(self)




    def headMethod(self):

        localctx = WFLParser.HeadMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_headMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2862
            self.match(WFLParser.HEAD)
            self.state = 2863
            self.match(WFLParser.LP)
            self.state = 2864
            self.headParameter()
            self.state = 2869
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2865
                self.match(WFLParser.COMMA)
                self.state = 2866
                self.headParameter()
                self.state = 2871
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2872
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HeadParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def NOT(self):
            return self.getToken(WFLParser.NOT, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_headParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeadParameter" ):
                listener.enterHeadParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeadParameter" ):
                listener.exitHeadParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeadParameter" ):
                return visitor.visitHeadParameter(self)
            else:
                return visitor.visitChildren(self)




    def headParameter(self):

        localctx = WFLParser.HeadParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_headParameter)
        self._la = 0 # Token type
        try:
            self.state = 2879
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2874
                self.match(WFLParser.Identifier)
                pass
            elif token in [441, 449]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2876
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==441:
                    self.state = 2875
                    self.match(WFLParser.NOT)


                self.state = 2878
                self.match(WFLParser.LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TailMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TAIL(self):
            return self.getToken(WFLParser.TAIL, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def tailParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TailParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.TailParameterContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_tailMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTailMethod" ):
                listener.enterTailMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTailMethod" ):
                listener.exitTailMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTailMethod" ):
                return visitor.visitTailMethod(self)
            else:
                return visitor.visitChildren(self)




    def tailMethod(self):

        localctx = WFLParser.TailMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_tailMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2881
            self.match(WFLParser.TAIL)
            self.state = 2882
            self.match(WFLParser.LP)
            self.state = 2883
            self.tailParameter()
            self.state = 2888
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 2884
                self.match(WFLParser.COMMA)
                self.state = 2885
                self.tailParameter()
                self.state = 2890
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2891
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TailParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def NOT(self):
            return self.getToken(WFLParser.NOT, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_tailParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTailParameter" ):
                listener.enterTailParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTailParameter" ):
                listener.exitTailParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTailParameter" ):
                return visitor.visitTailParameter(self)
            else:
                return visitor.visitChildren(self)




    def tailParameter(self):

        localctx = WFLParser.TailParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_tailParameter)
        self._la = 0 # Token type
        try:
            self.state = 2898
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2893
                self.match(WFLParser.Identifier)
                pass
            elif token in [441, 449]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2895
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==441:
                    self.state = 2894
                    self.match(WFLParser.NOT)


                self.state = 2897
                self.match(WFLParser.LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConcatMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringIdentifier(self):
            return self.getTypedRuleContext(WFLParser.StringIdentifierContext,0)


        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def timeDateMethod(self):
            return self.getTypedRuleContext(WFLParser.TimeDateMethodContext,0)


        def takeMethod(self):
            return self.getTypedRuleContext(WFLParser.TakeMethodContext,0)


        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def stringStringMethod(self):
            return self.getTypedRuleContext(WFLParser.StringStringMethodContext,0)


        def dropMethod(self):
            return self.getTypedRuleContext(WFLParser.DropMethodContext,0)


        def AMPERSAND(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.AMPERSAND)
            else:
                return self.getToken(WFLParser.AMPERSAND, i)

        def SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SLASH)
            else:
                return self.getToken(WFLParser.SLASH, i)

        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.StringExpressionContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_concatMethod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatMethod" ):
                listener.enterConcatMethod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatMethod" ):
                listener.exitConcatMethod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatMethod" ):
                return visitor.visitConcatMethod(self)
            else:
                return visitor.visitChildren(self)




    def concatMethod(self):

        localctx = WFLParser.ConcatMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_concatMethod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2907
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,302,self._ctx)
            if la_ == 1:
                self.state = 2900
                self.stringIdentifier()
                pass

            elif la_ == 2:
                self.state = 2901
                self.match(WFLParser.LITERAL)
                pass

            elif la_ == 3:
                self.state = 2902
                self.timeDateMethod()
                pass

            elif la_ == 4:
                self.state = 2903
                self.takeMethod()
                pass

            elif la_ == 5:
                self.state = 2904
                self.match(WFLParser.EMPTYSTRING)
                pass

            elif la_ == 6:
                self.state = 2905
                self.stringStringMethod()
                pass

            elif la_ == 7:
                self.state = 2906
                self.dropMethod()
                pass


            self.state = 2911 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2909
                    _la = self._input.LA(1)
                    if not(_la==1 or _la==27):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                    self.state = 2910
                    self.stringExpression()

                else:
                    raise NoViableAltException(self)
                self.state = 2913 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,303,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskEquationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,i)


        def fileEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileEquationContext,i)


        def libraryEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.LibraryEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.LibraryEquationContext,i)


        def databaseEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.DatabaseEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.DatabaseEquationContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_taskEquationList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskEquationList" ):
                listener.enterTaskEquationList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskEquationList" ):
                listener.exitTaskEquationList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskEquationList" ):
                return visitor.visitTaskEquationList(self)
            else:
                return visitor.visitChildren(self)




    def taskEquationList(self):

        localctx = WFLParser.TaskEquationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_taskEquationList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2919 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2919
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,304,self._ctx)
                    if la_ == 1:
                        self.state = 2915
                        self.taskAttributeAssignment()
                        pass

                    elif la_ == 2:
                        self.state = 2916
                        self.fileEquation()
                        pass

                    elif la_ == 3:
                        self.state = 2917
                        self.libraryEquation()
                        pass

                    elif la_ == 4:
                        self.state = 2918
                        self.databaseEquation()
                        pass



                else:
                    raise NoViableAltException(self)
                self.state = 2921 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,305,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(WFLParser.DISPLAY, 0)

        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_displayStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayStatement" ):
                listener.enterDisplayStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayStatement" ):
                listener.exitDisplayStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayStatement" ):
                return visitor.visitDisplayStatement(self)
            else:
                return visitor.visitChildren(self)




    def displayStatement(self):

        localctx = WFLParser.DisplayStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_displayStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2923
            self.match(WFLParser.DISPLAY)
            self.state = 2925
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 2924
                self.match(WFLParser.LP)


            self.state = 2927
            self.stringConstantExpression()
            self.state = 2929
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 2928
                self.match(WFLParser.RP)


            self.state = 2932
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,308,self._ctx)
            if la_ == 1:
                self.state = 2931
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitializeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIALIZE(self):
            return self.getToken(WFLParser.INITIALIZE, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_initializeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitializeStatement" ):
                listener.enterInitializeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitializeStatement" ):
                listener.exitInitializeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitializeStatement" ):
                return visitor.visitInitializeStatement(self)
            else:
                return visitor.visitChildren(self)




    def initializeStatement(self):

        localctx = WFLParser.InitializeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_initializeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2934
            self.match(WFLParser.INITIALIZE)
            self.state = 2935
            self.match(WFLParser.LP)
            self.state = 2936
            self.taskIdentifier()
            self.state = 2937
            self.match(WFLParser.RP)
            self.state = 2938
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AbortStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABORT(self):
            return self.getToken(WFLParser.ABORT, 0)

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def MYSELF(self):
            return self.getToken(WFLParser.MYSELF, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_abortStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbortStatement" ):
                listener.enterAbortStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbortStatement" ):
                listener.exitAbortStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbortStatement" ):
                return visitor.visitAbortStatement(self)
            else:
                return visitor.visitChildren(self)




    def abortStatement(self):

        localctx = WFLParser.AbortStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_abortStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2940
            self.match(WFLParser.ABORT)
            self.state = 2947
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 2941
                self.match(WFLParser.LS)
                self.state = 2944
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 2942
                    self.taskIdentifier()
                    pass
                elif token in [396]:
                    self.state = 2943
                    self.match(WFLParser.MYSELF)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2946
                self.match(WFLParser.RS)


            self.state = 2950
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,311,self._ctx)
            if la_ == 1:
                self.state = 2949
                self.match(WFLParser.LP)


            self.state = 2953
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,312,self._ctx)
            if la_ == 1:
                self.state = 2952
                self.stringConstantExpression()


            self.state = 2956
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 2955
                self.match(WFLParser.RP)


            self.state = 2959
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,314,self._ctx)
            if la_ == 1:
                self.state = 2958
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WaitStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WAIT(self):
            return self.getToken(WFLParser.WAIT, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def waitContent(self):
            return self.getTypedRuleContext(WFLParser.WaitContentContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_waitStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaitStatement" ):
                listener.enterWaitStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaitStatement" ):
                listener.exitWaitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWaitStatement" ):
                return visitor.visitWaitStatement(self)
            else:
                return visitor.visitChildren(self)




    def waitStatement(self):

        localctx = WFLParser.WaitStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_waitStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2961
            self.match(WFLParser.WAIT)
            self.state = 2966
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,315,self._ctx)
            if la_ == 1:
                self.state = 2962
                self.match(WFLParser.LP)
                self.state = 2963
                self.waitContent()
                self.state = 2964
                self.match(WFLParser.RP)


            self.state = 2969
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,316,self._ctx)
            if la_ == 1:
                self.state = 2968
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WaitContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def waitSpecification(self):
            return self.getTypedRuleContext(WFLParser.WaitSpecificationContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_waitContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaitContent" ):
                listener.enterWaitContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaitContent" ):
                listener.exitWaitContent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWaitContent" ):
                return visitor.visitWaitContent(self)
            else:
                return visitor.visitChildren(self)




    def waitContent(self):

        localctx = WFLParser.WaitContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_waitContent)
        self._la = 0 # Token type
        try:
            self.state = 2977
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,318,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2971
                self.stringExpression()
                self.state = 2974
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 2972
                    self.match(WFLParser.COMMA)
                    self.state = 2973
                    self.waitSpecification()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2976
                self.waitSpecification()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WaitSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OK(self):
            return self.getToken(WFLParser.OK, 0)

        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def taskState(self):
            return self.getTypedRuleContext(WFLParser.TaskStateContext,0)


        def IS(self):
            return self.getToken(WFLParser.IS, 0)

        def ISNT(self):
            return self.getToken(WFLParser.ISNT, 0)

        def simpleTaskRelation(self):
            return self.getTypedRuleContext(WFLParser.SimpleTaskRelationContext,0)


        def taskMnemonicComparison(self):
            return self.getTypedRuleContext(WFLParser.TaskMnemonicComparisonContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def booleanTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.BooleanTaskAttributeContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def RESIDENT(self):
            return self.getToken(WFLParser.RESIDENT, 0)

        def COMPLETEDOK(self):
            return self.getToken(WFLParser.COMPLETEDOK, 0)

        def COMPILEDOK(self):
            return self.getToken(WFLParser.COMPILEDOK, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_waitSpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaitSpecification" ):
                listener.enterWaitSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaitSpecification" ):
                listener.exitWaitSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWaitSpecification" ):
                return visitor.visitWaitSpecification(self)
            else:
                return visitor.visitChildren(self)




    def waitSpecification(self):

        localctx = WFLParser.WaitSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_waitSpecification)
        self._la = 0 # Token type
        try:
            self.state = 3006
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,321,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2979
                self.match(WFLParser.OK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2980
                self.realExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2981
                self.taskIdentifier()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2982
                self.taskState()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2983
                self.taskIdentifier()
                self.state = 2984
                _la = self._input.LA(1)
                if not(_la==270 or _la==271):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2985
                self.taskState()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2987
                self.simpleTaskRelation()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2988
                self.taskMnemonicComparison()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2989
                self.taskIdentifier()
                self.state = 2990
                self.match(WFLParser.LP)
                self.state = 2991
                self.booleanTaskAttribute()
                self.state = 2992
                self.match(WFLParser.RP)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2994
                self.match(WFLParser.FILE)
                self.state = 2997
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,319,self._ctx)
                if la_ == 1:
                    self.state = 2995
                    self.filePath()
                    pass

                elif la_ == 2:
                    self.state = 2996
                    self.fileReferencedVariable()
                    pass


                self.state = 3001
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==253:
                    self.state = 2999
                    self.match(WFLParser.ON)
                    self.state = 3000
                    self.storageUnit()


                self.state = 3003
                self.match(WFLParser.IS)
                self.state = 3004
                _la = self._input.LA(1)
                if not(_la==120 or _la==165 or _la==437):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleTaskRelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def realRelation(self):
            return self.getTypedRuleContext(WFLParser.RealRelationContext,0)


        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def integerTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.IntegerTaskAttributeContext,0)


        def realTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.RealTaskAttributeContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_simpleTaskRelation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleTaskRelation" ):
                listener.enterSimpleTaskRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleTaskRelation" ):
                listener.exitSimpleTaskRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleTaskRelation" ):
                return visitor.visitSimpleTaskRelation(self)
            else:
                return visitor.visitChildren(self)




    def simpleTaskRelation(self):

        localctx = WFLParser.SimpleTaskRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_simpleTaskRelation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3008
            self.taskIdentifier()
            self.state = 3009
            self.match(WFLParser.LP)
            self.state = 3012
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286, 363, 397, 398]:
                self.state = 3010
                self.integerTaskAttribute()
                pass
            elif token in [364, 366, 368]:
                self.state = 3011
                self.realTaskAttribute()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 3014
            self.match(WFLParser.RP)
            self.state = 3015
            self.realRelation()
            self.state = 3016
            self.realExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskMnemonicComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def mnemonicTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.MnemonicTaskAttributeContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def IS(self):
            return self.getToken(WFLParser.IS, 0)

        def taskState(self):
            return self.getTypedRuleContext(WFLParser.TaskStateContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_taskMnemonicComparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskMnemonicComparison" ):
                listener.enterTaskMnemonicComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskMnemonicComparison" ):
                listener.exitTaskMnemonicComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskMnemonicComparison" ):
                return visitor.visitTaskMnemonicComparison(self)
            else:
                return visitor.visitChildren(self)




    def taskMnemonicComparison(self):

        localctx = WFLParser.TaskMnemonicComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_taskMnemonicComparison)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3018
            self.taskIdentifier()
            self.state = 3019
            self.match(WFLParser.LP)
            self.state = 3020
            self.mnemonicTaskAttribute()
            self.state = 3021
            self.match(WFLParser.RP)
            self.state = 3022
            self.match(WFLParser.IS)
            self.state = 3023
            self.taskState()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskStateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPLETED(self):
            return self.getToken(WFLParser.COMPLETED, 0)

        def ACTIVE(self):
            return self.getToken(WFLParser.ACTIVE, 0)

        def TERMINATED(self):
            return self.getToken(WFLParser.TERMINATED, 0)

        def BADINITIATE(self):
            return self.getToken(WFLParser.BADINITIATE, 0)

        def NEVERUSED(self):
            return self.getToken(WFLParser.NEVERUSED, 0)

        def STOPPED(self):
            return self.getToken(WFLParser.STOPPED, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_taskState

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskState" ):
                listener.enterTaskState(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskState" ):
                listener.exitTaskState(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskState" ):
                return visitor.visitTaskState(self)
            else:
                return visitor.visitChildren(self)




    def taskState(self):

        localctx = WFLParser.TaskStateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_taskState)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3025
            _la = self._input.LA(1)
            if not(_la==58 or ((((_la - 166)) & ~0x3f) == 0 and ((1 << (_la - 166)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanTaskAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TASKVALUE(self):
            return self.getToken(WFLParser.TASKVALUE, 0)

        def STATUS(self):
            return self.getToken(WFLParser.STATUS, 0)

        def SW1(self):
            return self.getToken(WFLParser.SW1, 0)

        def SW2(self):
            return self.getToken(WFLParser.SW2, 0)

        def SW3(self):
            return self.getToken(WFLParser.SW3, 0)

        def SW4(self):
            return self.getToken(WFLParser.SW4, 0)

        def SW5(self):
            return self.getToken(WFLParser.SW5, 0)

        def SW6(self):
            return self.getToken(WFLParser.SW6, 0)

        def SW7(self):
            return self.getToken(WFLParser.SW7, 0)

        def SW8(self):
            return self.getToken(WFLParser.SW8, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanTaskAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTaskAttribute" ):
                listener.enterBooleanTaskAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTaskAttribute" ):
                listener.exitBooleanTaskAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTaskAttribute" ):
                return visitor.visitBooleanTaskAttribute(self)
            else:
                return visitor.visitChildren(self)




    def booleanTaskAttribute(self):

        localctx = WFLParser.BooleanTaskAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_booleanTaskAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3027
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1095216660480) != 0) or _la==342 or _la==349):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerTaskAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCUMPROCTIME(self):
            return self.getToken(WFLParser.ACCUMPROCTIME, 0)

        def MAXRECSIZE(self):
            return self.getToken(WFLParser.MAXRECSIZE, 0)

        def SERIALNO(self):
            return self.getToken(WFLParser.SERIALNO, 0)

        def VALUE(self):
            return self.getToken(WFLParser.VALUE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_integerTaskAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerTaskAttribute" ):
                listener.enterIntegerTaskAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerTaskAttribute" ):
                listener.exitIntegerTaskAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerTaskAttribute" ):
                return visitor.visitIntegerTaskAttribute(self)
            else:
                return visitor.visitChildren(self)




    def integerTaskAttribute(self):

        localctx = WFLParser.IntegerTaskAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_integerTaskAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3029
            _la = self._input.LA(1)
            if not(_la==286 or ((((_la - 363)) & ~0x3f) == 0 and ((1 << (_la - 363)) & 51539607553) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealTaskAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSEDTIME(self):
            return self.getToken(WFLParser.ELAPSEDTIME, 0)

        def INITPBITTIME(self):
            return self.getToken(WFLParser.INITPBITTIME, 0)

        def OTHERPBITTIME(self):
            return self.getToken(WFLParser.OTHERPBITTIME, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realTaskAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealTaskAttribute" ):
                listener.enterRealTaskAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealTaskAttribute" ):
                listener.exitRealTaskAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealTaskAttribute" ):
                return visitor.visitRealTaskAttribute(self)
            else:
                return visitor.visitChildren(self)




    def realTaskAttribute(self):

        localctx = WFLParser.RealTaskAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_realTaskAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3031
            _la = self._input.LA(1)
            if not(((((_la - 364)) & ~0x3f) == 0 and ((1 << (_la - 364)) & 21) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MnemonicTaskAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(WFLParser.STATUS, 0)

        def TASKVALUE(self):
            return self.getToken(WFLParser.TASKVALUE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_mnemonicTaskAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMnemonicTaskAttribute" ):
                listener.enterMnemonicTaskAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMnemonicTaskAttribute" ):
                listener.exitMnemonicTaskAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMnemonicTaskAttribute" ):
                return visitor.visitMnemonicTaskAttribute(self)
            else:
                return visitor.visitChildren(self)




    def mnemonicTaskAttribute(self):

        localctx = WFLParser.MnemonicTaskAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_mnemonicTaskAttribute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3033
            _la = self._input.LA(1)
            if not(_la==342 or _la==349):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealRelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQL(self):
            return self.getToken(WFLParser.EQL, 0)

        def GTR(self):
            return self.getToken(WFLParser.GTR, 0)

        def LSS(self):
            return self.getToken(WFLParser.LSS, 0)

        def GEQ(self):
            return self.getToken(WFLParser.GEQ, 0)

        def LEQ(self):
            return self.getToken(WFLParser.LEQ, 0)

        def NEQ(self):
            return self.getToken(WFLParser.NEQ, 0)

        def LT(self):
            return self.getToken(WFLParser.LT, 0)

        def GT(self):
            return self.getToken(WFLParser.GT, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realRelation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealRelation" ):
                listener.enterRealRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealRelation" ):
                listener.exitRealRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealRelation" ):
                return visitor.visitRealRelation(self)
            else:
                return visitor.visitChildren(self)




    def realRelation(self):

        localctx = WFLParser.RealRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_realRelation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3035
            _la = self._input.LA(1)
            if not(_la==23 or _la==24 or ((((_la - 171)) & ~0x3f) == 0 and ((1 << (_la - 171)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(WFLParser.ADD, 0)

        def copyRequest(self):
            return self.getTypedRuleContext(WFLParser.CopyRequestContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def addOptions(self):
            return self.getTypedRuleContext(WFLParser.AddOptionsContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def taskAttributeAssignment(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,0)


        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def copyAsClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CopyAsClauseContext)
            else:
                return self.getTypedRuleContext(WFLParser.CopyAsClauseContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def toClause(self):
            return self.getTypedRuleContext(WFLParser.ToClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_addStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddStatement" ):
                listener.enterAddStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddStatement" ):
                listener.exitAddStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddStatement" ):
                return visitor.visitAddStatement(self)
            else:
                return visitor.visitChildren(self)




    def addStatement(self):

        localctx = WFLParser.AddStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_addStatement)
        self._la = 0 # Token type
        try:
            self.state = 3081
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,331,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3037
                self.match(WFLParser.ADD)
                self.state = 3039
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,323,self._ctx)
                if la_ == 1:
                    self.state = 3038
                    self.addOptions()


                self.state = 3041
                self.copyRequest()
                self.state = 3046
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==8:
                    self.state = 3042
                    self.match(WFLParser.LS)
                    self.state = 3043
                    self.taskIdentifier()
                    self.state = 3044
                    self.match(WFLParser.RS)


                self.state = 3049
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1095216660480) != 0) or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 2327883808801) != 0) or ((((_la - 315)) & ~0x3f) == 0 and ((1 << (_la - 315)) & -1879048193) != 0) or ((((_la - 379)) & ~0x3f) == 0 and ((1 << (_la - 379)) & -8646911284551350273) != 0):
                    self.state = 3048
                    self.taskAttributeAssignment()


                self.state = 3051
                self.match(WFLParser.SEMICOLON)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3053
                self.match(WFLParser.ADD)

                self.state = 3054
                self.filePath()
                self.state = 3055
                self.copyAsClause()
                self.state = 3063
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 3057
                    self.match(WFLParser.COMMA)
                    self.state = 3058
                    self.filePath()
                    self.state = 3059
                    self.copyAsClause()
                    self.state = 3065
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3067
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==216:
                    self.state = 3066
                    self.fromClause()


                self.state = 3070
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,328,self._ctx)
                if la_ == 1:
                    self.state = 3069
                    self.toClause()


                self.state = 3076
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,329,self._ctx)
                if la_ == 1:
                    self.state = 3072
                    self.match(WFLParser.LS)
                    self.state = 3073
                    self.taskIdentifier()
                    self.state = 3074
                    self.match(WFLParser.RS)


                self.state = 3079
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,330,self._ctx)
                if la_ == 1:
                    self.state = 3078
                    self.match(WFLParser.SEMICOLON)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.AddOptionContext)
            else:
                return self.getTypedRuleContext(WFLParser.AddOptionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def AND(self):
            return self.getToken(WFLParser.AND, 0)

        def AMPERSAND(self):
            return self.getToken(WFLParser.AMPERSAND, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_addOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddOptions" ):
                listener.enterAddOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddOptions" ):
                listener.exitAddOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddOptions" ):
                return visitor.visitAddOptions(self)
            else:
                return visitor.visitChildren(self)




    def addOptions(self):

        localctx = WFLParser.AddOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_addOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3084
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==163:
                self.state = 3083
                _la = self._input.LA(1)
                if not(_la==1 or _la==163):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 3086
            self.addOption()
            self.state = 3091
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3087
                self.match(WFLParser.COMMA)
                self.state = 3088
                self.addOption()
                self.state = 3093
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BECOMEOWNER(self):
            return self.getToken(WFLParser.BECOMEOWNER, 0)

        def CATALOG(self):
            return self.getToken(WFLParser.CATALOG, 0)

        def BACKUP(self):
            return self.getToken(WFLParser.BACKUP, 0)

        def COMPARE(self):
            return self.getToken(WFLParser.COMPARE, 0)

        def VERIFY(self):
            return self.getToken(WFLParser.VERIFY, 0)

        def DSONERROR(self):
            return self.getToken(WFLParser.DSONERROR, 0)

        def WAITONERROR(self):
            return self.getToken(WFLParser.WAITONERROR, 0)

        def REPORT(self):
            return self.getToken(WFLParser.REPORT, 0)

        def SKIPEXCLUSIVE(self):
            return self.getToken(WFLParser.SKIPEXCLUSIVE, 0)

        def FROMSTART(self):
            return self.getToken(WFLParser.FROMSTART, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_addOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddOption" ):
                listener.enterAddOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddOption" ):
                listener.exitAddOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddOption" ):
                return visitor.visitAddOption(self)
            else:
                return visitor.visitChildren(self)




    def addOption(self):

        localctx = WFLParser.AddOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_addOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3094
            _la = self._input.LA(1)
            if not(((((_la - 153)) & ~0x3f) == 0 and ((1 << (_la - 153)) & 1015) != 0) or _la==282):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CopyRequestContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def toClause(self):
            return self.getTypedRuleContext(WFLParser.ToClauseContext,0)


        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def copyAsClause(self):
            return self.getTypedRuleContext(WFLParser.CopyAsClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_copyRequest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopyRequest" ):
                listener.enterCopyRequest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopyRequest" ):
                listener.exitCopyRequest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCopyRequest" ):
                return visitor.visitCopyRequest(self)
            else:
                return visitor.visitChildren(self)




    def copyRequest(self):

        localctx = WFLParser.CopyRequestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_copyRequest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3099
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,334,self._ctx)
            if la_ == 1:
                self.state = 3096
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 3097
                self.fileReferencedVariable()
                pass

            elif la_ == 3:
                self.state = 3098
                self.match(WFLParser.EQUAL)
                pass


            self.state = 3105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3101
                self.match(WFLParser.COMMA)

                self.state = 3102
                self.filePath()
                self.state = 3107
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==189:
                self.state = 3108
                self.copyAsClause()


            self.state = 3112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 3111
                self.fromClause()


            self.state = 3115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 3114
                self.toClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcessStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCESS(self):
            return self.getToken(WFLParser.PROCESS, 0)

        def addStatement(self):
            return self.getTypedRuleContext(WFLParser.AddStatementContext,0)


        def compileStatement(self):
            return self.getTypedRuleContext(WFLParser.CompileStatementContext,0)


        def runStatement(self):
            return self.getTypedRuleContext(WFLParser.RunStatementContext,0)


        def startStatement(self):
            return self.getTypedRuleContext(WFLParser.StartStatementContext,0)


        def subroutineInvocationStatement(self):
            return self.getTypedRuleContext(WFLParser.SubroutineInvocationStatementContext,0)


        def copyStatement(self):
            return self.getTypedRuleContext(WFLParser.CopyStatementContext,0)


        def wrapAndCompressStatement(self):
            return self.getTypedRuleContext(WFLParser.WrapAndCompressStatementContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def taskEquationList(self):
            return self.getTypedRuleContext(WFLParser.TaskEquationListContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_processStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcessStatement" ):
                listener.enterProcessStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcessStatement" ):
                listener.exitProcessStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcessStatement" ):
                return visitor.visitProcessStatement(self)
            else:
                return visitor.visitChildren(self)




    def processStatement(self):

        localctx = WFLParser.ProcessStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_processStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3117
            self.match(WFLParser.PROCESS)
            self.state = 3125
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,339,self._ctx)
            if la_ == 1:
                self.state = 3118
                self.addStatement()
                pass

            elif la_ == 2:
                self.state = 3119
                self.compileStatement()
                pass

            elif la_ == 3:
                self.state = 3120
                self.runStatement()
                pass

            elif la_ == 4:
                self.state = 3121
                self.startStatement()
                pass

            elif la_ == 5:
                self.state = 3122
                self.subroutineInvocationStatement()
                pass

            elif la_ == 6:
                self.state = 3123
                self.copyStatement()
                pass

            elif la_ == 7:
                self.state = 3124
                self.wrapAndCompressStatement()
                pass


            self.state = 3131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 3127
                self.match(WFLParser.LS)
                self.state = 3128
                self.taskIdentifier()
                self.state = 3129
                self.match(WFLParser.RS)


            self.state = 3134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,341,self._ctx)
            if la_ == 1:
                self.state = 3133
                self.taskEquationList()


            self.state = 3137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,342,self._ctx)
            if la_ == 1:
                self.state = 3136
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanAssignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.BooleanAssignmentStatementContext,0)


        def integerAssignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.IntegerAssignmentStatementContext,0)


        def realAssignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.RealAssignmentStatementContext,0)


        def stringAssignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.StringAssignmentStatementContext,0)


        def fileAssignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.FileAssignmentStatementContext,0)


        def taskAssignmentStatement(self):
            return self.getTypedRuleContext(WFLParser.TaskAssignmentStatementContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_assignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentStatement" ):
                listener.enterAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentStatement" ):
                listener.exitAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentStatement" ):
                return visitor.visitAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def assignmentStatement(self):

        localctx = WFLParser.AssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_assignmentStatement)
        try:
            self.state = 3145
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,343,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3139
                self.booleanAssignmentStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3140
                self.integerAssignmentStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3141
                self.realAssignmentStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3142
                self.stringAssignmentStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3143
                self.fileAssignmentStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3144
                self.taskAssignmentStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanAssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanIdentifier(self):
            return self.getTypedRuleContext(WFLParser.BooleanIdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanAssignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanAssignmentStatement" ):
                listener.enterBooleanAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanAssignmentStatement" ):
                listener.exitBooleanAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanAssignmentStatement" ):
                return visitor.visitBooleanAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def booleanAssignmentStatement(self):

        localctx = WFLParser.BooleanAssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_booleanAssignmentStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3147
            self.booleanIdentifier()
            self.state = 3148
            self.match(WFLParser.ASSIGN)
            self.state = 3149
            self.booleanConstantExpression()
            self.state = 3150
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanIdentifier" ):
                listener.enterBooleanIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanIdentifier" ):
                listener.exitBooleanIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanIdentifier" ):
                return visitor.visitBooleanIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def booleanIdentifier(self):

        localctx = WFLParser.BooleanIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_booleanIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3152
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerAssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerIdentifier(self):
            return self.getTypedRuleContext(WFLParser.IntegerIdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_integerAssignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerAssignmentStatement" ):
                listener.enterIntegerAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerAssignmentStatement" ):
                listener.exitIntegerAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerAssignmentStatement" ):
                return visitor.visitIntegerAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def integerAssignmentStatement(self):

        localctx = WFLParser.IntegerAssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 516, self.RULE_integerAssignmentStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3154
            self.integerIdentifier()
            self.state = 3155
            self.match(WFLParser.ASSIGN)
            self.state = 3156
            self.integerExpression()
            self.state = 3158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,344,self._ctx)
            if la_ == 1:
                self.state = 3157
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_integerIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerIdentifier" ):
                listener.enterIntegerIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerIdentifier" ):
                listener.exitIntegerIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerIdentifier" ):
                return visitor.visitIntegerIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def integerIdentifier(self):

        localctx = WFLParser.IntegerIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 518, self.RULE_integerIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3160
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealAssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def realIdentifier(self):
            return self.getTypedRuleContext(WFLParser.RealIdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realAssignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealAssignmentStatement" ):
                listener.enterRealAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealAssignmentStatement" ):
                listener.exitRealAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealAssignmentStatement" ):
                return visitor.visitRealAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def realAssignmentStatement(self):

        localctx = WFLParser.RealAssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 520, self.RULE_realAssignmentStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3162
            self.realIdentifier()
            self.state = 3163
            self.match(WFLParser.ASSIGN)
            self.state = 3164
            self.realExpression()
            self.state = 3165
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealIdentifier" ):
                listener.enterRealIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealIdentifier" ):
                listener.exitRealIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealIdentifier" ):
                return visitor.visitRealIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def realIdentifier(self):

        localctx = WFLParser.RealIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 522, self.RULE_realIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3167
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringAssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringIdentifier(self):
            return self.getTypedRuleContext(WFLParser.StringIdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringAssignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringAssignmentStatement" ):
                listener.enterStringAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringAssignmentStatement" ):
                listener.exitStringAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringAssignmentStatement" ):
                return visitor.visitStringAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def stringAssignmentStatement(self):

        localctx = WFLParser.StringAssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 524, self.RULE_stringAssignmentStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3169
            self.stringIdentifier()
            self.state = 3170
            self.match(WFLParser.ASSIGN)
            self.state = 3172
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,345,self._ctx)
            if la_ == 1:
                self.state = 3171
                self.stringExpression()


            self.state = 3175
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,346,self._ctx)
            if la_ == 1:
                self.state = 3174
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_stringIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringIdentifier" ):
                listener.enterStringIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringIdentifier" ):
                listener.exitStringIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringIdentifier" ):
                return visitor.visitStringIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def stringIdentifier(self):

        localctx = WFLParser.StringIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 526, self.RULE_stringIdentifier)
        try:
            self.state = 3179
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3177
                self.match(WFLParser.Identifier)
                pass
            elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3178
                self.charDataKeyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileAssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileAttributeAssignmentContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_fileAssignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileAssignmentStatement" ):
                listener.enterFileAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileAssignmentStatement" ):
                listener.exitFileAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileAssignmentStatement" ):
                return visitor.visitFileAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def fileAssignmentStatement(self):

        localctx = WFLParser.FileAssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 528, self.RULE_fileAssignmentStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3181
            self.fileIdentifier()
            self.state = 3182
            self.match(WFLParser.LP)
            self.state = 3183
            self.fileAttributeAssignment()
            self.state = 3188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3184
                self.match(WFLParser.COMMA)
                self.state = 3185
                self.fileAttributeAssignment()
                self.state = 3190
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3191
            self.match(WFLParser.RP)
            self.state = 3192
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fileIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileIdentifier" ):
                listener.enterFileIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileIdentifier" ):
                listener.exitFileIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileIdentifier" ):
                return visitor.visitFileIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def fileIdentifier(self):

        localctx = WFLParser.FileIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 530, self.RULE_fileIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3194
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskAssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def taskAttributeAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskAttributeAssignmentContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,i)


        def fileEquation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FileEquationContext)
            else:
                return self.getTypedRuleContext(WFLParser.FileEquationContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_taskAssignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaskAssignmentStatement" ):
                listener.enterTaskAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaskAssignmentStatement" ):
                listener.exitTaskAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaskAssignmentStatement" ):
                return visitor.visitTaskAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def taskAssignmentStatement(self):

        localctx = WFLParser.TaskAssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 532, self.RULE_taskAssignmentStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3196
            self.taskIdentifier()
            self.state = 3197
            self.match(WFLParser.LP)
            self.state = 3200
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442]:
                self.state = 3198
                self.taskAttributeAssignment()
                pass
            elif token in [237]:
                self.state = 3199
                self.fileEquation()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 3209
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3202
                self.match(WFLParser.COMMA)
                self.state = 3205
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [32, 33, 34, 35, 36, 37, 38, 39, 187, 192, 207, 208, 210, 220, 221, 222, 223, 228, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 438, 442]:
                    self.state = 3203
                    self.taskAttributeAssignment()
                    pass
                elif token in [237]:
                    self.state = 3204
                    self.fileEquation()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3211
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3212
            self.match(WFLParser.RP)
            self.state = 3213
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def START(self):
            return self.getToken(WFLParser.START, 0)

        def STARTJOB(self):
            return self.getToken(WFLParser.STARTJOB, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def HASH(self):
            return self.getToken(WFLParser.HASH, 0)

        def stringPrimary(self):
            return self.getTypedRuleContext(WFLParser.StringPrimaryContext,0)


        def startTimeAttribute(self):
            return self.getTypedRuleContext(WFLParser.StartTimeAttributeContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def startParameterList(self):
            return self.getTypedRuleContext(WFLParser.StartParameterListContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def FOR(self):
            return self.getToken(WFLParser.FOR, 0)

        def SYNTAX(self):
            return self.getToken(WFLParser.SYNTAX, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_startStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartStatement" ):
                listener.enterStartStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartStatement" ):
                listener.exitStartStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartStatement" ):
                return visitor.visitStartStatement(self)
            else:
                return visitor.visitChildren(self)




    def startStatement(self):

        localctx = WFLParser.StartStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 534, self.RULE_startStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3215
            _la = self._input.LA(1)
            if not(_la==278 or _la==279):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3216
            self.filePath()
            self.state = 3219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 3217
                self.match(WFLParser.ON)
                self.state = 3218
                self.storageUnit()


            self.state = 3225
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 3221
                self.match(WFLParser.LP)
                self.state = 3222
                self.startParameterList()
                self.state = 3223
                self.match(WFLParser.RP)


            self.state = 3231
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 3227
                self.match(WFLParser.LS)
                self.state = 3228
                self.taskIdentifier()
                self.state = 3229
                self.match(WFLParser.RS)


            self.state = 3235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215:
                self.state = 3233
                self.match(WFLParser.FOR)
                self.state = 3234
                self.match(WFLParser.SYNTAX)


            self.state = 3242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,356,self._ctx)
            if la_ == 1:
                self.state = 3237
                self.match(WFLParser.SEMICOLON)
                pass

            elif la_ == 2:
                self.state = 3238
                self.match(WFLParser.HASH)
                self.state = 3239
                self.stringPrimary()
                pass

            elif la_ == 3:
                self.state = 3240
                self.match(WFLParser.SEMICOLON)
                self.state = 3241
                self.startTimeAttribute()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedParameterList(self):
            return self.getTypedRuleContext(WFLParser.NamedParameterListContext,0)


        def positionalParameterList(self):
            return self.getTypedRuleContext(WFLParser.PositionalParameterListContext,0)


        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_startParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartParameterList" ):
                listener.enterStartParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartParameterList" ):
                listener.exitStartParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartParameterList" ):
                return visitor.visitStartParameterList(self)
            else:
                return visitor.visitChildren(self)




    def startParameterList(self):

        localctx = WFLParser.StartParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 536, self.RULE_startParameterList)
        self._la = 0 # Token type
        try:
            self.state = 3250
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,358,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3244
                self.namedParameterList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3245
                self.positionalParameterList()
                self.state = 3248
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 3246
                    self.match(WFLParser.COMMA)
                    self.state = 3247
                    self.namedParameterList()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.NamedParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.NamedParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_namedParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedParameterList" ):
                listener.enterNamedParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedParameterList" ):
                listener.exitNamedParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedParameterList" ):
                return visitor.visitNamedParameterList(self)
            else:
                return visitor.visitChildren(self)




    def namedParameterList(self):

        localctx = WFLParser.NamedParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 538, self.RULE_namedParameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3252
            self.namedParameter()
            self.state = 3257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3253
                self.match(WFLParser.COMMA)
                self.state = 3254
                self.namedParameter()
                self.state = 3259
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def realFormalParameter(self):
            return self.getTypedRuleContext(WFLParser.RealFormalParameterContext,0)


        def ASSIGN(self):
            return self.getToken(WFLParser.ASSIGN, 0)

        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def integerFormalParameter(self):
            return self.getTypedRuleContext(WFLParser.IntegerFormalParameterContext,0)


        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def booleanFormalParameter(self):
            return self.getTypedRuleContext(WFLParser.BooleanFormalParameterContext,0)


        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def stringFormalParameter(self):
            return self.getTypedRuleContext(WFLParser.StringFormalParameterContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_namedParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedParameter" ):
                listener.enterNamedParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedParameter" ):
                listener.exitNamedParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedParameter" ):
                return visitor.visitNamedParameter(self)
            else:
                return visitor.visitChildren(self)




    def namedParameter(self):

        localctx = WFLParser.NamedParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 540, self.RULE_namedParameter)
        try:
            self.state = 3276
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,360,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3260
                self.realFormalParameter()
                self.state = 3261
                self.match(WFLParser.ASSIGN)
                self.state = 3262
                self.realExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3264
                self.integerFormalParameter()
                self.state = 3265
                self.match(WFLParser.ASSIGN)
                self.state = 3266
                self.integerExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3268
                self.booleanFormalParameter()
                self.state = 3269
                self.match(WFLParser.ASSIGN)
                self.state = 3270
                self.booleanConstantExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3272
                self.stringFormalParameter()
                self.state = 3273
                self.match(WFLParser.ASSIGN)
                self.state = 3274
                self.stringExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealFormalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_realFormalParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealFormalParameter" ):
                listener.enterRealFormalParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealFormalParameter" ):
                listener.exitRealFormalParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealFormalParameter" ):
                return visitor.visitRealFormalParameter(self)
            else:
                return visitor.visitChildren(self)




    def realFormalParameter(self):

        localctx = WFLParser.RealFormalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 542, self.RULE_realFormalParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3278
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerFormalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_integerFormalParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerFormalParameter" ):
                listener.enterIntegerFormalParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerFormalParameter" ):
                listener.exitIntegerFormalParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerFormalParameter" ):
                return visitor.visitIntegerFormalParameter(self)
            else:
                return visitor.visitChildren(self)




    def integerFormalParameter(self):

        localctx = WFLParser.IntegerFormalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 544, self.RULE_integerFormalParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3280
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanFormalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanFormalParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFormalParameter" ):
                listener.enterBooleanFormalParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFormalParameter" ):
                listener.exitBooleanFormalParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFormalParameter" ):
                return visitor.visitBooleanFormalParameter(self)
            else:
                return visitor.visitChildren(self)




    def booleanFormalParameter(self):

        localctx = WFLParser.BooleanFormalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 546, self.RULE_booleanFormalParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3282
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringFormalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringFormalParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringFormalParameter" ):
                listener.enterStringFormalParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringFormalParameter" ):
                listener.exitStringFormalParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringFormalParameter" ):
                return visitor.visitStringFormalParameter(self)
            else:
                return visitor.visitChildren(self)




    def stringFormalParameter(self):

        localctx = WFLParser.StringFormalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 548, self.RULE_stringFormalParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3284
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PositionalParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def positionalParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.PositionalParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.PositionalParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_positionalParameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPositionalParameterList" ):
                listener.enterPositionalParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPositionalParameterList" ):
                listener.exitPositionalParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPositionalParameterList" ):
                return visitor.visitPositionalParameterList(self)
            else:
                return visitor.visitChildren(self)




    def positionalParameterList(self):

        localctx = WFLParser.PositionalParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 550, self.RULE_positionalParameterList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3286
            self.positionalParameter()
            self.state = 3291
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,361,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3287
                    self.match(WFLParser.COMMA)
                    self.state = 3288
                    self.positionalParameter() 
                self.state = 3293
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,361,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PositionalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def realExpression(self):
            return self.getTypedRuleContext(WFLParser.RealExpressionContext,0)


        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_positionalParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPositionalParameter" ):
                listener.enterPositionalParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPositionalParameter" ):
                listener.exitPositionalParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPositionalParameter" ):
                return visitor.visitPositionalParameter(self)
            else:
                return visitor.visitChildren(self)




    def positionalParameter(self):

        localctx = WFLParser.PositionalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 552, self.RULE_positionalParameter)
        try:
            self.state = 3298
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,362,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3294
                self.realExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3295
                self.integerExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3296
                self.booleanConstantExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3297
                self.stringExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def STAR(self):
            return self.getToken(WFLParser.STAR, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_stringPrimary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringPrimary" ):
                listener.enterStringPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringPrimary" ):
                listener.exitStringPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringPrimary" ):
                return visitor.visitStringPrimary(self)
            else:
                return visitor.visitChildren(self)




    def stringPrimary(self):

        localctx = WFLParser.StringPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 554, self.RULE_stringPrimary)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3300
            self.match(WFLParser.STRING)
            self.state = 3301
            self.match(WFLParser.LP)
            self.state = 3302
            _la = self._input.LA(1)
            if not(_la==446 or _la==447):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3305
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 3303
                self.match(WFLParser.COMMA)
                self.state = 3304
                self.match(WFLParser.STAR)


            self.state = 3307
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(WFLParser.IF, 0)

        def condition(self):
            return self.getTypedRuleContext(WFLParser.ConditionContext,0)


        def thenClause(self):
            return self.getTypedRuleContext(WFLParser.ThenClauseContext,0)


        def elseClause(self):
            return self.getTypedRuleContext(WFLParser.ElseClauseContext,0)


        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = WFLParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 556, self.RULE_ifStatement)
        self._la = 0 # Token type
        try:
            self.state = 3325
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [269]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3309
                self.match(WFLParser.IF)
                self.state = 3310
                self.condition()
                self.state = 3311
                self.thenClause()
                self.state = 3313
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,364,self._ctx)
                if la_ == 1:
                    self.state = 3312
                    self.elseClause()


                pass
            elif token in [193]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3315
                self.match(WFLParser.BEGIN)
                self.state = 3316
                self.match(WFLParser.IF)
                self.state = 3317
                self.condition()
                self.state = 3318
                self.thenClause()
                self.state = 3320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==203:
                    self.state = 3319
                    self.elseClause()


                self.state = 3322
                self.match(WFLParser.END)
                self.state = 3323
                self.match(WFLParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleCondition(self):
            return self.getTypedRuleContext(WFLParser.SimpleConditionContext,0)


        def combineComplexCondition(self):
            return self.getTypedRuleContext(WFLParser.CombineComplexConditionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = WFLParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 558, self.RULE_condition)
        try:
            self.state = 3329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,367,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3327
                self.simpleCondition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3328
                self.combineComplexCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.BooleanExpressionContext,i)


        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.NOT)
            else:
                return self.getToken(WFLParser.NOT, i)

        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.OR)
            else:
                return self.getToken(WFLParser.OR, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.AND)
            else:
                return self.getToken(WFLParser.AND, i)

        def getRuleIndex(self):
            return WFLParser.RULE_simpleCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleCondition" ):
                listener.enterSimpleCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleCondition" ):
                listener.exitSimpleCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleCondition" ):
                return visitor.visitSimpleCondition(self)
            else:
                return visitor.visitChildren(self)




    def simpleCondition(self):

        localctx = WFLParser.SimpleConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 560, self.RULE_simpleCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3332
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,368,self._ctx)
            if la_ == 1:
                self.state = 3331
                self.match(WFLParser.NOT)


            self.state = 3335
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,369,self._ctx)
            if la_ == 1:
                self.state = 3334
                self.match(WFLParser.LP)


            self.state = 3337
            self.booleanExpression()
            self.state = 3339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 3338
                self.match(WFLParser.RP)


            self.state = 3354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==122 or _la==163:
                self.state = 3341
                _la = self._input.LA(1)
                if not(_la==122 or _la==163):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3343
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,371,self._ctx)
                if la_ == 1:
                    self.state = 3342
                    self.match(WFLParser.NOT)


                self.state = 3346
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,372,self._ctx)
                if la_ == 1:
                    self.state = 3345
                    self.match(WFLParser.LP)


                self.state = 3348
                self.booleanExpression()
                self.state = 3350
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 3349
                    self.match(WFLParser.RP)


                self.state = 3356
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplexConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.BooleanExpressionContext,i)


        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.AND)
            else:
                return self.getToken(WFLParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.OR)
            else:
                return self.getToken(WFLParser.OR, i)

        def getRuleIndex(self):
            return WFLParser.RULE_complexCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexCondition" ):
                listener.enterComplexCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexCondition" ):
                listener.exitComplexCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexCondition" ):
                return visitor.visitComplexCondition(self)
            else:
                return visitor.visitChildren(self)




    def complexCondition(self):

        localctx = WFLParser.ComplexConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 562, self.RULE_complexCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3357
            self.match(WFLParser.LP)
            self.state = 3358
            self.match(WFLParser.LP)
            self.state = 3359
            self.match(WFLParser.LP)
            self.state = 3360
            self.booleanExpression()
            self.state = 3361
            self.match(WFLParser.RP)
            self.state = 3362
            _la = self._input.LA(1)
            if not(_la==122 or _la==163):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3363
            self.match(WFLParser.LP)
            self.state = 3364
            self.booleanExpression()
            self.state = 3365
            self.match(WFLParser.RP)
            self.state = 3366
            self.match(WFLParser.RP)
            self.state = 3367
            _la = self._input.LA(1)
            if not(_la==122 or _la==163):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3368
            self.match(WFLParser.LP)
            self.state = 3369
            self.match(WFLParser.LP)
            self.state = 3370
            self.booleanExpression()
            self.state = 3371
            self.match(WFLParser.RP)
            self.state = 3372
            _la = self._input.LA(1)
            if not(_la==122 or _la==163):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3373
            self.match(WFLParser.LP)
            self.state = 3374
            self.booleanExpression()
            self.state = 3375
            self.match(WFLParser.RP)
            self.state = 3376
            self.match(WFLParser.RP)
            self.state = 3377
            self.match(WFLParser.RP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CombineComplexConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def complexCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ComplexConditionContext)
            else:
                return self.getTypedRuleContext(WFLParser.ComplexConditionContext,i)


        def OR(self):
            return self.getToken(WFLParser.OR, 0)

        def AND(self):
            return self.getToken(WFLParser.AND, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_combineComplexCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCombineComplexCondition" ):
                listener.enterCombineComplexCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCombineComplexCondition" ):
                listener.exitCombineComplexCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCombineComplexCondition" ):
                return visitor.visitCombineComplexCondition(self)
            else:
                return visitor.visitChildren(self)




    def combineComplexCondition(self):

        localctx = WFLParser.CombineComplexConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 564, self.RULE_combineComplexCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3379
            self.complexCondition()
            self.state = 3382
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==122 or _la==163:
                self.state = 3380
                _la = self._input.LA(1)
                if not(_la==122 or _la==163):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3381
                self.complexCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THEN(self):
            return self.getToken(WFLParser.THEN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def getRuleIndex(self):
            return WFLParser.RULE_thenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenClause" ):
                listener.enterThenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenClause" ):
                listener.exitThenClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThenClause" ):
                return visitor.visitThenClause(self)
            else:
                return visitor.visitChildren(self)




    def thenClause(self):

        localctx = WFLParser.ThenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 566, self.RULE_thenClause)
        self._la = 0 # Token type
        try:
            self.state = 3400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,379,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3384
                self.match(WFLParser.THEN)
                self.state = 3385
                self.statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3386
                self.match(WFLParser.THEN)
                self.state = 3387
                self.match(WFLParser.BEGIN)
                self.state = 3389
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==20:
                    self.state = 3388
                    self.match(WFLParser.SEMICOLON)


                self.state = 3392 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3391
                    self.statement()
                    self.state = 3394 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0)):
                        break

                self.state = 3396
                self.match(WFLParser.END)
                self.state = 3398
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,378,self._ctx)
                if la_ == 1:
                    self.state = 3397
                    self.match(WFLParser.SEMICOLON)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(WFLParser.ELSE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def getRuleIndex(self):
            return WFLParser.RULE_elseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseClause" ):
                listener.enterElseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseClause" ):
                listener.exitElseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseClause" ):
                return visitor.visitElseClause(self)
            else:
                return visitor.visitChildren(self)




    def elseClause(self):

        localctx = WFLParser.ElseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 568, self.RULE_elseClause)
        self._la = 0 # Token type
        try:
            self.state = 3418
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,383,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3402
                self.match(WFLParser.ELSE)
                self.state = 3403
                self.statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3404
                self.match(WFLParser.ELSE)
                self.state = 3405
                self.match(WFLParser.BEGIN)
                self.state = 3407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==20:
                    self.state = 3406
                    self.match(WFLParser.SEMICOLON)


                self.state = 3410 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3409
                    self.statement()
                    self.state = 3412 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0)):
                        break

                self.state = 3414
                self.match(WFLParser.END)
                self.state = 3416
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,382,self._ctx)
                if la_ == 1:
                    self.state = 3415
                    self.match(WFLParser.SEMICOLON)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def booleanComparison(self):
            return self.getTypedRuleContext(WFLParser.BooleanComparisonContext,0)


        def NOT(self):
            return self.getToken(WFLParser.NOT, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanExpressionContext,0)


        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def calcExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CalcExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.CalcExpressionContext,i)


        def realRelation(self):
            return self.getTypedRuleContext(WFLParser.RealRelationContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_booleanExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanExpression" ):
                listener.enterBooleanExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanExpression" ):
                listener.exitBooleanExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanExpression" ):
                return visitor.visitBooleanExpression(self)
            else:
                return visitor.visitChildren(self)




    def booleanExpression(self):

        localctx = WFLParser.BooleanExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 570, self.RULE_booleanExpression)
        try:
            self.state = 3457
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,392,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3420
                self.booleanConstantExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3421
                self.booleanComparison()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3422
                self.match(WFLParser.NOT)
                self.state = 3424
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,384,self._ctx)
                if la_ == 1:
                    self.state = 3423
                    self.match(WFLParser.LP)


                self.state = 3426
                self.booleanExpression()
                self.state = 3428
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,385,self._ctx)
                if la_ == 1:
                    self.state = 3427
                    self.match(WFLParser.RP)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3430
                self.match(WFLParser.NOT)
                self.state = 3432
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,386,self._ctx)
                if la_ == 1:
                    self.state = 3431
                    self.match(WFLParser.LP)


                self.state = 3434
                self.calcExpression()
                self.state = 3437
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23, 24, 171, 172, 173, 174, 175, 176]:
                    self.state = 3435
                    self.realRelation()
                    pass
                elif token in [29]:
                    self.state = 3436
                    self.match(WFLParser.EQUAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3448
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,390,self._ctx)
                if la_ == 1:
                    self.state = 3439
                    self.match(WFLParser.Num)
                    pass

                elif la_ == 2:
                    self.state = 3440
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 3:
                    self.state = 3442
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,388,self._ctx)
                    if la_ == 1:
                        self.state = 3441
                        self.match(WFLParser.LP)


                    self.state = 3444
                    self.calcExpression()
                    self.state = 3446
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,389,self._ctx)
                    if la_ == 1:
                        self.state = 3445
                        self.match(WFLParser.RP)


                    pass


                self.state = 3451
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,391,self._ctx)
                if la_ == 1:
                    self.state = 3450
                    self.match(WFLParser.RP)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3453
                self.match(WFLParser.LP)
                self.state = 3454
                self.booleanExpression()
                self.state = 3455
                self.match(WFLParser.RP)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def booleanTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.BooleanTaskAttributeContext,0)


        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def IS(self):
            return self.getToken(WFLParser.IS, 0)

        def ISNT(self):
            return self.getToken(WFLParser.ISNT, 0)

        def integerTaskAttribute(self):
            return self.getTypedRuleContext(WFLParser.IntegerTaskAttributeContext,0)


        def realRelation(self):
            return self.getTypedRuleContext(WFLParser.RealRelationContext,0)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def calcExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CalcExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.CalcExpressionContext,i)


        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def RESIDENT(self):
            return self.getToken(WFLParser.RESIDENT, 0)

        def ABORTED(self):
            return self.getToken(WFLParser.ABORTED, 0)

        def COMPLETEDOK(self):
            return self.getToken(WFLParser.COMPLETEDOK, 0)

        def COMPILEDOK(self):
            return self.getToken(WFLParser.COMPILEDOK, 0)

        def FILE(self):
            return self.getToken(WFLParser.FILE, 0)

        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def taskState(self):
            return self.getTypedRuleContext(WFLParser.TaskStateContext,0)


        def NOT(self):
            return self.getToken(WFLParser.NOT, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_booleanComparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanComparison" ):
                listener.enterBooleanComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanComparison" ):
                listener.exitBooleanComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanComparison" ):
                return visitor.visitBooleanComparison(self)
            else:
                return visitor.visitChildren(self)




    def booleanComparison(self):

        localctx = WFLParser.BooleanComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 572, self.RULE_booleanComparison)
        self._la = 0 # Token type
        try:
            self.state = 3575
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,415,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3459
                self.taskIdentifier()
                self.state = 3460
                self.match(WFLParser.LP)
                self.state = 3461
                self.booleanTaskAttribute()
                self.state = 3462
                self.match(WFLParser.RP)
                self.state = 3463
                _la = self._input.LA(1)
                if not(_la==270 or _la==271):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3464
                self.booleanConstantExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3466
                self.taskIdentifier()
                self.state = 3467
                self.match(WFLParser.LP)
                self.state = 3470
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [32, 33, 34, 35, 36, 37, 38, 39, 342, 349]:
                    self.state = 3468
                    self.booleanTaskAttribute()
                    pass
                elif token in [286, 363, 397, 398]:
                    self.state = 3469
                    self.integerTaskAttribute()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3472
                self.match(WFLParser.RP)
                self.state = 3477
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23, 24, 171, 172, 173, 174, 175, 176]:
                    self.state = 3473
                    self.realRelation()
                    pass
                elif token in [270]:
                    self.state = 3474
                    self.match(WFLParser.IS)
                    pass
                elif token in [271]:
                    self.state = 3475
                    self.match(WFLParser.ISNT)
                    pass
                elif token in [29]:
                    self.state = 3476
                    self.match(WFLParser.EQUAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3487
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,397,self._ctx)
                if la_ == 1:
                    self.state = 3479
                    self.match(WFLParser.Num)
                    pass

                elif la_ == 2:
                    self.state = 3481
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,395,self._ctx)
                    if la_ == 1:
                        self.state = 3480
                        self.match(WFLParser.LP)


                    self.state = 3483
                    self.calcExpression()
                    self.state = 3485
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,396,self._ctx)
                    if la_ == 1:
                        self.state = 3484
                        self.match(WFLParser.RP)


                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3489
                self.filePath()
                self.state = 3490
                _la = self._input.LA(1)
                if not(_la==270 or _la==271):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3491
                _la = self._input.LA(1)
                if not(_la==120 or _la==165 or _la==247 or _la==437):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3493
                self.match(WFLParser.FILE)
                self.state = 3496
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,398,self._ctx)
                if la_ == 1:
                    self.state = 3494
                    self.fileReferencedVariable()
                    pass

                elif la_ == 2:
                    self.state = 3495
                    self.filePath()
                    pass


                self.state = 3500
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==253:
                    self.state = 3498
                    self.match(WFLParser.ON)
                    self.state = 3499
                    self.storageUnit()


                self.state = 3502
                _la = self._input.LA(1)
                if not(_la==270 or _la==271):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3503
                _la = self._input.LA(1)
                if not(_la==120 or _la==165 or _la==247 or _la==437):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3509
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,400,self._ctx)
                if la_ == 1:
                    self.state = 3505
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 2:
                    self.state = 3506
                    self.stringExpression()
                    pass

                elif la_ == 3:
                    self.state = 3507
                    self.charDataKeyword()
                    pass

                elif la_ == 4:
                    self.state = 3508
                    self.taskAttribute()
                    pass


                self.state = 3513
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23, 24, 171, 172, 173, 174, 175, 176]:
                    self.state = 3511
                    self.realRelation()
                    pass
                elif token in [29]:
                    self.state = 3512
                    self.match(WFLParser.EQUAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3526
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,404,self._ctx)
                if la_ == 1:
                    self.state = 3515
                    self.match(WFLParser.LITERAL)
                    pass

                elif la_ == 2:
                    self.state = 3516
                    self.match(WFLParser.Num)
                    pass

                elif la_ == 3:
                    self.state = 3518
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,402,self._ctx)
                    if la_ == 1:
                        self.state = 3517
                        self.match(WFLParser.LP)


                    self.state = 3520
                    self.calcExpression()
                    self.state = 3522
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,403,self._ctx)
                    if la_ == 1:
                        self.state = 3521
                        self.match(WFLParser.RP)


                    pass

                elif la_ == 4:
                    self.state = 3524
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 5:
                    self.state = 3525
                    self.match(WFLParser.EMPTYSTRING)
                    pass


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3528
                self.taskIdentifier()
                self.state = 3529
                _la = self._input.LA(1)
                if not(_la==270 or _la==271):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3530
                self.taskState()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 3532
                self.match(WFLParser.NOT)
                self.state = 3533
                self.match(WFLParser.Identifier)
                self.state = 3534
                self.match(WFLParser.LP)
                self.state = 3535
                self.match(WFLParser.RESIDENT)
                self.state = 3536
                self.match(WFLParser.RP)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 3537
                self.integerExpression()
                self.state = 3540
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23, 24, 171, 172, 173, 174, 175, 176]:
                    self.state = 3538
                    self.realRelation()
                    pass
                elif token in [29]:
                    self.state = 3539
                    self.match(WFLParser.EQUAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3551
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,408,self._ctx)
                if la_ == 1:
                    self.state = 3542
                    self.match(WFLParser.Num)
                    pass

                elif la_ == 2:
                    self.state = 3543
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 3:
                    self.state = 3545
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,406,self._ctx)
                    if la_ == 1:
                        self.state = 3544
                        self.match(WFLParser.LP)


                    self.state = 3547
                    self.calcExpression()
                    self.state = 3549
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,407,self._ctx)
                    if la_ == 1:
                        self.state = 3548
                        self.match(WFLParser.RP)


                    pass


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 3554
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,409,self._ctx)
                if la_ == 1:
                    self.state = 3553
                    self.match(WFLParser.LP)


                self.state = 3556
                self.calcExpression()
                self.state = 3558
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==13:
                    self.state = 3557
                    self.match(WFLParser.RP)


                self.state = 3562
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [23, 24, 171, 172, 173, 174, 175, 176]:
                    self.state = 3560
                    self.realRelation()
                    pass
                elif token in [29]:
                    self.state = 3561
                    self.match(WFLParser.EQUAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3573
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,414,self._ctx)
                if la_ == 1:
                    self.state = 3564
                    self.match(WFLParser.Num)
                    pass

                elif la_ == 2:
                    self.state = 3565
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 3:
                    self.state = 3567
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,412,self._ctx)
                    if la_ == 1:
                        self.state = 3566
                        self.match(WFLParser.LP)


                    self.state = 3569
                    self.calcExpression()
                    self.state = 3571
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,413,self._ctx)
                    if la_ == 1:
                        self.state = 3570
                        self.match(WFLParser.RP)


                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StorageUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_storageUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorageUnit" ):
                listener.enterStorageUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorageUnit" ):
                listener.exitStorageUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStorageUnit" ):
                return visitor.visitStorageUnit(self)
            else:
                return visitor.visitChildren(self)




    def storageUnit(self):

        localctx = WFLParser.StorageUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 574, self.RULE_storageUnit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3577
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(WFLParser.DO, 0)

        def statements(self):
            return self.getTypedRuleContext(WFLParser.StatementsContext,0)


        def UNTIL(self):
            return self.getToken(WFLParser.UNTIL, 0)

        def condition(self):
            return self.getTypedRuleContext(WFLParser.ConditionContext,0)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_doStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoStatement" ):
                listener.enterDoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoStatement" ):
                listener.exitDoStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoStatement" ):
                return visitor.visitDoStatement(self)
            else:
                return visitor.visitChildren(self)




    def doStatement(self):

        localctx = WFLParser.DoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 576, self.RULE_doStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3579
            self.match(WFLParser.DO)
            self.state = 3581
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,416,self._ctx)
            if la_ == 1:
                self.state = 3580
                self.match(WFLParser.BEGIN)


            self.state = 3583
            self.statements()
            self.state = 3585
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==204:
                self.state = 3584
                self.match(WFLParser.END)


            self.state = 3588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 3587
                self.match(WFLParser.SEMICOLON)


            self.state = 3590
            self.match(WFLParser.UNTIL)
            self.state = 3591
            self.condition()
            self.state = 3592
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(WFLParser.WHILE, 0)

        def condition(self):
            return self.getTypedRuleContext(WFLParser.ConditionContext,0)


        def DO(self):
            return self.getToken(WFLParser.DO, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_whileStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStatement" ):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)




    def whileStatement(self):

        localctx = WFLParser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 578, self.RULE_whileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3594
            self.match(WFLParser.WHILE)
            self.state = 3595
            self.condition()
            self.state = 3596
            self.match(WFLParser.DO)
            self.state = 3606
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,420,self._ctx)
            if la_ == 1:
                self.state = 3597
                self.match(WFLParser.BEGIN)
                self.state = 3599 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3598
                    self.statement()
                    self.state = 3601 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0)):
                        break

                self.state = 3603
                self.match(WFLParser.END)
                pass

            elif la_ == 2:
                self.state = 3605
                self.statement()
                pass


            self.state = 3608
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(WFLParser.CASE, 0)

        def caseExpression(self):
            return self.getTypedRuleContext(WFLParser.CaseExpressionContext,0)


        def OF(self):
            return self.getToken(WFLParser.OF, 0)

        def BEGIN(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.BEGIN)
            else:
                return self.getToken(WFLParser.BEGIN, i)

        def caseClauses(self):
            return self.getTypedRuleContext(WFLParser.CaseClausesContext,0)


        def END(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.END)
            else:
                return self.getToken(WFLParser.END, i)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def ELSE(self):
            return self.getToken(WFLParser.ELSE, 0)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_caseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStatement" ):
                listener.enterCaseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStatement" ):
                listener.exitCaseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseStatement" ):
                return visitor.visitCaseStatement(self)
            else:
                return visitor.visitChildren(self)




    def caseStatement(self):

        localctx = WFLParser.CaseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 580, self.RULE_caseStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3610
            self.match(WFLParser.CASE)
            self.state = 3611
            self.caseExpression()
            self.state = 3612
            self.match(WFLParser.OF)
            self.state = 3613
            self.match(WFLParser.BEGIN)
            self.state = 3614
            self.caseClauses()
            self.state = 3634
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==203:
                self.state = 3615
                self.match(WFLParser.ELSE)
                self.state = 3617
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==15:
                    self.state = 3616
                    self.match(WFLParser.COLON)


                self.state = 3620
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,422,self._ctx)
                if la_ == 1:
                    self.state = 3619
                    self.match(WFLParser.BEGIN)


                self.state = 3625
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0):
                    self.state = 3622
                    self.statement()
                    self.state = 3627
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3629
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,424,self._ctx)
                if la_ == 1:
                    self.state = 3628
                    self.match(WFLParser.END)


                self.state = 3632
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==20:
                    self.state = 3631
                    self.match(WFLParser.SEMICOLON)




            self.state = 3636
            self.match(WFLParser.END)
            self.state = 3637
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(WFLParser.StringExpressionContext,0)


        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpression" ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpression" ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpression" ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = WFLParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 582, self.RULE_caseExpression)
        try:
            self.state = 3642
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,427,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3639
                self.integerExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3640
                self.stringExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3641
                self.match(WFLParser.Identifier)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(WFLParser.CaseClauseContext,i)


        def getRuleIndex(self):
            return WFLParser.RULE_caseClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClauses" ):
                listener.enterCaseClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClauses" ):
                listener.exitCaseClauses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseClauses" ):
                return visitor.visitCaseClauses(self)
            else:
                return visitor.visitChildren(self)




    def caseClauses(self):

        localctx = WFLParser.CaseClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 584, self.RULE_caseClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3645 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3644
                self.caseClause()
                self.state = 3647 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==12):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def caseConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.CaseConstantExpressionContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COLON(self):
            return self.getToken(WFLParser.COLON, 0)

        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseClause" ):
                return visitor.visitCaseClause(self)
            else:
                return visitor.visitChildren(self)




    def caseClause(self):

        localctx = WFLParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 586, self.RULE_caseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3649
            self.match(WFLParser.LP)
            self.state = 3650
            self.caseConstantExpression()
            self.state = 3651
            self.match(WFLParser.RP)
            self.state = 3652
            self.match(WFLParser.COLON)
            self.state = 3662
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,430,self._ctx)
            if la_ == 1:
                self.state = 3653
                self.match(WFLParser.BEGIN)
                self.state = 3655 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3654
                    self.statement()
                    self.state = 3657 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0)):
                        break

                self.state = 3659
                self.match(WFLParser.END)
                pass

            elif la_ == 2:
                self.state = 3661
                self.statement()
                pass


            self.state = 3665
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 3664
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseConstantExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerConstantExpressionContext,0)


        def stringConstantExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StringConstantExpressionContext)
            else:
                return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_caseConstantExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseConstantExpression" ):
                listener.enterCaseConstantExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseConstantExpression" ):
                listener.exitCaseConstantExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseConstantExpression" ):
                return visitor.visitCaseConstantExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseConstantExpression(self):

        localctx = WFLParser.CaseConstantExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 588, self.RULE_caseConstantExpression)
        self._la = 0 # Token type
        try:
            self.state = 3676
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,433,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3667
                self.integerConstantExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3668
                self.stringConstantExpression()
                self.state = 3673
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 3669
                    self.match(WFLParser.COMMA)
                    self.state = 3670
                    self.stringConstantExpression()
                    self.state = 3675
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTER(self):
            return self.getToken(WFLParser.ALTER, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def alterAttributeList(self):
            return self.getTypedRuleContext(WFLParser.AlterAttributeListContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def longFileTitle(self):
            return self.getTypedRuleContext(WFLParser.LongFileTitleContext,0)


        def longDirectoryTitle(self):
            return self.getTypedRuleContext(WFLParser.LongDirectoryTitleContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_alterStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterStatement" ):
                listener.enterAlterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterStatement" ):
                listener.exitAlterStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterStatement" ):
                return visitor.visitAlterStatement(self)
            else:
                return visitor.visitChildren(self)




    def alterStatement(self):

        localctx = WFLParser.AlterStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 590, self.RULE_alterStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3678
            self.match(WFLParser.ALTER)
            self.state = 3681
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,434,self._ctx)
            if la_ == 1:
                self.state = 3679
                self.longFileTitle()
                pass

            elif la_ == 2:
                self.state = 3680
                self.longDirectoryTitle()
                pass


            self.state = 3685
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 3683
                self.match(WFLParser.ON)
                self.state = 3684
                self.storageUnit()


            self.state = 3687
            self.match(WFLParser.LP)
            self.state = 3688
            self.alterAttributeList()
            self.state = 3689
            self.match(WFLParser.RP)
            self.state = 3690
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LongFileTitleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_longFileTitle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLongFileTitle" ):
                listener.enterLongFileTitle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLongFileTitle" ):
                listener.exitLongFileTitle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLongFileTitle" ):
                return visitor.visitLongFileTitle(self)
            else:
                return visitor.visitChildren(self)




    def longFileTitle(self):

        localctx = WFLParser.LongFileTitleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 592, self.RULE_longFileTitle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3692
            self.filePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LongDirectoryTitleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_longDirectoryTitle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLongDirectoryTitle" ):
                listener.enterLongDirectoryTitle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLongDirectoryTitle" ):
                listener.exitLongDirectoryTitle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLongDirectoryTitle" ):
                return visitor.visitLongDirectoryTitle(self)
            else:
                return visitor.visitChildren(self)




    def longDirectoryTitle(self):

        localctx = WFLParser.LongDirectoryTitleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 594, self.RULE_longDirectoryTitle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3694
            self.filePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterAttributeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alterAttribute(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.AlterAttributeContext)
            else:
                return self.getTypedRuleContext(WFLParser.AlterAttributeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_alterAttributeList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterAttributeList" ):
                listener.enterAlterAttributeList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterAttributeList" ):
                listener.exitAlterAttributeList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterAttributeList" ):
                return visitor.visitAlterAttributeList(self)
            else:
                return visitor.visitChildren(self)




    def alterAttributeList(self):

        localctx = WFLParser.AlterAttributeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 596, self.RULE_alterAttributeList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3696
            self.alterAttribute()
            self.state = 3701
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3697
                self.match(WFLParser.COMMA)
                self.state = 3698
                self.alterAttribute()
                self.state = 3703
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterAttributeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTERNATEGROUPS(self):
            return self.getToken(WFLParser.ALTERNATEGROUPS, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def alternategroupsValue(self):
            return self.getTypedRuleContext(WFLParser.AlternategroupsValueContext,0)


        def PROPAGATESECURITYTODIRS(self):
            return self.getToken(WFLParser.PROPAGATESECURITYTODIRS, 0)

        def DONTPROPAGATE(self):
            return self.getToken(WFLParser.DONTPROPAGATE, 0)

        def PROPAGATE(self):
            return self.getToken(WFLParser.PROPAGATE, 0)

        def PROPAGATESECURITYTOFILES(self):
            return self.getToken(WFLParser.PROPAGATESECURITYTOFILES, 0)

        def ALIGNFILE(self):
            return self.getToken(WFLParser.ALIGNFILE, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def ALIGNMENT(self):
            return self.getToken(WFLParser.ALIGNMENT, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanExpressionContext,0)


        def APL(self):
            return self.getToken(WFLParser.APL, 0)

        def BANNER(self):
            return self.getToken(WFLParser.BANNER, 0)

        def LOCKEDFILE(self):
            return self.getToken(WFLParser.LOCKEDFILE, 0)

        def SECURITYADMIN(self):
            return self.getToken(WFLParser.SECURITYADMIN, 0)

        def SENSITIVEDATA(self):
            return self.getToken(WFLParser.SENSITIVEDATA, 0)

        def CCSVERSION(self):
            return self.getToken(WFLParser.CCSVERSION, 0)

        def mnemonicValue(self):
            return self.getTypedRuleContext(WFLParser.MnemonicValueContext,0)


        def EXTMODE(self):
            return self.getToken(WFLParser.EXTMODE, 0)

        def FORMID(self):
            return self.getToken(WFLParser.FORMID, 0)

        def stringPrimary(self):
            return self.getTypedRuleContext(WFLParser.StringPrimaryContext,0)


        def PAGECOMP(self):
            return self.getToken(WFLParser.PAGECOMP, 0)

        def TRANSFORM(self):
            return self.getToken(WFLParser.TRANSFORM, 0)

        def groupExpression(self):
            return self.getTypedRuleContext(WFLParser.GroupExpressionContext,0)


        def EXTDELIMITER(self):
            return self.getToken(WFLParser.EXTDELIMITER, 0)

        def mnemonic(self):
            return self.getTypedRuleContext(WFLParser.MnemonicContext,0)


        def FILEKIND(self):
            return self.getToken(WFLParser.FILEKIND, 0)

        def LABEL(self):
            return self.getToken(WFLParser.LABEL, 0)

        def PRINTERKIND(self):
            return self.getToken(WFLParser.PRINTERKIND, 0)

        def TRAINID(self):
            return self.getToken(WFLParser.TRAINID, 0)

        def NOTE(self):
            return self.getToken(WFLParser.NOTE, 0)

        def PRODUCT(self):
            return self.getToken(WFLParser.PRODUCT, 0)

        def RELEASEID(self):
            return self.getToken(WFLParser.RELEASEID, 0)

        def SAVEFACTOR(self):
            return self.getToken(WFLParser.SAVEFACTOR, 0)

        def integerExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerExpressionContext,0)


        def SECURITYGUARD(self):
            return self.getToken(WFLParser.SECURITYGUARD, 0)

        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def SECURITYMODE(self):
            return self.getToken(WFLParser.SECURITYMODE, 0)

        def SECURITYTYPE(self):
            return self.getToken(WFLParser.SECURITYTYPE, 0)

        def fileMnemonicPrimary(self):
            return self.getTypedRuleContext(WFLParser.FileMnemonicPrimaryContext,0)


        def SECURITYUSE(self):
            return self.getToken(WFLParser.SECURITYUSE, 0)

        def USERINFO(self):
            return self.getToken(WFLParser.USERINFO, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_alterAttribute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlterAttribute" ):
                listener.enterAlterAttribute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlterAttribute" ):
                listener.exitAlterAttribute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterAttribute" ):
                return visitor.visitAlterAttribute(self)
            else:
                return visitor.visitChildren(self)




    def alterAttribute(self):

        localctx = WFLParser.AlterAttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 598, self.RULE_alterAttribute)
        self._la = 0 # Token type
        try:
            self.state = 3795
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [50]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3704
                self.match(WFLParser.ALTERNATEGROUPS)
                self.state = 3705
                self.match(WFLParser.EQUAL)
                self.state = 3706
                self.alternategroupsValue()
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3707
                self.match(WFLParser.PROPAGATESECURITYTODIRS)
                self.state = 3708
                self.match(WFLParser.EQUAL)
                self.state = 3709
                _la = self._input.LA(1)
                if not(_la==67 or _la==71):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3710
                self.match(WFLParser.PROPAGATESECURITYTOFILES)
                self.state = 3711
                self.match(WFLParser.EQUAL)
                self.state = 3712
                _la = self._input.LA(1)
                if not(_la==67 or _la==71):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [426]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3713
                self.match(WFLParser.ALIGNFILE)
                self.state = 3714
                self.match(WFLParser.EQUAL)
                self.state = 3715
                self.filePath()
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3716
                self.match(WFLParser.ALIGNMENT)
                self.state = 3717
                self.match(WFLParser.EQUAL)
                self.state = 3718
                self.booleanExpression()
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3719
                self.match(WFLParser.APL)
                self.state = 3720
                self.match(WFLParser.EQUAL)
                self.state = 3721
                self.booleanExpression()
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3722
                self.match(WFLParser.BANNER)
                self.state = 3723
                self.match(WFLParser.EQUAL)
                self.state = 3724
                self.booleanExpression()
                pass
            elif token in [84]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3725
                self.match(WFLParser.LOCKEDFILE)
                self.state = 3726
                self.match(WFLParser.EQUAL)
                self.state = 3727
                self.booleanExpression()
                pass
            elif token in [85]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3728
                self.match(WFLParser.SECURITYADMIN)
                self.state = 3729
                self.match(WFLParser.EQUAL)
                self.state = 3730
                self.booleanExpression()
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3731
                self.match(WFLParser.SENSITIVEDATA)
                self.state = 3732
                self.match(WFLParser.EQUAL)
                self.state = 3733
                self.booleanExpression()
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 11)
                self.state = 3734
                self.match(WFLParser.CCSVERSION)
                self.state = 3735
                self.match(WFLParser.EQUAL)
                self.state = 3736
                self.mnemonicValue()
                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 12)
                self.state = 3737
                self.match(WFLParser.EXTMODE)
                self.state = 3738
                self.match(WFLParser.EQUAL)
                self.state = 3739
                self.mnemonicValue()
                pass
            elif token in [420]:
                self.enterOuterAlt(localctx, 13)
                self.state = 3740
                self.match(WFLParser.FORMID)
                self.state = 3741
                self.match(WFLParser.EQUAL)
                self.state = 3742
                self.stringPrimary()
                pass
            elif token in [98]:
                self.enterOuterAlt(localctx, 14)
                self.state = 3743
                self.match(WFLParser.PAGECOMP)
                self.state = 3744
                self.match(WFLParser.EQUAL)
                self.state = 3745
                self.booleanExpression()
                pass
            elif token in [99]:
                self.enterOuterAlt(localctx, 15)
                self.state = 3746
                self.match(WFLParser.TRANSFORM)
                self.state = 3747
                self.match(WFLParser.EQUAL)
                self.state = 3748
                self.booleanExpression()
                pass
            elif token in [49, 119, 131, 132, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147]:
                self.enterOuterAlt(localctx, 16)
                self.state = 3749
                self.groupExpression()
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 17)
                self.state = 3750
                self.match(WFLParser.EXTDELIMITER)
                self.state = 3751
                self.match(WFLParser.EQUAL)
                self.state = 3752
                self.mnemonic()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 18)
                self.state = 3753
                self.match(WFLParser.FILEKIND)
                self.state = 3754
                self.match(WFLParser.EQUAL)
                self.state = 3755
                self.mnemonic()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 19)
                self.state = 3756
                self.match(WFLParser.LABEL)
                self.state = 3757
                self.match(WFLParser.EQUAL)
                self.state = 3758
                self.mnemonic()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 20)
                self.state = 3759
                self.match(WFLParser.PRINTERKIND)
                self.state = 3760
                self.match(WFLParser.EQUAL)
                self.state = 3761
                self.mnemonic()
                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 21)
                self.state = 3762
                self.match(WFLParser.TRAINID)
                self.state = 3763
                self.match(WFLParser.EQUAL)
                self.state = 3764
                self.mnemonic()
                pass
            elif token in [422]:
                self.enterOuterAlt(localctx, 22)
                self.state = 3765
                self.match(WFLParser.NOTE)
                self.state = 3766
                self.match(WFLParser.EQUAL)
                self.state = 3767
                self.stringPrimary()
                pass
            elif token in [108]:
                self.enterOuterAlt(localctx, 23)
                self.state = 3768
                self.match(WFLParser.PRODUCT)
                self.state = 3769
                self.match(WFLParser.EQUAL)
                self.state = 3770
                self.stringPrimary()
                pass
            elif token in [424]:
                self.enterOuterAlt(localctx, 24)
                self.state = 3771
                self.match(WFLParser.RELEASEID)
                self.state = 3772
                self.match(WFLParser.EQUAL)
                self.state = 3773
                self.stringPrimary()
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 25)
                self.state = 3774
                self.match(WFLParser.SAVEFACTOR)
                self.state = 3775
                self.match(WFLParser.EQUAL)
                self.state = 3776
                self.integerExpression()
                pass
            elif token in [429]:
                self.enterOuterAlt(localctx, 26)
                self.state = 3777
                self.match(WFLParser.SECURITYGUARD)
                self.state = 3778
                self.match(WFLParser.EQUAL)
                self.state = 3781
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 12, 16, 18, 23, 24, 26, 27, 28, 29, 32, 33, 34, 35, 36, 37, 38, 39, 46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 171, 172, 173, 174, 175, 176, 177, 182, 187, 189, 192, 195, 200, 201, 202, 205, 207, 208, 209, 210, 211, 217, 219, 220, 221, 222, 223, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 282, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 391, 394, 398, 418, 438, 442, 444, 446, 447, 448, 449]:
                    self.state = 3779
                    self.filePath()
                    pass
                elif token in [2]:
                    self.state = 3780
                    self.match(WFLParser.EMPTYSTRING)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [110]:
                self.enterOuterAlt(localctx, 27)
                self.state = 3783
                self.match(WFLParser.SECURITYMODE)
                self.state = 3784
                self.match(WFLParser.EQUAL)
                self.state = 3785
                self.integerExpression()
                pass
            elif token in [399]:
                self.enterOuterAlt(localctx, 28)
                self.state = 3786
                self.match(WFLParser.SECURITYTYPE)
                self.state = 3787
                self.match(WFLParser.EQUAL)
                self.state = 3788
                self.fileMnemonicPrimary()
                pass
            elif token in [111]:
                self.enterOuterAlt(localctx, 29)
                self.state = 3789
                self.match(WFLParser.SECURITYUSE)
                self.state = 3790
                self.match(WFLParser.EQUAL)
                self.state = 3791
                self.fileMnemonicPrimary()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 30)
                self.state = 3792
                self.match(WFLParser.USERINFO)
                self.state = 3793
                self.match(WFLParser.EQUAL)
                self.state = 3794
                self.integerExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlternategroupsValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def HASH(self):
            return self.getToken(WFLParser.HASH, 0)

        def stringPrimary(self):
            return self.getTypedRuleContext(WFLParser.StringPrimaryContext,0)


        def STRING(self):
            return self.getToken(WFLParser.STRING, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_alternategroupsValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlternategroupsValue" ):
                listener.enterAlternategroupsValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlternategroupsValue" ):
                listener.exitAlternategroupsValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlternategroupsValue" ):
                return visitor.visitAlternategroupsValue(self)
            else:
                return visitor.visitChildren(self)




    def alternategroupsValue(self):

        localctx = WFLParser.AlternategroupsValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 600, self.RULE_alternategroupsValue)
        try:
            self.state = 3801
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3797
                self.match(WFLParser.EMPTYSTRING)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3798
                self.match(WFLParser.HASH)
                self.state = 3799
                self.stringPrimary()
                pass
            elif token in [235]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3800
                self.match(WFLParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(WFLParser.GROUP, 0)

        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def nameConstant(self):
            return self.getTypedRuleContext(WFLParser.NameConstantContext,0)


        def HASH(self):
            return self.getToken(WFLParser.HASH, 0)

        def stringPrimary(self):
            return self.getTypedRuleContext(WFLParser.StringPrimaryContext,0)


        def EMPTYSTRING(self):
            return self.getToken(WFLParser.EMPTYSTRING, 0)

        def OWNER(self):
            return self.getToken(WFLParser.OWNER, 0)

        def GROUPRWX(self):
            return self.getToken(WFLParser.GROUPRWX, 0)

        def mnemonic(self):
            return self.getTypedRuleContext(WFLParser.MnemonicContext,0)


        def OTHERRWX(self):
            return self.getToken(WFLParser.OTHERRWX, 0)

        def OWNERRWX(self):
            return self.getToken(WFLParser.OWNERRWX, 0)

        def GROUPR(self):
            return self.getToken(WFLParser.GROUPR, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanExpressionContext,0)


        def GROUPW(self):
            return self.getToken(WFLParser.GROUPW, 0)

        def GROUPX(self):
            return self.getToken(WFLParser.GROUPX, 0)

        def OTHERR(self):
            return self.getToken(WFLParser.OTHERR, 0)

        def OTHERW(self):
            return self.getToken(WFLParser.OTHERW, 0)

        def OTHERX(self):
            return self.getToken(WFLParser.OTHERX, 0)

        def OWNERR(self):
            return self.getToken(WFLParser.OWNERR, 0)

        def OWNERW(self):
            return self.getToken(WFLParser.OWNERW, 0)

        def OWNERX(self):
            return self.getToken(WFLParser.OWNERX, 0)

        def SETUSERCODE(self):
            return self.getToken(WFLParser.SETUSERCODE, 0)

        def SETGROUPCODE(self):
            return self.getToken(WFLParser.SETGROUPCODE, 0)

        def USEGUARDFILE(self):
            return self.getToken(WFLParser.USEGUARDFILE, 0)

        def GUARDOWNER(self):
            return self.getToken(WFLParser.GUARDOWNER, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_groupExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupExpression" ):
                listener.enterGroupExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupExpression" ):
                listener.exitGroupExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupExpression" ):
                return visitor.visitGroupExpression(self)
            else:
                return visitor.visitChildren(self)




    def groupExpression(self):

        localctx = WFLParser.GroupExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 602, self.RULE_groupExpression)
        try:
            self.state = 3867
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3803
                self.match(WFLParser.GROUP)
                self.state = 3804
                self.match(WFLParser.EQUAL)
                self.state = 3809
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 3805
                    self.nameConstant()
                    pass
                elif token in [18]:
                    self.state = 3806
                    self.match(WFLParser.HASH)
                    self.state = 3807
                    self.stringPrimary()
                    pass
                elif token in [2]:
                    self.state = 3808
                    self.match(WFLParser.EMPTYSTRING)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [131]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3811
                self.match(WFLParser.OWNER)
                self.state = 3812
                self.match(WFLParser.EQUAL)
                self.state = 3817
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 3813
                    self.nameConstant()
                    pass
                elif token in [18]:
                    self.state = 3814
                    self.match(WFLParser.HASH)
                    self.state = 3815
                    self.stringPrimary()
                    pass
                elif token in [2]:
                    self.state = 3816
                    self.match(WFLParser.EMPTYSTRING)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [132]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3819
                self.match(WFLParser.GROUPRWX)
                self.state = 3820
                self.match(WFLParser.EQUAL)
                self.state = 3821
                self.mnemonic()
                pass
            elif token in [134]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3822
                self.match(WFLParser.OTHERRWX)
                self.state = 3823
                self.match(WFLParser.EQUAL)
                self.state = 3824
                self.mnemonic()
                pass
            elif token in [135]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3825
                self.match(WFLParser.OWNERRWX)
                self.state = 3826
                self.match(WFLParser.EQUAL)
                self.state = 3827
                self.mnemonic()
                pass
            elif token in [136]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3828
                self.match(WFLParser.GROUPR)
                self.state = 3829
                self.match(WFLParser.EQUAL)
                self.state = 3830
                self.booleanExpression()
                pass
            elif token in [137]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3831
                self.match(WFLParser.GROUPW)
                self.state = 3832
                self.match(WFLParser.EQUAL)
                self.state = 3833
                self.booleanExpression()
                pass
            elif token in [138]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3834
                self.match(WFLParser.GROUPX)
                self.state = 3835
                self.match(WFLParser.EQUAL)
                self.state = 3836
                self.booleanExpression()
                pass
            elif token in [139]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3837
                self.match(WFLParser.OTHERR)
                self.state = 3838
                self.match(WFLParser.EQUAL)
                self.state = 3839
                self.booleanExpression()
                pass
            elif token in [140]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3840
                self.match(WFLParser.OTHERW)
                self.state = 3841
                self.match(WFLParser.EQUAL)
                self.state = 3842
                self.booleanExpression()
                pass
            elif token in [141]:
                self.enterOuterAlt(localctx, 11)
                self.state = 3843
                self.match(WFLParser.OTHERX)
                self.state = 3844
                self.match(WFLParser.EQUAL)
                self.state = 3845
                self.booleanExpression()
                pass
            elif token in [142]:
                self.enterOuterAlt(localctx, 12)
                self.state = 3846
                self.match(WFLParser.OWNERR)
                self.state = 3847
                self.match(WFLParser.EQUAL)
                self.state = 3848
                self.booleanExpression()
                pass
            elif token in [143]:
                self.enterOuterAlt(localctx, 13)
                self.state = 3849
                self.match(WFLParser.OWNERW)
                self.state = 3850
                self.match(WFLParser.EQUAL)
                self.state = 3851
                self.booleanExpression()
                pass
            elif token in [144]:
                self.enterOuterAlt(localctx, 14)
                self.state = 3852
                self.match(WFLParser.OWNERX)
                self.state = 3853
                self.match(WFLParser.EQUAL)
                self.state = 3854
                self.booleanExpression()
                pass
            elif token in [145]:
                self.enterOuterAlt(localctx, 15)
                self.state = 3855
                self.match(WFLParser.SETUSERCODE)
                self.state = 3856
                self.match(WFLParser.EQUAL)
                self.state = 3857
                self.booleanExpression()
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 16)
                self.state = 3858
                self.match(WFLParser.SETGROUPCODE)
                self.state = 3859
                self.match(WFLParser.EQUAL)
                self.state = 3860
                self.booleanExpression()
                pass
            elif token in [146]:
                self.enterOuterAlt(localctx, 17)
                self.state = 3861
                self.match(WFLParser.USEGUARDFILE)
                self.state = 3862
                self.match(WFLParser.EQUAL)
                self.state = 3863
                self.booleanExpression()
                pass
            elif token in [147]:
                self.enterOuterAlt(localctx, 18)
                self.state = 3864
                self.match(WFLParser.GUARDOWNER)
                self.state = 3865
                self.match(WFLParser.EQUAL)
                self.state = 3866
                self.booleanExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MnemonicValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_mnemonicValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMnemonicValue" ):
                listener.enterMnemonicValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMnemonicValue" ):
                listener.exitMnemonicValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMnemonicValue" ):
                return visitor.visitMnemonicValue(self)
            else:
                return visitor.visitChildren(self)




    def mnemonicValue(self):

        localctx = WFLParser.MnemonicValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 604, self.RULE_mnemonicValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3869
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileMnemonicPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fileMnemonicPrimary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileMnemonicPrimary" ):
                listener.enterFileMnemonicPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileMnemonicPrimary" ):
                listener.exitFileMnemonicPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileMnemonicPrimary" ):
                return visitor.visitFileMnemonicPrimary(self)
            else:
                return visitor.visitChildren(self)




    def fileMnemonicPrimary(self):

        localctx = WFLParser.FileMnemonicPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 606, self.RULE_fileMnemonicPrimary)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3871
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_nameConstant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNameConstant" ):
                listener.enterNameConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNameConstant" ):
                listener.exitNameConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNameConstant" ):
                return visitor.visitNameConstant(self)
            else:
                return visitor.visitChildren(self)




    def nameConstant(self):

        localctx = WFLParser.NameConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 608, self.RULE_nameConstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3873
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MnemonicContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RWX(self):
            return self.getToken(WFLParser.RWX, 0)

        def RW(self):
            return self.getToken(WFLParser.RW, 0)

        def RX(self):
            return self.getToken(WFLParser.RX, 0)

        def WX(self):
            return self.getToken(WFLParser.WX, 0)

        def NO(self):
            return self.getToken(WFLParser.NO, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_mnemonic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMnemonic" ):
                listener.enterMnemonic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMnemonic" ):
                listener.exitMnemonic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMnemonic" ):
                return visitor.visitMnemonic(self)
            else:
                return visitor.visitChildren(self)




    def mnemonic(self):

        localctx = WFLParser.MnemonicContext(self, self._ctx, self.state)
        self.enterRule(localctx, 610, self.RULE_mnemonic)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3875
            _la = self._input.LA(1)
            if not(((((_la - 148)) & ~0x3f) == 0 and ((1 << (_la - 148)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHANGE(self):
            return self.getToken(WFLParser.CHANGE, 0)

        def changeItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ChangeItemContext)
            else:
                return self.getTypedRuleContext(WFLParser.ChangeItemContext,i)


        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def familyName(self):
            return self.getTypedRuleContext(WFLParser.FamilyNameContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_changeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeStatement" ):
                listener.enterChangeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeStatement" ):
                listener.exitChangeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeStatement" ):
                return visitor.visitChangeStatement(self)
            else:
                return visitor.visitChildren(self)




    def changeStatement(self):

        localctx = WFLParser.ChangeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 612, self.RULE_changeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3877
            self.match(WFLParser.CHANGE)
            self.state = 3878
            self.changeItem()
            self.state = 3881
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 3879
                self.match(WFLParser.ON)
                self.state = 3880
                self.familyName()


            self.state = 3883
            self.match(WFLParser.TO)
            self.state = 3884
            self.changeItem()
            self.state = 3886
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==216:
                self.state = 3885
                self.fromClause()


            self.state = 3888
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_changeItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChangeItem" ):
                listener.enterChangeItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChangeItem" ):
                listener.exitChangeItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChangeItem" ):
                return visitor.visitChangeItem(self)
            else:
                return visitor.visitChildren(self)




    def changeItem(self):

        localctx = WFLParser.ChangeItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 614, self.RULE_changeItem)
        try:
            self.state = 3892
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,445,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3890
                self.filePath()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3891
                self.fileReferencedVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CrunchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CRUNCH(self):
            return self.getToken(WFLParser.CRUNCH, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_crunchStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCrunchStatement" ):
                listener.enterCrunchStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCrunchStatement" ):
                listener.exitCrunchStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCrunchStatement" ):
                return visitor.visitCrunchStatement(self)
            else:
                return visitor.visitChildren(self)




    def crunchStatement(self):

        localctx = WFLParser.CrunchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 616, self.RULE_crunchStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3894
            self.match(WFLParser.CRUNCH)
            self.state = 3895
            self.match(WFLParser.LP)
            self.state = 3896
            self.fileIdentifier()
            self.state = 3897
            self.match(WFLParser.RP)
            self.state = 3898
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GO(self):
            return self.getToken(WFLParser.GO, 0)

        def labelIdentifer(self):
            return self.getTypedRuleContext(WFLParser.LabelIdentiferContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_goStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoStatement" ):
                listener.enterGoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoStatement" ):
                listener.exitGoStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoStatement" ):
                return visitor.visitGoStatement(self)
            else:
                return visitor.visitChildren(self)




    def goStatement(self):

        localctx = WFLParser.GoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 618, self.RULE_goStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3900
            self.match(WFLParser.GO)
            self.state = 3902
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 3901
                self.match(WFLParser.TO)


            self.state = 3904
            self.labelIdentifer()
            self.state = 3905
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelIdentiferContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_labelIdentifer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelIdentifer" ):
                listener.enterLabelIdentifer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelIdentifer" ):
                listener.exitLabelIdentifer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelIdentifer" ):
                return visitor.visitLabelIdentifer(self)
            else:
                return visitor.visitChildren(self)




    def labelIdentifer(self):

        localctx = WFLParser.LabelIdentiferContext(self, self._ctx, self.state)
        self.enterRule(localctx, 620, self.RULE_labelIdentifer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3907
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODIFY(self):
            return self.getToken(WFLParser.MODIFY, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def runParameterList(self):
            return self.getTypedRuleContext(WFLParser.RunParameterListContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def taskIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.TaskIdentifierContext)
            else:
                return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def taskEquationList(self):
            return self.getTypedRuleContext(WFLParser.TaskEquationListContext,0)


        def localDataSpecification(self):
            return self.getTypedRuleContext(WFLParser.LocalDataSpecificationContext,0)


        def QMARK(self):
            return self.getToken(WFLParser.QMARK, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_modifyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifyStatement" ):
                listener.enterModifyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifyStatement" ):
                listener.exitModifyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifyStatement" ):
                return visitor.visitModifyStatement(self)
            else:
                return visitor.visitChildren(self)




    def modifyStatement(self):

        localctx = WFLParser.ModifyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 622, self.RULE_modifyStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3909
            self.match(WFLParser.MODIFY)
            self.state = 3912
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,447,self._ctx)
            if la_ == 1:
                self.state = 3910
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 3911
                self.fileReferencedVariable()
                pass


            self.state = 3919
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 3914
                self.match(WFLParser.ON)
                self.state = 3917
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 3915
                    self.storageUnit()
                    pass
                elif token in [201, 209, 211, 219]:
                    self.state = 3916
                    self.reservedKeyword()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 3922
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,450,self._ctx)
            if la_ == 1:
                self.state = 3921
                self.runParameterList()


            self.state = 3928
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 3924
                self.match(WFLParser.LP)
                self.state = 3925
                self.taskIdentifier()
                self.state = 3926
                self.match(WFLParser.RP)


            self.state = 3931
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,452,self._ctx)
            if la_ == 1:
                self.state = 3930
                self.match(WFLParser.SEMICOLON)


            self.state = 3937
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 3933
                self.match(WFLParser.LS)
                self.state = 3934
                self.taskIdentifier()
                self.state = 3935
                self.match(WFLParser.RS)


            self.state = 3939
            self.match(WFLParser.SEMICOLON)
            self.state = 3941
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,454,self._ctx)
            if la_ == 1:
                self.state = 3940
                self.taskEquationList()


            self.state = 3946
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,455,self._ctx)
            if la_ == 1:
                self.state = 3943
                self.localDataSpecification()
                self.state = 3944
                self.match(WFLParser.QMARK)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_onClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnClause" ):
                listener.enterOnClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnClause" ):
                listener.exitOnClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnClause" ):
                return visitor.visitOnClause(self)
            else:
                return visitor.visitChildren(self)




    def onClause(self):

        localctx = WFLParser.OnClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 624, self.RULE_onClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3948
            self.match(WFLParser.ON)
            self.state = 3949
            self.match(WFLParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemoveStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMOVE(self):
            return self.getToken(WFLParser.REMOVE, 0)

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FilePathContext)
            else:
                return self.getTypedRuleContext(WFLParser.FilePathContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def onClause(self):
            return self.getTypedRuleContext(WFLParser.OnClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(WFLParser.FromClauseContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_removeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveStatement" ):
                listener.enterRemoveStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveStatement" ):
                listener.exitRemoveStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemoveStatement" ):
                return visitor.visitRemoveStatement(self)
            else:
                return visitor.visitChildren(self)




    def removeStatement(self):

        localctx = WFLParser.RemoveStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 626, self.RULE_removeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3951
            self.match(WFLParser.REMOVE)

            self.state = 3952
            self.filePath()
            self.state = 3957
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 3953
                self.match(WFLParser.COMMA)
                self.state = 3954
                self.filePath()
                self.state = 3959
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3962
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,457,self._ctx)
            if la_ == 1:
                self.state = 3960
                self.onClause()

            elif la_ == 2:
                self.state = 3961
                self.fromClause()


            self.state = 3965
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,458,self._ctx)
            if la_ == 1:
                self.state = 3964
                self.match(WFLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(WFLParser.FROM, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fromClauseParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.FromClauseParameterContext)
            else:
                return self.getTypedRuleContext(WFLParser.FromClauseParameterContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = WFLParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 628, self.RULE_fromClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3967
            self.match(WFLParser.FROM)
            self.state = 3971
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.state = 3968
                self.storageUnit()
                pass
            elif token in [18]:
                self.state = 3969
                self.fileReferencedVariable()
                pass
            elif token in [201, 209, 211, 219]:
                self.state = 3970
                self.reservedKeyword()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 3984
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,461,self._ctx)
            if la_ == 1:
                self.state = 3973
                self.match(WFLParser.LP)
                self.state = 3974
                self.fromClauseParameter()
                self.state = 3979
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 3975
                    self.match(WFLParser.COMMA)
                    self.state = 3976
                    self.fromClauseParameter()
                    self.state = 3981
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3982
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def charDataKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CharDataKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,i)


        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def reservedKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ReservedKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,i)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_fromClauseParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClauseParameter" ):
                listener.enterFromClauseParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClauseParameter" ):
                listener.exitFromClauseParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClauseParameter" ):
                return visitor.visitFromClauseParameter(self)
            else:
                return visitor.visitChildren(self)




    def fromClauseParameter(self):

        localctx = WFLParser.FromClauseParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 630, self.RULE_fromClauseParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3990
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,462,self._ctx)
            if la_ == 1:
                self.state = 3986
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 3987
                self.charDataKeyword()
                pass

            elif la_ == 3:
                self.state = 3988
                self.taskAttribute()
                pass

            elif la_ == 4:
                self.state = 3989
                self.reservedKeyword()
                pass


            self.state = 4000
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 3992
                self.match(WFLParser.EQUAL)
                self.state = 3998
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,463,self._ctx)
                if la_ == 1:
                    self.state = 3993
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 2:
                    self.state = 3994
                    self.charDataKeyword()
                    pass

                elif la_ == 3:
                    self.state = 3995
                    self.reservedKeyword()
                    pass

                elif la_ == 4:
                    self.state = 3996
                    self.filePath()
                    pass

                elif la_ == 5:
                    self.state = 3997
                    self.match(WFLParser.LITERAL)
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def Num(self):
            return self.getToken(WFLParser.Num, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def toClauseParameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ToClauseParametersContext)
            else:
                return self.getTypedRuleContext(WFLParser.ToClauseParametersContext,i)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_toClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToClause" ):
                listener.enterToClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToClause" ):
                listener.exitToClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToClause" ):
                return visitor.visitToClause(self)
            else:
                return visitor.visitChildren(self)




    def toClause(self):

        localctx = WFLParser.ToClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 632, self.RULE_toClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4002
            self.match(WFLParser.TO)
            self.state = 4008
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,465,self._ctx)
            if la_ == 1:
                self.state = 4003
                self.storageUnit()
                pass

            elif la_ == 2:
                self.state = 4004
                self.reservedKeyword()
                pass

            elif la_ == 3:
                self.state = 4005
                self.fileReferencedVariable()
                pass

            elif la_ == 4:
                self.state = 4006
                self.charDataKeyword()
                pass

            elif la_ == 5:
                self.state = 4007
                self.match(WFLParser.Num)
                pass


            self.state = 4021
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,467,self._ctx)
            if la_ == 1:
                self.state = 4010
                self.match(WFLParser.LP)
                self.state = 4011
                self.toClauseParameters()
                self.state = 4016
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 4012
                    self.match(WFLParser.COMMA)
                    self.state = 4013
                    self.toClauseParameters()
                    self.state = 4018
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 4019
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToClauseParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def charDataKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CharDataKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,i)


        def taskAttribute(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeContext,0)


        def reservedKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ReservedKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,i)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def LP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LP)
            else:
                return self.getToken(WFLParser.LP, i)

        def RP(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.RP)
            else:
                return self.getToken(WFLParser.RP, i)

        def filePath(self):
            return self.getTypedRuleContext(WFLParser.FilePathContext,0)


        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.LITERAL)
            else:
                return self.getToken(WFLParser.LITERAL, i)

        def ATS(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.ATS)
            else:
                return self.getToken(WFLParser.ATS, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_toClauseParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToClauseParameters" ):
                listener.enterToClauseParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToClauseParameters" ):
                listener.exitToClauseParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToClauseParameters" ):
                return visitor.visitToClauseParameters(self)
            else:
                return visitor.visitChildren(self)




    def toClauseParameters(self):

        localctx = WFLParser.ToClauseParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 634, self.RULE_toClauseParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4027
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,468,self._ctx)
            if la_ == 1:
                self.state = 4023
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.state = 4024
                self.charDataKeyword()
                pass

            elif la_ == 3:
                self.state = 4025
                self.taskAttribute()
                pass

            elif la_ == 4:
                self.state = 4026
                self.reservedKeyword()
                pass


            self.state = 4056
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 4029
                self.match(WFLParser.EQUAL)
                self.state = 4054
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,471,self._ctx)
                if la_ == 1:
                    self.state = 4030
                    self.match(WFLParser.Identifier)
                    pass

                elif la_ == 2:
                    self.state = 4031
                    self.charDataKeyword()
                    pass

                elif la_ == 3:
                    self.state = 4032
                    self.reservedKeyword()
                    pass

                elif la_ == 4:
                    self.state = 4033
                    self.match(WFLParser.LP)

                    self.state = 4042
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [449]:
                        self.state = 4034
                        self.match(WFLParser.LITERAL)
                        pass
                    elif token in [446]:
                        self.state = 4035
                        self.match(WFLParser.Identifier)
                        pass
                    elif token in [17]:
                        self.state = 4036
                        self.match(WFLParser.ATS)
                        self.state = 4037
                        self.match(WFLParser.Identifier)
                        self.state = 4038
                        self.match(WFLParser.LP)
                        self.state = 4039
                        self.match(WFLParser.Identifier)
                        self.state = 4040
                        self.match(WFLParser.RP)
                        self.state = 4041
                        self.match(WFLParser.ATS)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 4048
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==4:
                        self.state = 4044
                        self.match(WFLParser.COMMA)
                        self.state = 4045
                        _la = self._input.LA(1)
                        if not(_la==446 or _la==449):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 4050
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 4051
                    self.match(WFLParser.RP)
                    pass

                elif la_ == 5:
                    self.state = 4052
                    self.filePath()
                    pass

                elif la_ == 6:
                    self.state = 4053
                    self.booleanConstantExpression()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(WFLParser.ON, 0)

        def TASKFAULT(self):
            return self.getToken(WFLParser.TASKFAULT, 0)

        def RESTART(self):
            return self.getToken(WFLParser.RESTART, 0)

        def COMMA(self):
            return self.getToken(WFLParser.COMMA, 0)

        def BEGIN(self):
            return self.getToken(WFLParser.BEGIN, 0)

        def END(self):
            return self.getToken(WFLParser.END, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.StatementContext)
            else:
                return self.getTypedRuleContext(WFLParser.StatementContext,i)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_onStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnStatement" ):
                listener.enterOnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnStatement" ):
                listener.exitOnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnStatement" ):
                return visitor.visitOnStatement(self)
            else:
                return visitor.visitChildren(self)




    def onStatement(self):

        localctx = WFLParser.OnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 636, self.RULE_onStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4058
            self.match(WFLParser.ON)
            self.state = 4059
            _la = self._input.LA(1)
            if not(_la==48 or _la==377):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 4074
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 4060
                self.match(WFLParser.COMMA)
                self.state = 4072
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,475,self._ctx)
                if la_ == 1:
                    self.state = 4061
                    self.match(WFLParser.BEGIN)
                    self.state = 4063 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 4062
                        self.statement()
                        self.state = 4065 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -1193173525783904256) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -7350015329289895933) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & -160927246989096637) != 0) or ((((_la - 258)) & ~0x3f) == 0 and ((1 << (_la - 258)) & 18155324543537141) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 842173130320644209) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 335544321) != 0)):
                            break

                    self.state = 4067
                    self.match(WFLParser.END)
                    self.state = 4069
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,474,self._ctx)
                    if la_ == 1:
                        self.state = 4068
                        self.match(WFLParser.SEMICOLON)


                    pass

                elif la_ == 2:
                    self.state = 4071
                    self.statement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntoClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTO(self):
            return self.getToken(WFLParser.INTO, 0)

        def storageUnit(self):
            return self.getTypedRuleContext(WFLParser.StorageUnitContext,0)


        def fileReferencedVariable(self):
            return self.getTypedRuleContext(WFLParser.FileReferencedVariableContext,0)


        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.Identifier)
            else:
                return self.getToken(WFLParser.Identifier, i)

        def charDataKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.CharDataKeywordContext)
            else:
                return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,i)


        def EQUAL(self):
            return self.getToken(WFLParser.EQUAL, 0)

        def reservedKeyword(self):
            return self.getTypedRuleContext(WFLParser.ReservedKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_intoClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntoClause" ):
                listener.enterIntoClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntoClause" ):
                listener.exitIntoClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntoClause" ):
                return visitor.visitIntoClause(self)
            else:
                return visitor.visitChildren(self)




    def intoClause(self):

        localctx = WFLParser.IntoClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 638, self.RULE_intoClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4076
            self.match(WFLParser.INTO)
            self.state = 4079
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [446]:
                self.state = 4077
                self.storageUnit()
                pass
            elif token in [18]:
                self.state = 4078
                self.fileReferencedVariable()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4095
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 4081
                self.match(WFLParser.LP)
                self.state = 4084
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [446]:
                    self.state = 4082
                    self.match(WFLParser.Identifier)
                    pass
                elif token in [46, 47, 52, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 65, 66, 69, 70, 72, 75, 76, 77, 79, 80, 81, 83, 86, 87, 89, 91, 92, 93, 94, 95, 96, 101, 102, 103, 105, 113, 114, 115, 116, 117, 119, 124, 130, 131, 156, 177, 182, 189, 195, 200, 202, 205, 209, 217, 226, 228, 233, 234, 236, 240, 244, 249, 250, 254, 255, 256, 258, 260, 262, 263, 264, 265, 266, 267, 268, 275, 278, 283, 284, 287, 288, 289, 290, 293, 295, 305, 312, 339, 343, 344, 345, 350, 360, 391, 394, 398, 418, 444]:
                    self.state = 4083
                    self.charDataKeyword()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 4092
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 4086
                    self.match(WFLParser.EQUAL)
                    self.state = 4090
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,479,self._ctx)
                    if la_ == 1:
                        self.state = 4087
                        self.match(WFLParser.Identifier)
                        pass

                    elif la_ == 2:
                        self.state = 4088
                        self.charDataKeyword()
                        pass

                    elif la_ == 3:
                        self.state = 4089
                        self.reservedKeyword()
                        pass




                self.state = 4094
                self.match(WFLParser.RP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpenStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN(self):
            return self.getToken(WFLParser.OPEN, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_openStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpenStatement" ):
                listener.enterOpenStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpenStatement" ):
                listener.exitOpenStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpenStatement" ):
                return visitor.visitOpenStatement(self)
            else:
                return visitor.visitChildren(self)




    def openStatement(self):

        localctx = WFLParser.OpenStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 640, self.RULE_openStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4097
            self.match(WFLParser.OPEN)
            self.state = 4098
            self.match(WFLParser.LP)
            self.state = 4099
            self.fileIdentifier()
            self.state = 4100
            self.match(WFLParser.RP)
            self.state = 4101
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LockStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCK(self):
            return self.getToken(WFLParser.LOCK, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_lockStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLockStatement" ):
                listener.enterLockStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLockStatement" ):
                listener.exitLockStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLockStatement" ):
                return visitor.visitLockStatement(self)
            else:
                return visitor.visitChildren(self)




    def lockStatement(self):

        localctx = WFLParser.LockStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 642, self.RULE_lockStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4103
            self.match(WFLParser.LOCK)
            self.state = 4104
            self.match(WFLParser.LP)
            self.state = 4105
            self.fileIdentifier()
            self.state = 4106
            self.match(WFLParser.RP)
            self.state = 4107
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReleaseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RELEASE(self):
            return self.getToken(WFLParser.RELEASE, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_releaseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReleaseStatement" ):
                listener.enterReleaseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReleaseStatement" ):
                listener.exitReleaseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReleaseStatement" ):
                return visitor.visitReleaseStatement(self)
            else:
                return visitor.visitChildren(self)




    def releaseStatement(self):

        localctx = WFLParser.ReleaseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 644, self.RULE_releaseStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4109
            self.match(WFLParser.RELEASE)
            self.state = 4110
            self.match(WFLParser.LP)
            self.state = 4111
            self.fileIdentifier()
            self.state = 4112
            self.match(WFLParser.RP)
            self.state = 4113
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplaceStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLACE(self):
            return self.getToken(WFLParser.REPLACE, 0)

        def copyRequest(self):
            return self.getTypedRuleContext(WFLParser.CopyRequestContext,0)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.SEMICOLON)
            else:
                return self.getToken(WFLParser.SEMICOLON, i)

        def replaceOptions(self):
            return self.getTypedRuleContext(WFLParser.ReplaceOptionsContext,0)


        def LS(self):
            return self.getToken(WFLParser.LS, 0)

        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def RS(self):
            return self.getToken(WFLParser.RS, 0)

        def taskAttributeAssignment(self):
            return self.getTypedRuleContext(WFLParser.TaskAttributeAssignmentContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_replaceStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceStatement" ):
                listener.enterReplaceStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceStatement" ):
                listener.exitReplaceStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceStatement" ):
                return visitor.visitReplaceStatement(self)
            else:
                return visitor.visitChildren(self)




    def replaceStatement(self):

        localctx = WFLParser.ReplaceStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 646, self.RULE_replaceStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4115
            self.match(WFLParser.REPLACE)
            self.state = 4117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,482,self._ctx)
            if la_ == 1:
                self.state = 4116
                self.replaceOptions()


            self.state = 4119
            self.copyRequest()
            self.state = 4124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 4120
                self.match(WFLParser.LS)
                self.state = 4121
                self.taskIdentifier()
                self.state = 4122
                self.match(WFLParser.RS)


            self.state = 4128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,484,self._ctx)
            if la_ == 1:
                self.state = 4126
                self.match(WFLParser.SEMICOLON)
                self.state = 4127
                self.taskAttributeAssignment()


            self.state = 4130
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplaceOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPARE(self):
            return self.getToken(WFLParser.COMPARE, 0)

        def VERIFY(self):
            return self.getToken(WFLParser.VERIFY, 0)

        def CATALOG(self):
            return self.getToken(WFLParser.CATALOG, 0)

        def BACKUP(self):
            return self.getToken(WFLParser.BACKUP, 0)

        def REPORT(self):
            return self.getToken(WFLParser.REPORT, 0)

        def SELECT(self):
            return self.getToken(WFLParser.SELECT, 0)

        def DSONERROR(self):
            return self.getToken(WFLParser.DSONERROR, 0)

        def WAITONERROR(self):
            return self.getToken(WFLParser.WAITONERROR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def replaceOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ReplaceOptionsContext)
            else:
                return self.getTypedRuleContext(WFLParser.ReplaceOptionsContext,i)


        def AMPERSAND(self):
            return self.getToken(WFLParser.AMPERSAND, 0)

        def AND(self):
            return self.getToken(WFLParser.AND, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_replaceOptions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceOptions" ):
                listener.enterReplaceOptions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceOptions" ):
                listener.exitReplaceOptions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceOptions" ):
                return visitor.visitReplaceOptions(self)
            else:
                return visitor.visitChildren(self)




    def replaceOptions(self):

        localctx = WFLParser.ReplaceOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 648, self.RULE_replaceOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==163:
                self.state = 4132
                _la = self._input.LA(1)
                if not(_la==1 or _la==163):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 4135
            _la = self._input.LA(1)
            if not(_la==46 or ((((_la - 153)) & ~0x3f) == 0 and ((1 << (_la - 153)) & 407) != 0) or _la==282):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 4140
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,486,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 4136
                    self.match(WFLParser.COMMA)
                    self.state = 4137
                    self.replaceOptions() 
                self.state = 4142
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,486,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineInvocationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subroutineIdentifier(self):
            return self.getTypedRuleContext(WFLParser.SubroutineIdentifierContext,0)


        def SEMICOLON(self):
            return self.getToken(WFLParser.SEMICOLON, 0)

        def LP(self):
            return self.getToken(WFLParser.LP, 0)

        def RP(self):
            return self.getToken(WFLParser.RP, 0)

        def argumentList(self):
            return self.getTypedRuleContext(WFLParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subroutineInvocationStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineInvocationStatement" ):
                listener.enterSubroutineInvocationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineInvocationStatement" ):
                listener.exitSubroutineInvocationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineInvocationStatement" ):
                return visitor.visitSubroutineInvocationStatement(self)
            else:
                return visitor.visitChildren(self)




    def subroutineInvocationStatement(self):

        localctx = WFLParser.SubroutineInvocationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 650, self.RULE_subroutineInvocationStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4143
            self.subroutineIdentifier()
            self.state = 4149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 4144
                self.match(WFLParser.LP)
                self.state = 4146
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -1193242795020648444) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1206404919780424039) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & 1162210178972516359) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & -5132357814873733983) != 0) or ((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & 4538828987859453) != 0) or ((((_la - 339)) & ~0x3f) == 0 and ((1 << (_la - 339)) & 833165931065641073) != 0) or ((((_la - 418)) & ~0x3f) == 0 and ((1 << (_la - 418)) & 3026190337) != 0):
                    self.state = 4145
                    self.argumentList()


                self.state = 4148
                self.match(WFLParser.RP)


            self.state = 4151
            self.match(WFLParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(WFLParser.Identifier, 0)

        def compilerName(self):
            return self.getTypedRuleContext(WFLParser.CompilerNameContext,0)


        def charDataKeyword(self):
            return self.getTypedRuleContext(WFLParser.CharDataKeywordContext,0)


        def getRuleIndex(self):
            return WFLParser.RULE_subroutineIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubroutineIdentifier" ):
                listener.enterSubroutineIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubroutineIdentifier" ):
                listener.exitSubroutineIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineIdentifier" ):
                return visitor.visitSubroutineIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def subroutineIdentifier(self):

        localctx = WFLParser.SubroutineIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 652, self.RULE_subroutineIdentifier)
        try:
            self.state = 4156
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,489,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4153
                self.match(WFLParser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4154
                self.compilerName()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4155
                self.charDataKeyword()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(WFLParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(WFLParser.ArgumentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(WFLParser.COMMA)
            else:
                return self.getToken(WFLParser.COMMA, i)

        def getRuleIndex(self):
            return WFLParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = WFLParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 654, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4158
            self.argument()
            self.state = 4163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==4:
                self.state = 4159
                self.match(WFLParser.COMMA)
                self.state = 4160
                self.argument()
                self.state = 4165
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def realConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.RealConstantExpressionContext,0)


        def integerConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.IntegerConstantExpressionContext,0)


        def booleanConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.BooleanConstantExpressionContext,0)


        def stringConstantExpression(self):
            return self.getTypedRuleContext(WFLParser.StringConstantExpressionContext,0)


        def taskIdentifier(self):
            return self.getTypedRuleContext(WFLParser.TaskIdentifierContext,0)


        def fileIdentifier(self):
            return self.getTypedRuleContext(WFLParser.FileIdentifierContext,0)


        def LITERAL(self):
            return self.getToken(WFLParser.LITERAL, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgument" ):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = WFLParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 656, self.RULE_argument)
        try:
            self.state = 4173
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,491,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4166
                self.realConstantExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4167
                self.integerConstantExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4168
                self.booleanConstantExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4169
                self.stringConstantExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4170
                self.taskIdentifier()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4171
                self.fileIdentifier()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 4172
                self.match(WFLParser.LITERAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharDataKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JOB(self):
            return self.getToken(WFLParser.JOB, 0)

        def COMPILE(self):
            return self.getToken(WFLParser.COMPILE, 0)

        def GO(self):
            return self.getToken(WFLParser.GO, 0)

        def ADD(self):
            return self.getToken(WFLParser.ADD, 0)

        def DIV(self):
            return self.getToken(WFLParser.DIV, 0)

        def AFTER(self):
            return self.getToken(WFLParser.AFTER, 0)

        def GROUP(self):
            return self.getToken(WFLParser.GROUP, 0)

        def KIND(self):
            return self.getToken(WFLParser.KIND, 0)

        def SELECT(self):
            return self.getToken(WFLParser.SELECT, 0)

        def REMOVE(self):
            return self.getToken(WFLParser.REMOVE, 0)

        def DISPLAY(self):
            return self.getToken(WFLParser.DISPLAY, 0)

        def PRINT(self):
            return self.getToken(WFLParser.PRINT, 0)

        def LOG(self):
            return self.getToken(WFLParser.LOG, 0)

        def OPEN(self):
            return self.getToken(WFLParser.OPEN, 0)

        def LABEL(self):
            return self.getToken(WFLParser.LABEL, 0)

        def COPY(self):
            return self.getToken(WFLParser.COPY, 0)

        def OK(self):
            return self.getToken(WFLParser.OK, 0)

        def ACCEPT(self):
            return self.getToken(WFLParser.ACCEPT, 0)

        def SECURITY(self):
            return self.getToken(WFLParser.SECURITY, 0)

        def USERDATA(self):
            return self.getToken(WFLParser.USERDATA, 0)

        def INITIALIZE(self):
            return self.getToken(WFLParser.INITIALIZE, 0)

        def DO(self):
            return self.getToken(WFLParser.DO, 0)

        def WHILE(self):
            return self.getToken(WFLParser.WHILE, 0)

        def MODIFY(self):
            return self.getToken(WFLParser.MODIFY, 0)

        def RELEASE(self):
            return self.getToken(WFLParser.RELEASE, 0)

        def AS(self):
            return self.getToken(WFLParser.AS, 0)

        def SERIALNO(self):
            return self.getToken(WFLParser.SERIALNO, 0)

        def APRIL(self):
            return self.getToken(WFLParser.APRIL, 0)

        def TAKE(self):
            return self.getToken(WFLParser.TAKE, 0)

        def DROP(self):
            return self.getToken(WFLParser.DROP, 0)

        def USERCODE(self):
            return self.getToken(WFLParser.USERCODE, 0)

        def SUNDAY(self):
            return self.getToken(WFLParser.SUNDAY, 0)

        def NDLII(self):
            return self.getToken(WFLParser.NDLII, 0)

        def PRINTPARTIAL(self):
            return self.getToken(WFLParser.PRINTPARTIAL, 0)

        def INTO(self):
            return self.getToken(WFLParser.INTO, 0)

        def COMPRESS(self):
            return self.getToken(WFLParser.COMPRESS, 0)

        def TYPE(self):
            return self.getToken(WFLParser.TYPE, 0)

        def CHANGE(self):
            return self.getToken(WFLParser.CHANGE, 0)

        def DATA(self):
            return self.getToken(WFLParser.DATA, 0)

        def DB(self):
            return self.getToken(WFLParser.DB, 0)

        def OFFLINE(self):
            return self.getToken(WFLParser.OFFLINE, 0)

        def OPTIONS(self):
            return self.getToken(WFLParser.OPTIONS, 0)

        def DUMP(self):
            return self.getToken(WFLParser.DUMP, 0)

        def ALL(self):
            return self.getToken(WFLParser.ALL, 0)

        def CARD(self):
            return self.getToken(WFLParser.CARD, 0)

        def DENSITY(self):
            return self.getToken(WFLParser.DENSITY, 0)

        def JOBSYMBOL(self):
            return self.getToken(WFLParser.JOBSYMBOL, 0)

        def ACCESSED(self):
            return self.getToken(WFLParser.ACCESSED, 0)

        def BEFORE(self):
            return self.getToken(WFLParser.BEFORE, 0)

        def NOZ(self):
            return self.getToken(WFLParser.NOZ, 0)

        def ONLINE(self):
            return self.getToken(WFLParser.ONLINE, 0)

        def STOP(self):
            return self.getToken(WFLParser.STOP, 0)

        def TODAY(self):
            return self.getToken(WFLParser.TODAY, 0)

        def GENERATE(self):
            return self.getToken(WFLParser.GENERATE, 0)

        def ORDER(self):
            return self.getToken(WFLParser.ORDER, 0)

        def BY(self):
            return self.getToken(WFLParser.BY, 0)

        def SET(self):
            return self.getToken(WFLParser.SET, 0)

        def GLOBAL(self):
            return self.getToken(WFLParser.GLOBAL, 0)

        def INTERNAL(self):
            return self.getToken(WFLParser.INTERNAL, 0)

        def ALLOWEDCORE(self):
            return self.getToken(WFLParser.ALLOWEDCORE, 0)

        def ONLY(self):
            return self.getToken(WFLParser.ONLY, 0)

        def EXCLUDE(self):
            return self.getToken(WFLParser.EXCLUDE, 0)

        def DECIMAL(self):
            return self.getToken(WFLParser.DECIMAL, 0)

        def CC(self):
            return self.getToken(WFLParser.CC, 0)

        def AX(self):
            return self.getToken(WFLParser.AX, 0)

        def UPDATE(self):
            return self.getToken(WFLParser.UPDATE, 0)

        def RESET(self):
            return self.getToken(WFLParser.RESET, 0)

        def NOPOSTDUMP(self):
            return self.getToken(WFLParser.NOPOSTDUMP, 0)

        def LOCK(self):
            return self.getToken(WFLParser.LOCK, 0)

        def TO(self):
            return self.getToken(WFLParser.TO, 0)

        def MOD(self):
            return self.getToken(WFLParser.MOD, 0)

        def DAYNUMBER(self):
            return self.getToken(WFLParser.DAYNUMBER, 0)

        def FILES(self):
            return self.getToken(WFLParser.FILES, 0)

        def WRAP(self):
            return self.getToken(WFLParser.WRAP, 0)

        def RECORD(self):
            return self.getToken(WFLParser.RECORD, 0)

        def SOURCE(self):
            return self.getToken(WFLParser.SOURCE, 0)

        def LOAD(self):
            return self.getToken(WFLParser.LOAD, 0)

        def YYYYMMDD(self):
            return self.getToken(WFLParser.YYYYMMDD, 0)

        def USE(self):
            return self.getToken(WFLParser.USE, 0)

        def BREAK(self):
            return self.getToken(WFLParser.BREAK, 0)

        def BLOCKSTRUCTURE(self):
            return self.getToken(WFLParser.BLOCKSTRUCTURE, 0)

        def SYNTAX(self):
            return self.getToken(WFLParser.SYNTAX, 0)

        def BDNAME(self):
            return self.getToken(WFLParser.BDNAME, 0)

        def OUTPUT(self):
            return self.getToken(WFLParser.OUTPUT, 0)

        def ITEMS(self):
            return self.getToken(WFLParser.ITEMS, 0)

        def ARE(self):
            return self.getToken(WFLParser.ARE, 0)

        def REPORTS(self):
            return self.getToken(WFLParser.REPORTS, 0)

        def HEADING(self):
            return self.getToken(WFLParser.HEADING, 0)

        def PAGE(self):
            return self.getToken(WFLParser.PAGE, 0)

        def SPEC(self):
            return self.getToken(WFLParser.SPEC, 0)

        def ENTRY(self):
            return self.getToken(WFLParser.ENTRY, 0)

        def DISABLE(self):
            return self.getToken(WFLParser.DISABLE, 0)

        def ENABLE(self):
            return self.getToken(WFLParser.ENABLE, 0)

        def PROGRAM(self):
            return self.getToken(WFLParser.PROGRAM, 0)

        def ASCENDING(self):
            return self.getToken(WFLParser.ASCENDING, 0)

        def DESCENDING(self):
            return self.getToken(WFLParser.DESCENDING, 0)

        def QUIT(self):
            return self.getToken(WFLParser.QUIT, 0)

        def STOPPED(self):
            return self.getToken(WFLParser.STOPPED, 0)

        def START(self):
            return self.getToken(WFLParser.START, 0)

        def OWNER(self):
            return self.getToken(WFLParser.OWNER, 0)

        def ERRORFILE(self):
            return self.getToken(WFLParser.ERRORFILE, 0)

        def getRuleIndex(self):
            return WFLParser.RULE_charDataKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharDataKeyword" ):
                listener.enterCharDataKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharDataKeyword" ):
                listener.exitCharDataKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharDataKeyword" ):
                return visitor.visitCharDataKeyword(self)
            else:
                return visitor.visitChildren(self)




    def charDataKeyword(self):

        localctx = WFLParser.CharDataKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 658, self.RULE_charDataKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4175
            _la = self._input.LA(1)
            if not(((((_la - 46)) & ~0x3f) == 0 and ((1 << (_la - 46)) & 830891242926620099) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 8796093417567) != 0) or ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & -8427922648553222111) != 0) or ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & 2308791369004309601) != 0) or ((((_la - 312)) & ~0x3f) == 0 and ((1 << (_la - 312)) & 281765021220865) != 0) or ((((_la - 391)) & ~0x3f) == 0 and ((1 << (_la - 391)) & 9007199388958857) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





