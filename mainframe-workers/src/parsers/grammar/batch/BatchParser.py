# Generated from ./grammar/batch/Batch.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,102,774,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,1,0,5,0,190,8,0,10,0,12,0,193,9,0,1,0,5,0,
        196,8,0,10,0,12,0,199,9,0,1,0,1,0,1,1,1,1,5,1,205,8,1,10,1,12,1,
        208,9,1,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
        1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,232,8,3,1,4,1,4,1,4,1,4,1,4,
        1,5,1,5,1,6,4,6,242,8,6,11,6,12,6,243,1,7,1,7,5,7,248,8,7,10,7,12,
        7,251,9,7,1,8,1,8,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,
        1,11,4,11,266,8,11,11,11,12,11,267,1,12,1,12,1,12,1,12,1,13,4,13,
        275,8,13,11,13,12,13,276,1,14,1,14,4,14,281,8,14,11,14,12,14,282,
        1,15,1,15,1,15,1,16,1,16,4,16,290,8,16,11,16,12,16,291,1,17,1,17,
        1,17,1,18,1,18,4,18,299,8,18,11,18,12,18,300,1,19,1,19,3,19,305,
        8,19,1,20,1,20,4,20,309,8,20,11,20,12,20,310,1,21,1,21,1,21,1,21,
        1,22,1,22,1,22,1,22,1,22,3,22,322,8,22,1,23,1,23,1,23,3,23,327,8,
        23,1,24,1,24,1,25,1,25,4,25,333,8,25,11,25,12,25,334,1,25,3,25,338,
        8,25,1,25,3,25,341,8,25,1,26,4,26,344,8,26,11,26,12,26,345,1,27,
        1,27,1,27,1,27,1,27,1,27,3,27,354,8,27,1,28,1,28,1,28,1,28,1,28,
        1,29,1,29,1,29,1,30,1,30,1,31,1,31,3,31,368,8,31,1,31,5,31,371,8,
        31,10,31,12,31,374,9,31,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,33,
        1,33,1,33,3,33,386,8,33,1,34,1,34,3,34,390,8,34,1,34,1,34,1,34,3,
        34,395,8,34,1,35,1,35,3,35,399,8,35,1,35,3,35,402,8,35,1,36,1,36,
        1,37,1,37,3,37,408,8,37,1,38,1,38,3,38,412,8,38,1,38,3,38,415,8,
        38,1,38,1,38,1,38,1,38,1,38,1,38,1,39,1,39,1,40,1,40,4,40,427,8,
        40,11,40,12,40,428,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,3,41,
        439,8,41,1,42,1,42,1,42,3,42,444,8,42,1,42,1,42,1,43,1,43,1,44,1,
        44,4,44,452,8,44,11,44,12,44,453,1,44,1,44,1,45,1,45,1,45,3,45,461,
        8,45,1,46,1,46,1,46,1,46,3,46,467,8,46,1,47,1,47,4,47,471,8,47,11,
        47,12,47,472,1,47,1,47,1,47,3,47,478,8,47,1,48,1,48,1,48,4,48,483,
        8,48,11,48,12,48,484,1,48,1,48,1,49,1,49,1,50,3,50,492,8,50,1,50,
        1,50,1,50,1,51,1,51,1,51,3,51,500,8,51,1,52,1,52,1,52,1,52,3,52,
        506,8,52,1,53,1,53,1,54,1,54,1,54,1,55,1,55,1,55,1,56,1,56,1,56,
        3,56,519,8,56,1,57,1,57,3,57,523,8,57,1,57,1,57,1,58,1,58,1,58,1,
        58,3,58,531,8,58,1,59,1,59,1,60,1,60,1,61,4,61,538,8,61,11,61,12,
        61,539,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,
        62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,
        62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,5,62,574,8,62,10,62,12,62,
        577,9,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,585,8,62,1,63,1,63,1,
        63,1,63,1,63,1,63,1,64,1,64,1,65,1,65,3,65,597,8,65,1,65,1,65,3,
        65,601,8,65,1,65,3,65,604,8,65,1,66,1,66,1,66,1,67,1,67,1,67,4,67,
        612,8,67,11,67,12,67,613,3,67,616,8,67,1,67,1,67,1,67,1,67,3,67,
        622,8,67,1,68,1,68,1,68,3,68,627,8,68,1,69,1,69,1,70,1,70,1,70,4,
        70,634,8,70,11,70,12,70,635,1,70,1,70,1,70,1,70,1,70,1,70,1,70,3,
        70,645,8,70,1,71,1,71,1,71,3,71,650,8,71,1,71,1,71,1,71,1,71,3,71,
        656,8,71,1,72,1,72,1,73,1,73,3,73,662,8,73,1,73,1,73,3,73,666,8,
        73,4,73,668,8,73,11,73,12,73,669,1,74,4,74,673,8,74,11,74,12,74,
        674,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,686,8,75,1,
        76,4,76,689,8,76,11,76,12,76,690,1,77,1,77,3,77,695,8,77,1,78,1,
        78,1,78,3,78,700,8,78,1,78,1,78,1,78,1,78,1,78,3,78,707,8,78,1,78,
        1,78,3,78,711,8,78,1,79,1,79,1,79,1,79,1,79,1,79,3,79,719,8,79,1,
        80,1,80,1,80,1,80,1,80,1,81,1,81,1,81,1,81,1,82,4,82,731,8,82,11,
        82,12,82,732,1,82,1,82,1,82,1,82,1,82,3,82,740,8,82,1,83,1,83,1,
        83,1,84,1,84,1,85,1,85,1,86,3,86,750,8,86,1,86,1,86,1,86,1,87,1,
        87,1,88,1,88,1,89,1,89,1,90,3,90,762,8,90,1,90,1,90,1,91,1,91,1,
        92,1,92,1,93,1,93,1,93,1,93,1,93,0,0,94,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
        138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
        170,172,174,176,178,180,182,184,186,0,5,2,0,25,26,32,34,3,0,8,8,
        63,63,101,101,3,0,70,71,77,77,79,79,2,0,6,7,101,101,3,0,22,22,91,
        91,97,98,846,0,191,1,0,0,0,2,202,1,0,0,0,4,209,1,0,0,0,6,231,1,0,
        0,0,8,233,1,0,0,0,10,238,1,0,0,0,12,241,1,0,0,0,14,245,1,0,0,0,16,
        252,1,0,0,0,18,254,1,0,0,0,20,256,1,0,0,0,22,263,1,0,0,0,24,269,
        1,0,0,0,26,274,1,0,0,0,28,278,1,0,0,0,30,284,1,0,0,0,32,287,1,0,
        0,0,34,293,1,0,0,0,36,296,1,0,0,0,38,302,1,0,0,0,40,306,1,0,0,0,
        42,312,1,0,0,0,44,321,1,0,0,0,46,323,1,0,0,0,48,328,1,0,0,0,50,332,
        1,0,0,0,52,343,1,0,0,0,54,353,1,0,0,0,56,355,1,0,0,0,58,360,1,0,
        0,0,60,363,1,0,0,0,62,365,1,0,0,0,64,375,1,0,0,0,66,385,1,0,0,0,
        68,389,1,0,0,0,70,396,1,0,0,0,72,403,1,0,0,0,74,407,1,0,0,0,76,409,
        1,0,0,0,78,422,1,0,0,0,80,424,1,0,0,0,82,438,1,0,0,0,84,440,1,0,
        0,0,86,447,1,0,0,0,88,449,1,0,0,0,90,457,1,0,0,0,92,462,1,0,0,0,
        94,477,1,0,0,0,96,479,1,0,0,0,98,488,1,0,0,0,100,491,1,0,0,0,102,
        499,1,0,0,0,104,505,1,0,0,0,106,507,1,0,0,0,108,509,1,0,0,0,110,
        512,1,0,0,0,112,515,1,0,0,0,114,520,1,0,0,0,116,526,1,0,0,0,118,
        532,1,0,0,0,120,534,1,0,0,0,122,537,1,0,0,0,124,584,1,0,0,0,126,
        586,1,0,0,0,128,592,1,0,0,0,130,594,1,0,0,0,132,605,1,0,0,0,134,
        621,1,0,0,0,136,623,1,0,0,0,138,628,1,0,0,0,140,644,1,0,0,0,142,
        649,1,0,0,0,144,657,1,0,0,0,146,661,1,0,0,0,148,672,1,0,0,0,150,
        685,1,0,0,0,152,688,1,0,0,0,154,694,1,0,0,0,156,710,1,0,0,0,158,
        712,1,0,0,0,160,720,1,0,0,0,162,725,1,0,0,0,164,739,1,0,0,0,166,
        741,1,0,0,0,168,744,1,0,0,0,170,746,1,0,0,0,172,749,1,0,0,0,174,
        754,1,0,0,0,176,756,1,0,0,0,178,758,1,0,0,0,180,761,1,0,0,0,182,
        765,1,0,0,0,184,767,1,0,0,0,186,769,1,0,0,0,188,190,3,6,3,0,189,
        188,1,0,0,0,190,193,1,0,0,0,191,189,1,0,0,0,191,192,1,0,0,0,192,
        197,1,0,0,0,193,191,1,0,0,0,194,196,3,2,1,0,195,194,1,0,0,0,196,
        199,1,0,0,0,197,195,1,0,0,0,197,198,1,0,0,0,198,200,1,0,0,0,199,
        197,1,0,0,0,200,201,5,0,0,1,201,1,1,0,0,0,202,206,3,4,2,0,203,205,
        3,6,3,0,204,203,1,0,0,0,205,208,1,0,0,0,206,204,1,0,0,0,206,207,
        1,0,0,0,207,3,1,0,0,0,208,206,1,0,0,0,209,210,5,18,0,0,210,211,5,
        101,0,0,211,5,1,0,0,0,212,232,3,130,65,0,213,232,3,110,55,0,214,
        232,3,58,29,0,215,232,3,136,68,0,216,232,3,108,54,0,217,232,3,116,
        58,0,218,232,3,46,23,0,219,232,3,92,46,0,220,232,3,90,45,0,221,232,
        3,16,8,0,222,232,3,18,9,0,223,232,3,60,30,0,224,232,3,70,35,0,225,
        232,3,62,31,0,226,232,3,114,57,0,227,232,3,76,38,0,228,232,3,112,
        56,0,229,232,3,8,4,0,230,232,3,20,10,0,231,212,1,0,0,0,231,213,1,
        0,0,0,231,214,1,0,0,0,231,215,1,0,0,0,231,216,1,0,0,0,231,217,1,
        0,0,0,231,218,1,0,0,0,231,219,1,0,0,0,231,220,1,0,0,0,231,221,1,
        0,0,0,231,222,1,0,0,0,231,223,1,0,0,0,231,224,1,0,0,0,231,225,1,
        0,0,0,231,226,1,0,0,0,231,227,1,0,0,0,231,228,1,0,0,0,231,229,1,
        0,0,0,231,230,1,0,0,0,232,7,1,0,0,0,233,234,3,146,73,0,234,235,5,
        90,0,0,235,236,3,10,5,0,236,237,3,12,6,0,237,9,1,0,0,0,238,239,5,
        101,0,0,239,11,1,0,0,0,240,242,3,14,7,0,241,240,1,0,0,0,242,243,
        1,0,0,0,243,241,1,0,0,0,243,244,1,0,0,0,244,13,1,0,0,0,245,249,7,
        0,0,0,246,248,3,156,78,0,247,246,1,0,0,0,248,251,1,0,0,0,249,247,
        1,0,0,0,249,250,1,0,0,0,250,15,1,0,0,0,251,249,1,0,0,0,252,253,5,
        3,0,0,253,17,1,0,0,0,254,255,5,4,0,0,255,19,1,0,0,0,256,257,5,66,
        0,0,257,258,3,22,11,0,258,259,3,28,14,0,259,260,3,32,16,0,260,261,
        3,36,18,0,261,262,3,40,20,0,262,21,1,0,0,0,263,265,5,27,0,0,264,
        266,3,24,12,0,265,264,1,0,0,0,266,267,1,0,0,0,267,265,1,0,0,0,267,
        268,1,0,0,0,268,23,1,0,0,0,269,270,3,138,69,0,270,271,5,19,0,0,271,
        272,3,26,13,0,272,25,1,0,0,0,273,275,7,1,0,0,274,273,1,0,0,0,275,
        276,1,0,0,0,276,274,1,0,0,0,276,277,1,0,0,0,277,27,1,0,0,0,278,280,
        5,28,0,0,279,281,3,30,15,0,280,279,1,0,0,0,281,282,1,0,0,0,282,280,
        1,0,0,0,282,283,1,0,0,0,283,29,1,0,0,0,284,285,3,138,69,0,285,286,
        3,134,67,0,286,31,1,0,0,0,287,289,5,31,0,0,288,290,3,34,17,0,289,
        288,1,0,0,0,290,291,1,0,0,0,291,289,1,0,0,0,291,292,1,0,0,0,292,
        33,1,0,0,0,293,294,3,138,69,0,294,295,3,134,67,0,295,35,1,0,0,0,
        296,298,5,30,0,0,297,299,3,38,19,0,298,297,1,0,0,0,299,300,1,0,0,
        0,300,298,1,0,0,0,300,301,1,0,0,0,301,37,1,0,0,0,302,304,3,138,69,
        0,303,305,3,134,67,0,304,303,1,0,0,0,304,305,1,0,0,0,305,39,1,0,
        0,0,306,308,5,29,0,0,307,309,3,42,21,0,308,307,1,0,0,0,309,310,1,
        0,0,0,310,308,1,0,0,0,310,311,1,0,0,0,311,41,1,0,0,0,312,313,3,138,
        69,0,313,314,5,19,0,0,314,315,3,44,22,0,315,43,1,0,0,0,316,322,3,
        140,70,0,317,322,3,156,78,0,318,319,5,12,0,0,319,320,5,2,0,0,320,
        322,5,13,0,0,321,316,1,0,0,0,321,317,1,0,0,0,321,318,1,0,0,0,322,
        45,1,0,0,0,323,326,5,67,0,0,324,327,3,48,24,0,325,327,3,50,25,0,
        326,324,1,0,0,0,326,325,1,0,0,0,327,47,1,0,0,0,328,329,3,4,2,0,329,
        49,1,0,0,0,330,333,3,146,73,0,331,333,3,148,74,0,332,330,1,0,0,0,
        332,331,1,0,0,0,333,334,1,0,0,0,334,332,1,0,0,0,334,335,1,0,0,0,
        335,337,1,0,0,0,336,338,3,56,28,0,337,336,1,0,0,0,337,338,1,0,0,
        0,338,340,1,0,0,0,339,341,3,52,26,0,340,339,1,0,0,0,340,341,1,0,
        0,0,341,51,1,0,0,0,342,344,3,54,27,0,343,342,1,0,0,0,344,345,1,0,
        0,0,345,343,1,0,0,0,345,346,1,0,0,0,346,53,1,0,0,0,347,354,5,101,
        0,0,348,354,5,2,0,0,349,350,5,85,0,0,350,354,5,8,0,0,351,354,3,156,
        78,0,352,354,3,84,42,0,353,347,1,0,0,0,353,348,1,0,0,0,353,349,1,
        0,0,0,353,351,1,0,0,0,353,352,1,0,0,0,354,55,1,0,0,0,355,356,5,1,
        0,0,356,357,5,8,0,0,357,358,5,22,0,0,358,359,5,8,0,0,359,57,1,0,
        0,0,360,361,5,68,0,0,361,362,3,146,73,0,362,59,1,0,0,0,363,364,5,
        73,0,0,364,61,1,0,0,0,365,367,3,64,32,0,366,368,3,122,61,0,367,366,
        1,0,0,0,367,368,1,0,0,0,368,372,1,0,0,0,369,371,3,66,33,0,370,369,
        1,0,0,0,371,374,1,0,0,0,372,370,1,0,0,0,372,373,1,0,0,0,373,63,1,
        0,0,0,374,372,1,0,0,0,375,376,5,5,0,0,376,65,1,0,0,0,377,386,5,8,
        0,0,378,386,3,156,78,0,379,386,5,101,0,0,380,386,3,146,73,0,381,
        386,5,2,0,0,382,386,3,186,93,0,383,386,3,68,34,0,384,386,3,84,42,
        0,385,377,1,0,0,0,385,378,1,0,0,0,385,379,1,0,0,0,385,380,1,0,0,
        0,385,381,1,0,0,0,385,382,1,0,0,0,385,383,1,0,0,0,385,384,1,0,0,
        0,386,67,1,0,0,0,387,390,3,146,73,0,388,390,3,156,78,0,389,387,1,
        0,0,0,389,388,1,0,0,0,390,391,1,0,0,0,391,394,5,97,0,0,392,395,3,
        146,73,0,393,395,3,156,78,0,394,392,1,0,0,0,394,393,1,0,0,0,395,
        69,1,0,0,0,396,398,5,74,0,0,397,399,3,72,36,0,398,397,1,0,0,0,398,
        399,1,0,0,0,399,401,1,0,0,0,400,402,3,74,37,0,401,400,1,0,0,0,401,
        402,1,0,0,0,402,71,1,0,0,0,403,404,5,59,0,0,404,73,1,0,0,0,405,408,
        5,8,0,0,406,408,3,156,78,0,407,405,1,0,0,0,407,406,1,0,0,0,408,75,
        1,0,0,0,409,411,5,82,0,0,410,412,3,122,61,0,411,410,1,0,0,0,411,
        412,1,0,0,0,412,414,1,0,0,0,413,415,3,78,39,0,414,413,1,0,0,0,414,
        415,1,0,0,0,415,416,1,0,0,0,416,417,3,84,42,0,417,418,5,83,0,0,418,
        419,3,80,40,0,419,420,5,84,0,0,420,421,3,88,44,0,421,77,1,0,0,0,
        422,423,5,2,0,0,423,79,1,0,0,0,424,426,5,12,0,0,425,427,3,82,41,
        0,426,425,1,0,0,0,427,428,1,0,0,0,428,426,1,0,0,0,428,429,1,0,0,
        0,429,430,1,0,0,0,430,431,5,13,0,0,431,81,1,0,0,0,432,439,5,8,0,
        0,433,439,5,2,0,0,434,439,3,146,73,0,435,439,3,148,74,0,436,439,
        3,156,78,0,437,439,3,84,42,0,438,432,1,0,0,0,438,433,1,0,0,0,438,
        434,1,0,0,0,438,435,1,0,0,0,438,436,1,0,0,0,438,437,1,0,0,0,439,
        83,1,0,0,0,440,441,5,85,0,0,441,443,5,85,0,0,442,444,3,86,43,0,443,
        442,1,0,0,0,443,444,1,0,0,0,444,445,1,0,0,0,445,446,5,101,0,0,446,
        85,1,0,0,0,447,448,5,95,0,0,448,87,1,0,0,0,449,451,5,12,0,0,450,
        452,3,6,3,0,451,450,1,0,0,0,452,453,1,0,0,0,453,451,1,0,0,0,453,
        454,1,0,0,0,454,455,1,0,0,0,455,456,5,13,0,0,456,89,1,0,0,0,457,
        460,5,76,0,0,458,461,3,4,2,0,459,461,5,101,0,0,460,458,1,0,0,0,460,
        459,1,0,0,0,460,461,1,0,0,0,461,91,1,0,0,0,462,463,5,75,0,0,463,
        464,3,100,50,0,464,466,3,94,47,0,465,467,3,96,48,0,466,465,1,0,0,
        0,466,467,1,0,0,0,467,93,1,0,0,0,468,470,5,12,0,0,469,471,3,6,3,
        0,470,469,1,0,0,0,471,472,1,0,0,0,472,470,1,0,0,0,472,473,1,0,0,
        0,473,474,1,0,0,0,474,475,5,13,0,0,475,478,1,0,0,0,476,478,3,6,3,
        0,477,468,1,0,0,0,477,476,1,0,0,0,478,95,1,0,0,0,479,480,5,69,0,
        0,480,482,5,12,0,0,481,483,3,6,3,0,482,481,1,0,0,0,483,484,1,0,0,
        0,484,482,1,0,0,0,484,485,1,0,0,0,485,486,1,0,0,0,486,487,5,13,0,
        0,487,97,1,0,0,0,488,489,3,6,3,0,489,99,1,0,0,0,490,492,3,102,51,
        0,491,490,1,0,0,0,491,492,1,0,0,0,492,493,1,0,0,0,493,494,3,106,
        53,0,494,495,3,104,52,0,495,101,1,0,0,0,496,500,5,2,0,0,497,500,
        3,156,78,0,498,500,5,101,0,0,499,496,1,0,0,0,499,497,1,0,0,0,499,
        498,1,0,0,0,500,103,1,0,0,0,501,506,5,2,0,0,502,506,5,8,0,0,503,
        506,5,101,0,0,504,506,3,156,78,0,505,501,1,0,0,0,505,502,1,0,0,0,
        505,503,1,0,0,0,505,504,1,0,0,0,506,105,1,0,0,0,507,508,7,2,0,0,
        508,107,1,0,0,0,509,510,5,87,0,0,510,511,3,140,70,0,511,109,1,0,
        0,0,512,513,5,16,0,0,513,514,3,128,64,0,514,111,1,0,0,0,515,518,
        5,89,0,0,516,519,3,146,73,0,517,519,3,148,74,0,518,516,1,0,0,0,518,
        517,1,0,0,0,519,113,1,0,0,0,520,522,5,81,0,0,521,523,3,122,61,0,
        522,521,1,0,0,0,522,523,1,0,0,0,523,524,1,0,0,0,524,525,3,140,70,
        0,525,115,1,0,0,0,526,527,5,88,0,0,527,528,3,118,59,0,528,530,3,
        120,60,0,529,531,3,122,61,0,530,529,1,0,0,0,530,531,1,0,0,0,531,
        117,1,0,0,0,532,533,3,140,70,0,533,119,1,0,0,0,534,535,3,140,70,
        0,535,121,1,0,0,0,536,538,3,124,62,0,537,536,1,0,0,0,538,539,1,0,
        0,0,539,537,1,0,0,0,539,540,1,0,0,0,540,123,1,0,0,0,541,585,5,35,
        0,0,542,585,5,37,0,0,543,585,5,38,0,0,544,585,5,36,0,0,545,585,5,
        40,0,0,546,585,5,41,0,0,547,585,5,42,0,0,548,549,5,43,0,0,549,550,
        5,18,0,0,550,585,3,126,63,0,551,585,5,44,0,0,552,585,5,45,0,0,553,
        585,5,46,0,0,554,585,5,47,0,0,555,585,5,48,0,0,556,585,5,49,0,0,
        557,585,5,50,0,0,558,585,5,51,0,0,559,585,5,52,0,0,560,585,5,53,
        0,0,561,585,5,54,0,0,562,585,5,55,0,0,563,585,5,56,0,0,564,585,5,
        57,0,0,565,585,5,58,0,0,566,585,5,59,0,0,567,585,5,60,0,0,568,585,
        5,61,0,0,569,570,5,62,0,0,570,575,3,148,74,0,571,572,5,97,0,0,572,
        574,3,148,74,0,573,571,1,0,0,0,574,577,1,0,0,0,575,573,1,0,0,0,575,
        576,1,0,0,0,576,585,1,0,0,0,577,575,1,0,0,0,578,585,5,57,0,0,579,
        585,5,58,0,0,580,585,5,59,0,0,581,585,5,60,0,0,582,585,5,39,0,0,
        583,585,5,61,0,0,584,541,1,0,0,0,584,542,1,0,0,0,584,543,1,0,0,0,
        584,544,1,0,0,0,584,545,1,0,0,0,584,546,1,0,0,0,584,547,1,0,0,0,
        584,548,1,0,0,0,584,551,1,0,0,0,584,552,1,0,0,0,584,553,1,0,0,0,
        584,554,1,0,0,0,584,555,1,0,0,0,584,556,1,0,0,0,584,557,1,0,0,0,
        584,558,1,0,0,0,584,559,1,0,0,0,584,560,1,0,0,0,584,561,1,0,0,0,
        584,562,1,0,0,0,584,563,1,0,0,0,584,564,1,0,0,0,584,565,1,0,0,0,
        584,566,1,0,0,0,584,567,1,0,0,0,584,568,1,0,0,0,584,569,1,0,0,0,
        584,578,1,0,0,0,584,579,1,0,0,0,584,580,1,0,0,0,584,581,1,0,0,0,
        584,582,1,0,0,0,584,583,1,0,0,0,585,125,1,0,0,0,586,587,5,8,0,0,
        587,588,5,91,0,0,588,589,5,8,0,0,589,590,5,91,0,0,590,591,5,8,0,
        0,591,127,1,0,0,0,592,593,7,3,0,0,593,129,1,0,0,0,594,596,5,15,0,
        0,595,597,3,122,61,0,596,595,1,0,0,0,596,597,1,0,0,0,597,598,1,0,
        0,0,598,600,3,138,69,0,599,601,3,134,67,0,600,599,1,0,0,0,600,601,
        1,0,0,0,601,603,1,0,0,0,602,604,3,132,66,0,603,602,1,0,0,0,603,604,
        1,0,0,0,604,131,1,0,0,0,605,606,5,20,0,0,606,607,3,140,70,0,607,
        133,1,0,0,0,608,615,5,19,0,0,609,616,3,140,70,0,610,612,5,102,0,
        0,611,610,1,0,0,0,612,613,1,0,0,0,613,611,1,0,0,0,613,614,1,0,0,
        0,614,616,1,0,0,0,615,609,1,0,0,0,615,611,1,0,0,0,615,616,1,0,0,
        0,616,622,1,0,0,0,617,618,3,144,72,0,618,619,5,19,0,0,619,620,5,
        8,0,0,620,622,1,0,0,0,621,608,1,0,0,0,621,617,1,0,0,0,622,135,1,
        0,0,0,623,626,5,80,0,0,624,625,5,93,0,0,625,627,5,78,0,0,626,624,
        1,0,0,0,626,627,1,0,0,0,627,137,1,0,0,0,628,629,5,101,0,0,629,139,
        1,0,0,0,630,645,5,2,0,0,631,645,5,101,0,0,632,634,3,156,78,0,633,
        632,1,0,0,0,634,635,1,0,0,0,635,633,1,0,0,0,635,636,1,0,0,0,636,
        645,1,0,0,0,637,645,3,152,76,0,638,645,3,146,73,0,639,645,3,148,
        74,0,640,645,5,99,0,0,641,645,3,142,71,0,642,645,5,8,0,0,643,645,
        3,84,42,0,644,630,1,0,0,0,644,631,1,0,0,0,644,633,1,0,0,0,644,637,
        1,0,0,0,644,638,1,0,0,0,644,639,1,0,0,0,644,640,1,0,0,0,644,641,
        1,0,0,0,644,642,1,0,0,0,644,643,1,0,0,0,645,141,1,0,0,0,646,650,
        5,8,0,0,647,650,3,156,78,0,648,650,5,2,0,0,649,646,1,0,0,0,649,647,
        1,0,0,0,649,648,1,0,0,0,650,651,1,0,0,0,651,655,3,144,72,0,652,656,
        5,8,0,0,653,656,3,156,78,0,654,656,5,2,0,0,655,652,1,0,0,0,655,653,
        1,0,0,0,655,654,1,0,0,0,656,143,1,0,0,0,657,658,7,4,0,0,658,145,
        1,0,0,0,659,662,3,148,74,0,660,662,5,65,0,0,661,659,1,0,0,0,661,
        660,1,0,0,0,661,662,1,0,0,0,662,667,1,0,0,0,663,665,5,24,0,0,664,
        666,3,148,74,0,665,664,1,0,0,0,665,666,1,0,0,0,666,668,1,0,0,0,667,
        663,1,0,0,0,668,669,1,0,0,0,669,667,1,0,0,0,669,670,1,0,0,0,670,
        147,1,0,0,0,671,673,3,150,75,0,672,671,1,0,0,0,673,674,1,0,0,0,674,
        672,1,0,0,0,674,675,1,0,0,0,675,149,1,0,0,0,676,686,5,101,0,0,677,
        686,5,92,0,0,678,686,5,63,0,0,679,686,5,99,0,0,680,686,3,156,78,
        0,681,686,5,98,0,0,682,686,5,96,0,0,683,686,5,23,0,0,684,686,5,72,
        0,0,685,676,1,0,0,0,685,677,1,0,0,0,685,678,1,0,0,0,685,679,1,0,
        0,0,685,680,1,0,0,0,685,681,1,0,0,0,685,682,1,0,0,0,685,683,1,0,
        0,0,685,684,1,0,0,0,686,151,1,0,0,0,687,689,3,154,77,0,688,687,1,
        0,0,0,689,690,1,0,0,0,690,688,1,0,0,0,690,691,1,0,0,0,691,153,1,
        0,0,0,692,695,5,101,0,0,693,695,3,156,78,0,694,692,1,0,0,0,694,693,
        1,0,0,0,695,155,1,0,0,0,696,697,5,85,0,0,697,699,3,138,69,0,698,
        700,3,158,79,0,699,698,1,0,0,0,699,700,1,0,0,0,700,701,1,0,0,0,701,
        702,5,85,0,0,702,711,1,0,0,0,703,704,5,86,0,0,704,706,3,138,69,0,
        705,707,3,158,79,0,706,705,1,0,0,0,706,707,1,0,0,0,707,708,1,0,0,
        0,708,709,5,86,0,0,709,711,1,0,0,0,710,696,1,0,0,0,710,703,1,0,0,
        0,711,157,1,0,0,0,712,718,5,18,0,0,713,719,3,160,80,0,714,719,3,
        162,81,0,715,719,3,166,83,0,716,719,3,170,85,0,717,719,3,172,86,
        0,718,713,1,0,0,0,718,714,1,0,0,0,718,715,1,0,0,0,718,716,1,0,0,
        0,718,717,1,0,0,0,719,159,1,0,0,0,720,721,5,94,0,0,721,722,3,178,
        89,0,722,723,5,96,0,0,723,724,3,180,90,0,724,161,1,0,0,0,725,726,
        5,94,0,0,726,727,5,91,0,0,727,728,3,180,90,0,728,163,1,0,0,0,729,
        731,5,102,0,0,730,729,1,0,0,0,731,732,1,0,0,0,732,730,1,0,0,0,732,
        733,1,0,0,0,733,740,1,0,0,0,734,740,5,9,0,0,735,740,5,18,0,0,736,
        740,5,101,0,0,737,740,5,63,0,0,738,740,5,8,0,0,739,730,1,0,0,0,739,
        734,1,0,0,0,739,735,1,0,0,0,739,736,1,0,0,0,739,737,1,0,0,0,739,
        738,1,0,0,0,740,165,1,0,0,0,741,742,3,168,84,0,742,743,5,19,0,0,
        743,167,1,0,0,0,744,745,3,164,82,0,745,169,1,0,0,0,746,747,5,19,
        0,0,747,171,1,0,0,0,748,750,3,174,87,0,749,748,1,0,0,0,749,750,1,
        0,0,0,750,751,1,0,0,0,751,752,5,19,0,0,752,753,3,176,88,0,753,173,
        1,0,0,0,754,755,3,164,82,0,755,175,1,0,0,0,756,757,3,164,82,0,757,
        177,1,0,0,0,758,759,5,8,0,0,759,179,1,0,0,0,760,762,5,91,0,0,761,
        760,1,0,0,0,761,762,1,0,0,0,762,763,1,0,0,0,763,764,5,8,0,0,764,
        181,1,0,0,0,765,766,5,8,0,0,766,183,1,0,0,0,767,768,5,8,0,0,768,
        185,1,0,0,0,769,770,5,2,0,0,770,771,5,97,0,0,771,772,5,2,0,0,772,
        187,1,0,0,0,75,191,197,206,231,243,249,267,276,282,291,300,304,310,
        321,326,332,334,337,340,345,353,367,372,385,389,394,398,401,407,
        411,414,428,438,443,453,460,466,472,477,484,491,499,505,518,522,
        530,539,575,584,596,600,603,613,615,621,626,635,644,649,655,661,
        665,669,674,685,690,694,699,706,710,718,732,739,749,761
    ]

class BatchParser ( Parser ):

    grammarFileName = "Batch.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'COND:'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'EnableDelayedExpansion'", "'DisableDelayedExpansion'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'echo'", "'set'", "'setlocal'", "'rem'", 
                     "':'", "'='", "'\\uFF1D'", "'@'", "'/'", "'?'", "'\\'", 
                     "'-sfx'", "'-tzip'", "'-sort'", "'-input'", "'-output'", 
                     "'-option'", "'-record'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'/compress'", 
                     "'/exclude'", "'.'", "'COND'", "<INVALID>", "'bsortex'", 
                     "<INVALID>", "'del'", "'else'", "'equ'", "'exist'", 
                     "'exe'", "'endlocal'", "'exit'", "<INVALID>", "'goto'", 
                     "'gtr'", "'nul'", "'neq'", "'pause'", "'rmdir'", "'for'", 
                     "<INVALID>", "<INVALID>", "'%'", "'!'", "'mkdir'", 
                     "'xcopy'", "'type'", "'7z'", "'-'", "'_'", "'>'", "'~'", 
                     "'~nx'", "','", "'+'", "'*'" ]

    symbolicNames = [ "<INVALID>", "COND_COLON", "STRING", "ECHOSTATEMENT", 
                      "REMSTATEMENT", "EXE_FILE", "ENABLEDELAYEDEXPANSION", 
                      "DISABLEDELAYEDEXPANSION", "INT", "WS", "NL", "COMMENTLINE", 
                      "LPAREN", "RPAREN", "ECHO", "SET", "SETLOCAL", "REM", 
                      "COLON", "EQUAL", "JP_EQUAL", "ATSIGN", "SLASH", "QUESTION", 
                      "SSLASH", "DASH_SFX", "DASH_TZIP", "DASH_SORT", "DASH_INPUT", 
                      "DASH_OUTPUT", "DASH_OPTION", "DASH_RECORD", "DASH_P", 
                      "DASH_W", "DASH_Y", "SLASH_W", "SLASH_P", "SLASH_C", 
                      "SLASH_V", "SLASH_Q", "SLASH_F", "SLASH_L", "SLASH_G", 
                      "SLASH_D", "SLASH_U", "SLASH_I", "SLASH_S", "SLASH_E", 
                      "SLASH_T", "SLASH_K", "SLASH_R", "SLASH_H", "SLASH_A", 
                      "SLASH_M", "SLASH_N", "SLASH_O", "SLASH_X", "SLASH_Y", 
                      "SLASH_Z", "SLASH_B", "SLASH_J", "SLASH_COMPRESS", 
                      "SLASH_EXCLUDE", "DOT", "COND", "DISK_ADDRESS", "BSORTEX", 
                      "CALL", "DEL", "ELSE", "EQU", "EXIST", "EXE", "ENDLOCAL", 
                      "EXIT", "IF", "GOTO", "GTR", "NUL", "NEQ", "PAUSE", 
                      "RMDIR", "FOR", "IN", "DO", "PERCENT", "EXCLAMATION", 
                      "MKDIR", "XCOPY", "TYPE", "Z7", "DASH", "UNDERSCORE", 
                      "GREATER_CHAR", "TILDE", "TILDE_NX", "COMMA", "PLUS", 
                      "STAR", "JP_TXT", "JP_CHAR", "IDENTIFIER", "STRING_CHARACTERS" ]

    RULE_startRule = 0
    RULE_label = 1
    RULE_labelName = 2
    RULE_statement = 3
    RULE_z7Statement = 4
    RULE_z7Command = 5
    RULE_z7Switches = 6
    RULE_z7Switch = 7
    RULE_echoStatement = 8
    RULE_remStatement = 9
    RULE_bsortexStatement = 10
    RULE_sortParameters = 11
    RULE_sortParameter = 12
    RULE_sortValue = 13
    RULE_inputParameters = 14
    RULE_inputParameter = 15
    RULE_recordParameters = 16
    RULE_recordParameter = 17
    RULE_optionParameters = 18
    RULE_optionParameter = 19
    RULE_outputParameters = 20
    RULE_outputParameter = 21
    RULE_outputValue = 22
    RULE_callStatement = 23
    RULE_callWithLabel = 24
    RULE_callWithFilePath = 25
    RULE_batchParameters = 26
    RULE_batchParameter = 27
    RULE_conditionParameter = 28
    RULE_delStatement = 29
    RULE_endlocalStatement = 30
    RULE_execStatement = 31
    RULE_execFile = 32
    RULE_execParameter = 33
    RULE_concatenateFileContent = 34
    RULE_exitStatement = 35
    RULE_exitCurrentBatch = 36
    RULE_exitCode = 37
    RULE_forStatement = 38
    RULE_configurationString = 39
    RULE_forValues = 40
    RULE_forValue = 41
    RULE_forVariable = 42
    RULE_forVariableModifier = 43
    RULE_forDo = 44
    RULE_gotoStatement = 45
    RULE_ifStatement = 46
    RULE_ifThen = 47
    RULE_ifElse = 48
    RULE_simpleIf = 49
    RULE_condition = 50
    RULE_leftConditionOperator = 51
    RULE_rightConditionOperator = 52
    RULE_relationalOperator = 53
    RULE_mkdirStatement = 54
    RULE_setLocalStatement = 55
    RULE_typeStatement = 56
    RULE_rmdirStatement = 57
    RULE_xcopyStatement = 58
    RULE_xCopySource = 59
    RULE_xCopyDestination = 60
    RULE_switches = 61
    RULE_switch = 62
    RULE_dateFormat = 63
    RULE_setLocalOption = 64
    RULE_setStatement = 65
    RULE_displayFormating = 66
    RULE_assignmentPart = 67
    RULE_pauseStatement = 68
    RULE_variableName = 69
    RULE_value = 70
    RULE_calcValue = 71
    RULE_calcOperator = 72
    RULE_filePath = 73
    RULE_fileName = 74
    RULE_fileNameChar = 75
    RULE_identifierCombinedWithReferencedVariable = 76
    RULE_idetifierOrRerencedVariable = 77
    RULE_referencedVariable = 78
    RULE_variableSubstring = 79
    RULE_leftSubstring = 80
    RULE_rightSubstring = 81
    RULE_replacedOrRemovedSubstring = 82
    RULE_removeSubstring = 83
    RULE_removedSubstring = 84
    RULE_removeSpaces = 85
    RULE_replaceSubstring = 86
    RULE_subtringRemoved = 87
    RULE_subStringReplaced = 88
    RULE_startSub = 89
    RULE_lengthSub = 90
    RULE_variableStart = 91
    RULE_variableLength = 92
    RULE_concatenateString = 93

    ruleNames =  [ "startRule", "label", "labelName", "statement", "z7Statement", 
                   "z7Command", "z7Switches", "z7Switch", "echoStatement", 
                   "remStatement", "bsortexStatement", "sortParameters", 
                   "sortParameter", "sortValue", "inputParameters", "inputParameter", 
                   "recordParameters", "recordParameter", "optionParameters", 
                   "optionParameter", "outputParameters", "outputParameter", 
                   "outputValue", "callStatement", "callWithLabel", "callWithFilePath", 
                   "batchParameters", "batchParameter", "conditionParameter", 
                   "delStatement", "endlocalStatement", "execStatement", 
                   "execFile", "execParameter", "concatenateFileContent", 
                   "exitStatement", "exitCurrentBatch", "exitCode", "forStatement", 
                   "configurationString", "forValues", "forValue", "forVariable", 
                   "forVariableModifier", "forDo", "gotoStatement", "ifStatement", 
                   "ifThen", "ifElse", "simpleIf", "condition", "leftConditionOperator", 
                   "rightConditionOperator", "relationalOperator", "mkdirStatement", 
                   "setLocalStatement", "typeStatement", "rmdirStatement", 
                   "xcopyStatement", "xCopySource", "xCopyDestination", 
                   "switches", "switch", "dateFormat", "setLocalOption", 
                   "setStatement", "displayFormating", "assignmentPart", 
                   "pauseStatement", "variableName", "value", "calcValue", 
                   "calcOperator", "filePath", "fileName", "fileNameChar", 
                   "identifierCombinedWithReferencedVariable", "idetifierOrRerencedVariable", 
                   "referencedVariable", "variableSubstring", "leftSubstring", 
                   "rightSubstring", "replacedOrRemovedSubstring", "removeSubstring", 
                   "removedSubstring", "removeSpaces", "replaceSubstring", 
                   "subtringRemoved", "subStringReplaced", "startSub", "lengthSub", 
                   "variableStart", "variableLength", "concatenateString" ]

    EOF = Token.EOF
    COND_COLON=1
    STRING=2
    ECHOSTATEMENT=3
    REMSTATEMENT=4
    EXE_FILE=5
    ENABLEDELAYEDEXPANSION=6
    DISABLEDELAYEDEXPANSION=7
    INT=8
    WS=9
    NL=10
    COMMENTLINE=11
    LPAREN=12
    RPAREN=13
    ECHO=14
    SET=15
    SETLOCAL=16
    REM=17
    COLON=18
    EQUAL=19
    JP_EQUAL=20
    ATSIGN=21
    SLASH=22
    QUESTION=23
    SSLASH=24
    DASH_SFX=25
    DASH_TZIP=26
    DASH_SORT=27
    DASH_INPUT=28
    DASH_OUTPUT=29
    DASH_OPTION=30
    DASH_RECORD=31
    DASH_P=32
    DASH_W=33
    DASH_Y=34
    SLASH_W=35
    SLASH_P=36
    SLASH_C=37
    SLASH_V=38
    SLASH_Q=39
    SLASH_F=40
    SLASH_L=41
    SLASH_G=42
    SLASH_D=43
    SLASH_U=44
    SLASH_I=45
    SLASH_S=46
    SLASH_E=47
    SLASH_T=48
    SLASH_K=49
    SLASH_R=50
    SLASH_H=51
    SLASH_A=52
    SLASH_M=53
    SLASH_N=54
    SLASH_O=55
    SLASH_X=56
    SLASH_Y=57
    SLASH_Z=58
    SLASH_B=59
    SLASH_J=60
    SLASH_COMPRESS=61
    SLASH_EXCLUDE=62
    DOT=63
    COND=64
    DISK_ADDRESS=65
    BSORTEX=66
    CALL=67
    DEL=68
    ELSE=69
    EQU=70
    EXIST=71
    EXE=72
    ENDLOCAL=73
    EXIT=74
    IF=75
    GOTO=76
    GTR=77
    NUL=78
    NEQ=79
    PAUSE=80
    RMDIR=81
    FOR=82
    IN=83
    DO=84
    PERCENT=85
    EXCLAMATION=86
    MKDIR=87
    XCOPY=88
    TYPE=89
    Z7=90
    DASH=91
    UNDERSCORE=92
    GREATER_CHAR=93
    TILDE=94
    TILDE_NX=95
    COMMA=96
    PLUS=97
    STAR=98
    JP_TXT=99
    JP_CHAR=100
    IDENTIFIER=101
    STRING_CHARACTERS=102

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(BatchParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.StatementContext)
            else:
                return self.getTypedRuleContext(BatchParser.StatementContext,i)


        def label(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.LabelContext)
            else:
                return self.getTypedRuleContext(BatchParser.LabelContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_startRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartRule" ):
                listener.enterStartRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartRule" ):
                listener.exitStartRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartRule" ):
                return visitor.visitStartRule(self)
            else:
                return visitor.visitChildren(self)




    def startRule(self):

        localctx = BatchParser.StartRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_startRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036829511624) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 96803721103) != 0):
                self.state = 188
                self.statement()
                self.state = 193
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 194
                self.label()
                self.state = 199
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 200
            self.match(BatchParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelName(self):
            return self.getTypedRuleContext(BatchParser.LabelNameContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.StatementContext)
            else:
                return self.getTypedRuleContext(BatchParser.StatementContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = BatchParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_label)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.labelName()
            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036829511624) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 96803721103) != 0):
                self.state = 203
                self.statement()
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(BatchParser.COLON, 0)

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_labelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelName" ):
                listener.enterLabelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelName" ):
                listener.exitLabelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelName" ):
                return visitor.visitLabelName(self)
            else:
                return visitor.visitChildren(self)




    def labelName(self):

        localctx = BatchParser.LabelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_labelName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(BatchParser.COLON)
            self.state = 210
            self.match(BatchParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def setStatement(self):
            return self.getTypedRuleContext(BatchParser.SetStatementContext,0)


        def setLocalStatement(self):
            return self.getTypedRuleContext(BatchParser.SetLocalStatementContext,0)


        def delStatement(self):
            return self.getTypedRuleContext(BatchParser.DelStatementContext,0)


        def pauseStatement(self):
            return self.getTypedRuleContext(BatchParser.PauseStatementContext,0)


        def mkdirStatement(self):
            return self.getTypedRuleContext(BatchParser.MkdirStatementContext,0)


        def xcopyStatement(self):
            return self.getTypedRuleContext(BatchParser.XcopyStatementContext,0)


        def callStatement(self):
            return self.getTypedRuleContext(BatchParser.CallStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(BatchParser.IfStatementContext,0)


        def gotoStatement(self):
            return self.getTypedRuleContext(BatchParser.GotoStatementContext,0)


        def echoStatement(self):
            return self.getTypedRuleContext(BatchParser.EchoStatementContext,0)


        def remStatement(self):
            return self.getTypedRuleContext(BatchParser.RemStatementContext,0)


        def endlocalStatement(self):
            return self.getTypedRuleContext(BatchParser.EndlocalStatementContext,0)


        def exitStatement(self):
            return self.getTypedRuleContext(BatchParser.ExitStatementContext,0)


        def execStatement(self):
            return self.getTypedRuleContext(BatchParser.ExecStatementContext,0)


        def rmdirStatement(self):
            return self.getTypedRuleContext(BatchParser.RmdirStatementContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(BatchParser.ForStatementContext,0)


        def typeStatement(self):
            return self.getTypedRuleContext(BatchParser.TypeStatementContext,0)


        def z7Statement(self):
            return self.getTypedRuleContext(BatchParser.Z7StatementContext,0)


        def bsortexStatement(self):
            return self.getTypedRuleContext(BatchParser.BsortexStatementContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = BatchParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statement)
        try:
            self.state = 231
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 212
                self.setStatement()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 213
                self.setLocalStatement()
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 3)
                self.state = 214
                self.delStatement()
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 4)
                self.state = 215
                self.pauseStatement()
                pass
            elif token in [87]:
                self.enterOuterAlt(localctx, 5)
                self.state = 216
                self.mkdirStatement()
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 6)
                self.state = 217
                self.xcopyStatement()
                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 7)
                self.state = 218
                self.callStatement()
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 8)
                self.state = 219
                self.ifStatement()
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 9)
                self.state = 220
                self.gotoStatement()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 10)
                self.state = 221
                self.echoStatement()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 11)
                self.state = 222
                self.remStatement()
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 12)
                self.state = 223
                self.endlocalStatement()
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 13)
                self.state = 224
                self.exitStatement()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 14)
                self.state = 225
                self.execStatement()
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 15)
                self.state = 226
                self.rmdirStatement()
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 16)
                self.state = 227
                self.forStatement()
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 17)
                self.state = 228
                self.typeStatement()
                pass
            elif token in [23, 24, 63, 65, 72, 85, 86, 92, 96, 98, 99, 101]:
                self.enterOuterAlt(localctx, 18)
                self.state = 229
                self.z7Statement()
                pass
            elif token in [66]:
                self.enterOuterAlt(localctx, 19)
                self.state = 230
                self.bsortexStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Z7StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self):
            return self.getTypedRuleContext(BatchParser.FilePathContext,0)


        def Z7(self):
            return self.getToken(BatchParser.Z7, 0)

        def z7Command(self):
            return self.getTypedRuleContext(BatchParser.Z7CommandContext,0)


        def z7Switches(self):
            return self.getTypedRuleContext(BatchParser.Z7SwitchesContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_z7Statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZ7Statement" ):
                listener.enterZ7Statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZ7Statement" ):
                listener.exitZ7Statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZ7Statement" ):
                return visitor.visitZ7Statement(self)
            else:
                return visitor.visitChildren(self)




    def z7Statement(self):

        localctx = BatchParser.Z7StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_z7Statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.filePath()
            self.state = 234
            self.match(BatchParser.Z7)
            self.state = 235
            self.z7Command()
            self.state = 236
            self.z7Switches()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Z7CommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_z7Command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZ7Command" ):
                listener.enterZ7Command(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZ7Command" ):
                listener.exitZ7Command(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZ7Command" ):
                return visitor.visitZ7Command(self)
            else:
                return visitor.visitChildren(self)




    def z7Command(self):

        localctx = BatchParser.Z7CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_z7Command)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(BatchParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Z7SwitchesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def z7Switch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.Z7SwitchContext)
            else:
                return self.getTypedRuleContext(BatchParser.Z7SwitchContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_z7Switches

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZ7Switches" ):
                listener.enterZ7Switches(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZ7Switches" ):
                listener.exitZ7Switches(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZ7Switches" ):
                return visitor.visitZ7Switches(self)
            else:
                return visitor.visitChildren(self)




    def z7Switches(self):

        localctx = BatchParser.Z7SwitchesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_z7Switches)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 240
                self.z7Switch()
                self.state = 243 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 30165434368) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Z7SwitchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DASH_SFX(self):
            return self.getToken(BatchParser.DASH_SFX, 0)

        def DASH_P(self):
            return self.getToken(BatchParser.DASH_P, 0)

        def DASH_W(self):
            return self.getToken(BatchParser.DASH_W, 0)

        def DASH_Y(self):
            return self.getToken(BatchParser.DASH_Y, 0)

        def DASH_TZIP(self):
            return self.getToken(BatchParser.DASH_TZIP, 0)

        def referencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.ReferencedVariableContext)
            else:
                return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_z7Switch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZ7Switch" ):
                listener.enterZ7Switch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZ7Switch" ):
                listener.exitZ7Switch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZ7Switch" ):
                return visitor.visitZ7Switch(self)
            else:
                return visitor.visitChildren(self)




    def z7Switch(self):

        localctx = BatchParser.Z7SwitchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_z7Switch)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 30165434368) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 249
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 246
                    self.referencedVariable() 
                self.state = 251
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EchoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ECHOSTATEMENT(self):
            return self.getToken(BatchParser.ECHOSTATEMENT, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_echoStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEchoStatement" ):
                listener.enterEchoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEchoStatement" ):
                listener.exitEchoStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEchoStatement" ):
                return visitor.visitEchoStatement(self)
            else:
                return visitor.visitChildren(self)




    def echoStatement(self):

        localctx = BatchParser.EchoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_echoStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.match(BatchParser.ECHOSTATEMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMSTATEMENT(self):
            return self.getToken(BatchParser.REMSTATEMENT, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_remStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemStatement" ):
                listener.enterRemStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemStatement" ):
                listener.exitRemStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemStatement" ):
                return visitor.visitRemStatement(self)
            else:
                return visitor.visitChildren(self)




    def remStatement(self):

        localctx = BatchParser.RemStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_remStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(BatchParser.REMSTATEMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BsortexStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BSORTEX(self):
            return self.getToken(BatchParser.BSORTEX, 0)

        def sortParameters(self):
            return self.getTypedRuleContext(BatchParser.SortParametersContext,0)


        def inputParameters(self):
            return self.getTypedRuleContext(BatchParser.InputParametersContext,0)


        def recordParameters(self):
            return self.getTypedRuleContext(BatchParser.RecordParametersContext,0)


        def optionParameters(self):
            return self.getTypedRuleContext(BatchParser.OptionParametersContext,0)


        def outputParameters(self):
            return self.getTypedRuleContext(BatchParser.OutputParametersContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_bsortexStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBsortexStatement" ):
                listener.enterBsortexStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBsortexStatement" ):
                listener.exitBsortexStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBsortexStatement" ):
                return visitor.visitBsortexStatement(self)
            else:
                return visitor.visitChildren(self)




    def bsortexStatement(self):

        localctx = BatchParser.BsortexStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_bsortexStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.match(BatchParser.BSORTEX)
            self.state = 257
            self.sortParameters()
            self.state = 258
            self.inputParameters()
            self.state = 259
            self.recordParameters()
            self.state = 260
            self.optionParameters()
            self.state = 261
            self.outputParameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DASH_SORT(self):
            return self.getToken(BatchParser.DASH_SORT, 0)

        def sortParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.SortParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.SortParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_sortParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortParameters" ):
                listener.enterSortParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortParameters" ):
                listener.exitSortParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortParameters" ):
                return visitor.visitSortParameters(self)
            else:
                return visitor.visitChildren(self)




    def sortParameters(self):

        localctx = BatchParser.SortParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_sortParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(BatchParser.DASH_SORT)
            self.state = 265 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 264
                self.sortParameter()
                self.state = 267 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==101):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def EQUAL(self):
            return self.getToken(BatchParser.EQUAL, 0)

        def sortValue(self):
            return self.getTypedRuleContext(BatchParser.SortValueContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_sortParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortParameter" ):
                listener.enterSortParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortParameter" ):
                listener.exitSortParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortParameter" ):
                return visitor.visitSortParameter(self)
            else:
                return visitor.visitChildren(self)




    def sortParameter(self):

        localctx = BatchParser.SortParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_sortParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.variableName()
            self.state = 270
            self.match(BatchParser.EQUAL)
            self.state = 271
            self.sortValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.INT)
            else:
                return self.getToken(BatchParser.INT, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.DOT)
            else:
                return self.getToken(BatchParser.DOT, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.IDENTIFIER)
            else:
                return self.getToken(BatchParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return BatchParser.RULE_sortValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortValue" ):
                listener.enterSortValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortValue" ):
                listener.exitSortValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortValue" ):
                return visitor.visitSortValue(self)
            else:
                return visitor.visitChildren(self)




    def sortValue(self):

        localctx = BatchParser.SortValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_sortValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 273
                    _la = self._input.LA(1)
                    if not(_la==8 or _la==63 or _la==101):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 276 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DASH_INPUT(self):
            return self.getToken(BatchParser.DASH_INPUT, 0)

        def inputParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.InputParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.InputParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_inputParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInputParameters" ):
                listener.enterInputParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInputParameters" ):
                listener.exitInputParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputParameters" ):
                return visitor.visitInputParameters(self)
            else:
                return visitor.visitChildren(self)




    def inputParameters(self):

        localctx = BatchParser.InputParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_inputParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(BatchParser.DASH_INPUT)
            self.state = 280 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 279
                self.inputParameter()
                self.state = 282 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==101):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def assignmentPart(self):
            return self.getTypedRuleContext(BatchParser.AssignmentPartContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_inputParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInputParameter" ):
                listener.enterInputParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInputParameter" ):
                listener.exitInputParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputParameter" ):
                return visitor.visitInputParameter(self)
            else:
                return visitor.visitChildren(self)




    def inputParameter(self):

        localctx = BatchParser.InputParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_inputParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.variableName()
            self.state = 285
            self.assignmentPart()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RecordParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DASH_RECORD(self):
            return self.getToken(BatchParser.DASH_RECORD, 0)

        def recordParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.RecordParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.RecordParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_recordParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecordParameters" ):
                listener.enterRecordParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecordParameters" ):
                listener.exitRecordParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecordParameters" ):
                return visitor.visitRecordParameters(self)
            else:
                return visitor.visitChildren(self)




    def recordParameters(self):

        localctx = BatchParser.RecordParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_recordParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(BatchParser.DASH_RECORD)
            self.state = 289 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 288
                self.recordParameter()
                self.state = 291 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==101):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RecordParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def assignmentPart(self):
            return self.getTypedRuleContext(BatchParser.AssignmentPartContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_recordParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecordParameter" ):
                listener.enterRecordParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecordParameter" ):
                listener.exitRecordParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecordParameter" ):
                return visitor.visitRecordParameter(self)
            else:
                return visitor.visitChildren(self)




    def recordParameter(self):

        localctx = BatchParser.RecordParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_recordParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.variableName()
            self.state = 294
            self.assignmentPart()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DASH_OPTION(self):
            return self.getToken(BatchParser.DASH_OPTION, 0)

        def optionParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.OptionParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.OptionParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_optionParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionParameters" ):
                listener.enterOptionParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionParameters" ):
                listener.exitOptionParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionParameters" ):
                return visitor.visitOptionParameters(self)
            else:
                return visitor.visitChildren(self)




    def optionParameters(self):

        localctx = BatchParser.OptionParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_optionParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(BatchParser.DASH_OPTION)
            self.state = 298 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 297
                self.optionParameter()
                self.state = 300 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==101):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def assignmentPart(self):
            return self.getTypedRuleContext(BatchParser.AssignmentPartContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_optionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionParameter" ):
                listener.enterOptionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionParameter" ):
                listener.exitOptionParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionParameter" ):
                return visitor.visitOptionParameter(self)
            else:
                return visitor.visitChildren(self)




    def optionParameter(self):

        localctx = BatchParser.OptionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_optionParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.variableName()
            self.state = 304
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19 or _la==22 or ((((_la - 91)) & ~0x3f) == 0 and ((1 << (_la - 91)) & 193) != 0):
                self.state = 303
                self.assignmentPart()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DASH_OUTPUT(self):
            return self.getToken(BatchParser.DASH_OUTPUT, 0)

        def outputParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.OutputParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.OutputParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_outputParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputParameters" ):
                listener.enterOutputParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputParameters" ):
                listener.exitOutputParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputParameters" ):
                return visitor.visitOutputParameters(self)
            else:
                return visitor.visitChildren(self)




    def outputParameters(self):

        localctx = BatchParser.OutputParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_outputParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self.match(BatchParser.DASH_OUTPUT)
            self.state = 308 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 307
                    self.outputParameter()

                else:
                    raise NoViableAltException(self)
                self.state = 310 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def EQUAL(self):
            return self.getToken(BatchParser.EQUAL, 0)

        def outputValue(self):
            return self.getTypedRuleContext(BatchParser.OutputValueContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_outputParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputParameter" ):
                listener.enterOutputParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputParameter" ):
                listener.exitOutputParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputParameter" ):
                return visitor.visitOutputParameter(self)
            else:
                return visitor.visitChildren(self)




    def outputParameter(self):

        localctx = BatchParser.OutputParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_outputParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self.variableName()
            self.state = 313
            self.match(BatchParser.EQUAL)
            self.state = 314
            self.outputValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def LPAREN(self):
            return self.getToken(BatchParser.LPAREN, 0)

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def RPAREN(self):
            return self.getToken(BatchParser.RPAREN, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_outputValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputValue" ):
                listener.enterOutputValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputValue" ):
                listener.exitOutputValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputValue" ):
                return visitor.visitOutputValue(self)
            else:
                return visitor.visitChildren(self)




    def outputValue(self):

        localctx = BatchParser.OutputValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_outputValue)
        try:
            self.state = 321
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 316
                self.value()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 317
                self.referencedVariable()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 318
                self.match(BatchParser.LPAREN)
                self.state = 319
                self.match(BatchParser.STRING)
                self.state = 320
                self.match(BatchParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(BatchParser.CALL, 0)

        def callWithLabel(self):
            return self.getTypedRuleContext(BatchParser.CallWithLabelContext,0)


        def callWithFilePath(self):
            return self.getTypedRuleContext(BatchParser.CallWithFilePathContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_callStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallStatement" ):
                listener.enterCallStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallStatement" ):
                listener.exitCallStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallStatement" ):
                return visitor.visitCallStatement(self)
            else:
                return visitor.visitChildren(self)




    def callStatement(self):

        localctx = BatchParser.CallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_callStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            self.match(BatchParser.CALL)
            self.state = 326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [18]:
                self.state = 324
                self.callWithLabel()
                pass
            elif token in [23, 24, 63, 65, 72, 85, 86, 92, 96, 98, 99, 101]:
                self.state = 325
                self.callWithFilePath()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallWithLabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelName(self):
            return self.getTypedRuleContext(BatchParser.LabelNameContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_callWithLabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallWithLabel" ):
                listener.enterCallWithLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallWithLabel" ):
                listener.exitCallWithLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallWithLabel" ):
                return visitor.visitCallWithLabel(self)
            else:
                return visitor.visitChildren(self)




    def callWithLabel(self):

        localctx = BatchParser.CallWithLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_callWithLabel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.labelName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallWithFilePathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.FilePathContext)
            else:
                return self.getTypedRuleContext(BatchParser.FilePathContext,i)


        def fileName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.FileNameContext)
            else:
                return self.getTypedRuleContext(BatchParser.FileNameContext,i)


        def conditionParameter(self):
            return self.getTypedRuleContext(BatchParser.ConditionParameterContext,0)


        def batchParameters(self):
            return self.getTypedRuleContext(BatchParser.BatchParametersContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_callWithFilePath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallWithFilePath" ):
                listener.enterCallWithFilePath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallWithFilePath" ):
                listener.exitCallWithFilePath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallWithFilePath" ):
                return visitor.visitCallWithFilePath(self)
            else:
                return visitor.visitChildren(self)




    def callWithFilePath(self):

        localctx = BatchParser.CallWithFilePathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_callWithFilePath)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 332
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                    if la_ == 1:
                        self.state = 330
                        self.filePath()
                        pass

                    elif la_ == 2:
                        self.state = 331
                        self.fileName()
                        pass



                else:
                    raise NoViableAltException(self)
                self.state = 334 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

            self.state = 337
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 336
                self.conditionParameter()


            self.state = 340
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 339
                self.batchParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BatchParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def batchParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.BatchParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.BatchParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_batchParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBatchParameters" ):
                listener.enterBatchParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBatchParameters" ):
                listener.exitBatchParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBatchParameters" ):
                return visitor.visitBatchParameters(self)
            else:
                return visitor.visitChildren(self)




    def batchParameters(self):

        localctx = BatchParser.BatchParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_batchParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 342
                    self.batchParameter()

                else:
                    raise NoViableAltException(self)
                self.state = 345 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BatchParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def PERCENT(self):
            return self.getToken(BatchParser.PERCENT, 0)

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def forVariable(self):
            return self.getTypedRuleContext(BatchParser.ForVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_batchParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBatchParameter" ):
                listener.enterBatchParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBatchParameter" ):
                listener.exitBatchParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBatchParameter" ):
                return visitor.visitBatchParameter(self)
            else:
                return visitor.visitChildren(self)




    def batchParameter(self):

        localctx = BatchParser.BatchParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_batchParameter)
        try:
            self.state = 353
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 347
                self.match(BatchParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 348
                self.match(BatchParser.STRING)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 349
                self.match(BatchParser.PERCENT)
                self.state = 350
                self.match(BatchParser.INT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 351
                self.referencedVariable()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 352
                self.forVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COND_COLON(self):
            return self.getToken(BatchParser.COND_COLON, 0)

        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.INT)
            else:
                return self.getToken(BatchParser.INT, i)

        def SLASH(self):
            return self.getToken(BatchParser.SLASH, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_conditionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionParameter" ):
                listener.enterConditionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionParameter" ):
                listener.exitConditionParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionParameter" ):
                return visitor.visitConditionParameter(self)
            else:
                return visitor.visitChildren(self)




    def conditionParameter(self):

        localctx = BatchParser.ConditionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_conditionParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self.match(BatchParser.COND_COLON)
            self.state = 356
            self.match(BatchParser.INT)
            self.state = 357
            self.match(BatchParser.SLASH)
            self.state = 358
            self.match(BatchParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DelStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEL(self):
            return self.getToken(BatchParser.DEL, 0)

        def filePath(self):
            return self.getTypedRuleContext(BatchParser.FilePathContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_delStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelStatement" ):
                listener.enterDelStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelStatement" ):
                listener.exitDelStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelStatement" ):
                return visitor.visitDelStatement(self)
            else:
                return visitor.visitChildren(self)




    def delStatement(self):

        localctx = BatchParser.DelStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_delStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(BatchParser.DEL)
            self.state = 361
            self.filePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndlocalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENDLOCAL(self):
            return self.getToken(BatchParser.ENDLOCAL, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_endlocalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndlocalStatement" ):
                listener.enterEndlocalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndlocalStatement" ):
                listener.exitEndlocalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndlocalStatement" ):
                return visitor.visitEndlocalStatement(self)
            else:
                return visitor.visitChildren(self)




    def endlocalStatement(self):

        localctx = BatchParser.EndlocalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_endlocalStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(BatchParser.ENDLOCAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def execFile(self):
            return self.getTypedRuleContext(BatchParser.ExecFileContext,0)


        def switches(self):
            return self.getTypedRuleContext(BatchParser.SwitchesContext,0)


        def execParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.ExecParameterContext)
            else:
                return self.getTypedRuleContext(BatchParser.ExecParameterContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_execStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecStatement" ):
                listener.enterExecStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecStatement" ):
                listener.exitExecStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecStatement" ):
                return visitor.visitExecStatement(self)
            else:
                return visitor.visitChildren(self)




    def execStatement(self):

        localctx = BatchParser.ExecStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_execStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.execFile()
            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 9223372002495037440) != 0):
                self.state = 366
                self.switches()


            self.state = 372
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 369
                    self.execParameter() 
                self.state = 374
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecFileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXE_FILE(self):
            return self.getToken(BatchParser.EXE_FILE, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_execFile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecFile" ):
                listener.enterExecFile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecFile" ):
                listener.exitExecFile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecFile" ):
                return visitor.visitExecFile(self)
            else:
                return visitor.visitChildren(self)




    def execFile(self):

        localctx = BatchParser.ExecFileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_execFile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self.match(BatchParser.EXE_FILE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def filePath(self):
            return self.getTypedRuleContext(BatchParser.FilePathContext,0)


        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def concatenateString(self):
            return self.getTypedRuleContext(BatchParser.ConcatenateStringContext,0)


        def concatenateFileContent(self):
            return self.getTypedRuleContext(BatchParser.ConcatenateFileContentContext,0)


        def forVariable(self):
            return self.getTypedRuleContext(BatchParser.ForVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_execParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecParameter" ):
                listener.enterExecParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecParameter" ):
                listener.exitExecParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecParameter" ):
                return visitor.visitExecParameter(self)
            else:
                return visitor.visitChildren(self)




    def execParameter(self):

        localctx = BatchParser.ExecParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_execParameter)
        try:
            self.state = 385
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 377
                self.match(BatchParser.INT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 378
                self.referencedVariable()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 379
                self.match(BatchParser.IDENTIFIER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 380
                self.filePath()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 381
                self.match(BatchParser.STRING)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 382
                self.concatenateString()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 383
                self.concatenateFileContent()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 384
                self.forVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConcatenateFileContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(BatchParser.PLUS, 0)

        def filePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.FilePathContext)
            else:
                return self.getTypedRuleContext(BatchParser.FilePathContext,i)


        def referencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.ReferencedVariableContext)
            else:
                return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_concatenateFileContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenateFileContent" ):
                listener.enterConcatenateFileContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenateFileContent" ):
                listener.exitConcatenateFileContent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenateFileContent" ):
                return visitor.visitConcatenateFileContent(self)
            else:
                return visitor.visitChildren(self)




    def concatenateFileContent(self):

        localctx = BatchParser.ConcatenateFileContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_concatenateFileContent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 387
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 388
                self.referencedVariable()
                pass


            self.state = 391
            self.match(BatchParser.PLUS)
            self.state = 394
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 392
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 393
                self.referencedVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExitStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXIT(self):
            return self.getToken(BatchParser.EXIT, 0)

        def exitCurrentBatch(self):
            return self.getTypedRuleContext(BatchParser.ExitCurrentBatchContext,0)


        def exitCode(self):
            return self.getTypedRuleContext(BatchParser.ExitCodeContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_exitStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExitStatement" ):
                listener.enterExitStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExitStatement" ):
                listener.exitExitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExitStatement" ):
                return visitor.visitExitStatement(self)
            else:
                return visitor.visitChildren(self)




    def exitStatement(self):

        localctx = BatchParser.ExitStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_exitStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.match(BatchParser.EXIT)
            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==59:
                self.state = 397
                self.exitCurrentBatch()


            self.state = 401
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 400
                self.exitCode()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExitCurrentBatchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH_B(self):
            return self.getToken(BatchParser.SLASH_B, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_exitCurrentBatch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExitCurrentBatch" ):
                listener.enterExitCurrentBatch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExitCurrentBatch" ):
                listener.exitExitCurrentBatch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExitCurrentBatch" ):
                return visitor.visitExitCurrentBatch(self)
            else:
                return visitor.visitChildren(self)




    def exitCurrentBatch(self):

        localctx = BatchParser.ExitCurrentBatchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_exitCurrentBatch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.match(BatchParser.SLASH_B)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExitCodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_exitCode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExitCode" ):
                listener.enterExitCode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExitCode" ):
                listener.exitExitCode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExitCode" ):
                return visitor.visitExitCode(self)
            else:
                return visitor.visitChildren(self)




    def exitCode(self):

        localctx = BatchParser.ExitCodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_exitCode)
        try:
            self.state = 407
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 405
                self.match(BatchParser.INT)
                pass
            elif token in [85, 86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 406
                self.referencedVariable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(BatchParser.FOR, 0)

        def IN(self):
            return self.getToken(BatchParser.IN, 0)

        def DO(self):
            return self.getToken(BatchParser.DO, 0)

        def forVariable(self):
            return self.getTypedRuleContext(BatchParser.ForVariableContext,0)


        def forValues(self):
            return self.getTypedRuleContext(BatchParser.ForValuesContext,0)


        def forDo(self):
            return self.getTypedRuleContext(BatchParser.ForDoContext,0)


        def switches(self):
            return self.getTypedRuleContext(BatchParser.SwitchesContext,0)


        def configurationString(self):
            return self.getTypedRuleContext(BatchParser.ConfigurationStringContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_forStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStatement" ):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)




    def forStatement(self):

        localctx = BatchParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_forStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 409
            self.match(BatchParser.FOR)
            self.state = 411
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 9223372002495037440) != 0):
                self.state = 410
                self.switches()


            self.state = 414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2:
                self.state = 413
                self.configurationString()


            self.state = 416
            self.forVariable()
            self.state = 417
            self.match(BatchParser.IN)

            self.state = 418
            self.forValues()
            self.state = 419
            self.match(BatchParser.DO)

            self.state = 420
            self.forDo()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfigurationStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_configurationString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfigurationString" ):
                listener.enterConfigurationString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfigurationString" ):
                listener.exitConfigurationString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfigurationString" ):
                return visitor.visitConfigurationString(self)
            else:
                return visitor.visitChildren(self)




    def configurationString(self):

        localctx = BatchParser.ConfigurationStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_configurationString)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(BatchParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(BatchParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BatchParser.RPAREN, 0)

        def forValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.ForValueContext)
            else:
                return self.getTypedRuleContext(BatchParser.ForValueContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_forValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForValues" ):
                listener.enterForValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForValues" ):
                listener.exitForValues(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForValues" ):
                return visitor.visitForValues(self)
            else:
                return visitor.visitChildren(self)




    def forValues(self):

        localctx = BatchParser.ForValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_forValues)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 424
            self.match(BatchParser.LPAREN)
            self.state = 426 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 425
                self.forValue()
                self.state = 428 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036829609724) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 96774127745) != 0)):
                    break

            self.state = 430
            self.match(BatchParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def filePath(self):
            return self.getTypedRuleContext(BatchParser.FilePathContext,0)


        def fileName(self):
            return self.getTypedRuleContext(BatchParser.FileNameContext,0)


        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def forVariable(self):
            return self.getTypedRuleContext(BatchParser.ForVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_forValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForValue" ):
                listener.enterForValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForValue" ):
                listener.exitForValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForValue" ):
                return visitor.visitForValue(self)
            else:
                return visitor.visitChildren(self)




    def forValue(self):

        localctx = BatchParser.ForValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_forValue)
        try:
            self.state = 438
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 432
                self.match(BatchParser.INT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 433
                self.match(BatchParser.STRING)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 434
                self.filePath()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 435
                self.fileName()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 436
                self.referencedVariable()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 437
                self.forVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.PERCENT)
            else:
                return self.getToken(BatchParser.PERCENT, i)

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def forVariableModifier(self):
            return self.getTypedRuleContext(BatchParser.ForVariableModifierContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_forVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForVariable" ):
                listener.enterForVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForVariable" ):
                listener.exitForVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForVariable" ):
                return visitor.visitForVariable(self)
            else:
                return visitor.visitChildren(self)




    def forVariable(self):

        localctx = BatchParser.ForVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_forVariable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            self.match(BatchParser.PERCENT)
            self.state = 441
            self.match(BatchParser.PERCENT)
            self.state = 443
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==95:
                self.state = 442
                self.forVariableModifier()


            self.state = 445
            self.match(BatchParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForVariableModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TILDE_NX(self):
            return self.getToken(BatchParser.TILDE_NX, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_forVariableModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForVariableModifier" ):
                listener.enterForVariableModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForVariableModifier" ):
                listener.exitForVariableModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForVariableModifier" ):
                return visitor.visitForVariableModifier(self)
            else:
                return visitor.visitChildren(self)




    def forVariableModifier(self):

        localctx = BatchParser.ForVariableModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_forVariableModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(BatchParser.TILDE_NX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForDoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(BatchParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BatchParser.RPAREN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.StatementContext)
            else:
                return self.getTypedRuleContext(BatchParser.StatementContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_forDo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForDo" ):
                listener.enterForDo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForDo" ):
                listener.exitForDo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForDo" ):
                return visitor.visitForDo(self)
            else:
                return visitor.visitChildren(self)




    def forDo(self):

        localctx = BatchParser.ForDoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_forDo)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 449
            self.match(BatchParser.LPAREN)
            self.state = 451 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 450
                self.statement()
                self.state = 453 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036829511624) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 96803721103) != 0)):
                    break

            self.state = 455
            self.match(BatchParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GOTO(self):
            return self.getToken(BatchParser.GOTO, 0)

        def labelName(self):
            return self.getTypedRuleContext(BatchParser.LabelNameContext,0)


        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_gotoStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGotoStatement" ):
                listener.enterGotoStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGotoStatement" ):
                listener.exitGotoStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGotoStatement" ):
                return visitor.visitGotoStatement(self)
            else:
                return visitor.visitChildren(self)




    def gotoStatement(self):

        localctx = BatchParser.GotoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_gotoStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.match(BatchParser.GOTO)
            self.state = 460
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 458
                self.labelName()

            elif la_ == 2:
                self.state = 459
                self.match(BatchParser.IDENTIFIER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(BatchParser.IF, 0)

        def condition(self):
            return self.getTypedRuleContext(BatchParser.ConditionContext,0)


        def ifThen(self):
            return self.getTypedRuleContext(BatchParser.IfThenContext,0)


        def ifElse(self):
            return self.getTypedRuleContext(BatchParser.IfElseContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = BatchParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.match(BatchParser.IF)
            self.state = 463
            self.condition()
            self.state = 464
            self.ifThen()
            self.state = 466
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 465
                self.ifElse()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfThenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(BatchParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BatchParser.RPAREN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.StatementContext)
            else:
                return self.getTypedRuleContext(BatchParser.StatementContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_ifThen

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfThen" ):
                listener.enterIfThen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfThen" ):
                listener.exitIfThen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfThen" ):
                return visitor.visitIfThen(self)
            else:
                return visitor.visitChildren(self)




    def ifThen(self):

        localctx = BatchParser.IfThenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_ifThen)
        self._la = 0 # Token type
        try:
            self.state = 477
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 468
                self.match(BatchParser.LPAREN)
                self.state = 470 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 469
                    self.statement()
                    self.state = 472 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036829511624) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 96803721103) != 0)):
                        break

                self.state = 474
                self.match(BatchParser.RPAREN)
                pass
            elif token in [3, 4, 5, 15, 16, 23, 24, 63, 65, 66, 67, 68, 72, 73, 74, 75, 76, 80, 81, 82, 85, 86, 87, 88, 89, 92, 96, 98, 99, 101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 476
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfElseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(BatchParser.ELSE, 0)

        def LPAREN(self):
            return self.getToken(BatchParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BatchParser.RPAREN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.StatementContext)
            else:
                return self.getTypedRuleContext(BatchParser.StatementContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_ifElse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfElse" ):
                listener.enterIfElse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfElse" ):
                listener.exitIfElse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfElse" ):
                return visitor.visitIfElse(self)
            else:
                return visitor.visitChildren(self)




    def ifElse(self):

        localctx = BatchParser.IfElseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_ifElse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(BatchParser.ELSE)
            self.state = 480
            self.match(BatchParser.LPAREN)
            self.state = 482 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 481
                self.statement()
                self.state = 484 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036829511624) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 96803721103) != 0)):
                    break

            self.state = 486
            self.match(BatchParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(BatchParser.StatementContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_simpleIf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleIf" ):
                listener.enterSimpleIf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleIf" ):
                listener.exitSimpleIf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleIf" ):
                return visitor.visitSimpleIf(self)
            else:
                return visitor.visitChildren(self)




    def simpleIf(self):

        localctx = BatchParser.SimpleIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_simpleIf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationalOperator(self):
            return self.getTypedRuleContext(BatchParser.RelationalOperatorContext,0)


        def rightConditionOperator(self):
            return self.getTypedRuleContext(BatchParser.RightConditionOperatorContext,0)


        def leftConditionOperator(self):
            return self.getTypedRuleContext(BatchParser.LeftConditionOperatorContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = BatchParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 491
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2 or ((((_la - 85)) & ~0x3f) == 0 and ((1 << (_la - 85)) & 65539) != 0):
                self.state = 490
                self.leftConditionOperator()


            self.state = 493
            self.relationalOperator()
            self.state = 494
            self.rightConditionOperator()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeftConditionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_leftConditionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftConditionOperator" ):
                listener.enterLeftConditionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftConditionOperator" ):
                listener.exitLeftConditionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeftConditionOperator" ):
                return visitor.visitLeftConditionOperator(self)
            else:
                return visitor.visitChildren(self)




    def leftConditionOperator(self):

        localctx = BatchParser.LeftConditionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_leftConditionOperator)
        try:
            self.state = 499
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 496
                self.match(BatchParser.STRING)
                pass
            elif token in [85, 86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 497
                self.referencedVariable()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 3)
                self.state = 498
                self.match(BatchParser.IDENTIFIER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightConditionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_rightConditionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightConditionOperator" ):
                listener.enterRightConditionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightConditionOperator" ):
                listener.exitRightConditionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightConditionOperator" ):
                return visitor.visitRightConditionOperator(self)
            else:
                return visitor.visitChildren(self)




    def rightConditionOperator(self):

        localctx = BatchParser.RightConditionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_rightConditionOperator)
        try:
            self.state = 505
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 501
                self.match(BatchParser.STRING)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 502
                self.match(BatchParser.INT)
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 3)
                self.state = 503
                self.match(BatchParser.IDENTIFIER)
                pass
            elif token in [85, 86]:
                self.enterOuterAlt(localctx, 4)
                self.state = 504
                self.referencedVariable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQU(self):
            return self.getToken(BatchParser.EQU, 0)

        def NEQ(self):
            return self.getToken(BatchParser.NEQ, 0)

        def EXIST(self):
            return self.getToken(BatchParser.EXIST, 0)

        def GTR(self):
            return self.getToken(BatchParser.GTR, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_relationalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalOperator" ):
                listener.enterRelationalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalOperator" ):
                listener.exitRelationalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationalOperator" ):
                return visitor.visitRelationalOperator(self)
            else:
                return visitor.visitChildren(self)




    def relationalOperator(self):

        localctx = BatchParser.RelationalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_relationalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 507
            _la = self._input.LA(1)
            if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 643) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MkdirStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MKDIR(self):
            return self.getToken(BatchParser.MKDIR, 0)

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_mkdirStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMkdirStatement" ):
                listener.enterMkdirStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMkdirStatement" ):
                listener.exitMkdirStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMkdirStatement" ):
                return visitor.visitMkdirStatement(self)
            else:
                return visitor.visitChildren(self)




    def mkdirStatement(self):

        localctx = BatchParser.MkdirStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_mkdirStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 509
            self.match(BatchParser.MKDIR)
            self.state = 510
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetLocalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SETLOCAL(self):
            return self.getToken(BatchParser.SETLOCAL, 0)

        def setLocalOption(self):
            return self.getTypedRuleContext(BatchParser.SetLocalOptionContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_setLocalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetLocalStatement" ):
                listener.enterSetLocalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetLocalStatement" ):
                listener.exitSetLocalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetLocalStatement" ):
                return visitor.visitSetLocalStatement(self)
            else:
                return visitor.visitChildren(self)




    def setLocalStatement(self):

        localctx = BatchParser.SetLocalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_setLocalStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(BatchParser.SETLOCAL)
            self.state = 513
            self.setLocalOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(BatchParser.TYPE, 0)

        def filePath(self):
            return self.getTypedRuleContext(BatchParser.FilePathContext,0)


        def fileName(self):
            return self.getTypedRuleContext(BatchParser.FileNameContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_typeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeStatement" ):
                listener.enterTypeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeStatement" ):
                listener.exitTypeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeStatement" ):
                return visitor.visitTypeStatement(self)
            else:
                return visitor.visitChildren(self)




    def typeStatement(self):

        localctx = BatchParser.TypeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_typeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            self.match(BatchParser.TYPE)
            self.state = 518
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 516
                self.filePath()
                pass

            elif la_ == 2:
                self.state = 517
                self.fileName()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RmdirStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RMDIR(self):
            return self.getToken(BatchParser.RMDIR, 0)

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def switches(self):
            return self.getTypedRuleContext(BatchParser.SwitchesContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_rmdirStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRmdirStatement" ):
                listener.enterRmdirStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRmdirStatement" ):
                listener.exitRmdirStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRmdirStatement" ):
                return visitor.visitRmdirStatement(self)
            else:
                return visitor.visitChildren(self)




    def rmdirStatement(self):

        localctx = BatchParser.RmdirStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_rmdirStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.match(BatchParser.RMDIR)
            self.state = 522
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 9223372002495037440) != 0):
                self.state = 521
                self.switches()


            self.state = 524
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XcopyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XCOPY(self):
            return self.getToken(BatchParser.XCOPY, 0)

        def xCopySource(self):
            return self.getTypedRuleContext(BatchParser.XCopySourceContext,0)


        def xCopyDestination(self):
            return self.getTypedRuleContext(BatchParser.XCopyDestinationContext,0)


        def switches(self):
            return self.getTypedRuleContext(BatchParser.SwitchesContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_xcopyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXcopyStatement" ):
                listener.enterXcopyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXcopyStatement" ):
                listener.exitXcopyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXcopyStatement" ):
                return visitor.visitXcopyStatement(self)
            else:
                return visitor.visitChildren(self)




    def xcopyStatement(self):

        localctx = BatchParser.XcopyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_xcopyStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 526
            self.match(BatchParser.XCOPY)
            self.state = 527
            self.xCopySource()
            self.state = 528
            self.xCopyDestination()
            self.state = 530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 9223372002495037440) != 0):
                self.state = 529
                self.switches()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XCopySourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_xCopySource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXCopySource" ):
                listener.enterXCopySource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXCopySource" ):
                listener.exitXCopySource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXCopySource" ):
                return visitor.visitXCopySource(self)
            else:
                return visitor.visitChildren(self)




    def xCopySource(self):

        localctx = BatchParser.XCopySourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_xCopySource)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XCopyDestinationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_xCopyDestination

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXCopyDestination" ):
                listener.enterXCopyDestination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXCopyDestination" ):
                listener.exitXCopyDestination(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXCopyDestination" ):
                return visitor.visitXCopyDestination(self)
            else:
                return visitor.visitChildren(self)




    def xCopyDestination(self):

        localctx = BatchParser.XCopyDestinationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_xCopyDestination)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 534
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.SwitchContext)
            else:
                return self.getTypedRuleContext(BatchParser.SwitchContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_switches

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitches" ):
                listener.enterSwitches(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitches" ):
                listener.exitSwitches(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitches" ):
                return visitor.visitSwitches(self)
            else:
                return visitor.visitChildren(self)




    def switches(self):

        localctx = BatchParser.SwitchesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_switches)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 537 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 536
                self.switch()
                self.state = 539 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 9223372002495037440) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH_W(self):
            return self.getToken(BatchParser.SLASH_W, 0)

        def SLASH_C(self):
            return self.getToken(BatchParser.SLASH_C, 0)

        def SLASH_V(self):
            return self.getToken(BatchParser.SLASH_V, 0)

        def SLASH_P(self):
            return self.getToken(BatchParser.SLASH_P, 0)

        def SLASH_F(self):
            return self.getToken(BatchParser.SLASH_F, 0)

        def SLASH_L(self):
            return self.getToken(BatchParser.SLASH_L, 0)

        def SLASH_G(self):
            return self.getToken(BatchParser.SLASH_G, 0)

        def SLASH_D(self):
            return self.getToken(BatchParser.SLASH_D, 0)

        def COLON(self):
            return self.getToken(BatchParser.COLON, 0)

        def dateFormat(self):
            return self.getTypedRuleContext(BatchParser.DateFormatContext,0)


        def SLASH_U(self):
            return self.getToken(BatchParser.SLASH_U, 0)

        def SLASH_I(self):
            return self.getToken(BatchParser.SLASH_I, 0)

        def SLASH_S(self):
            return self.getToken(BatchParser.SLASH_S, 0)

        def SLASH_E(self):
            return self.getToken(BatchParser.SLASH_E, 0)

        def SLASH_T(self):
            return self.getToken(BatchParser.SLASH_T, 0)

        def SLASH_K(self):
            return self.getToken(BatchParser.SLASH_K, 0)

        def SLASH_R(self):
            return self.getToken(BatchParser.SLASH_R, 0)

        def SLASH_H(self):
            return self.getToken(BatchParser.SLASH_H, 0)

        def SLASH_A(self):
            return self.getToken(BatchParser.SLASH_A, 0)

        def SLASH_M(self):
            return self.getToken(BatchParser.SLASH_M, 0)

        def SLASH_N(self):
            return self.getToken(BatchParser.SLASH_N, 0)

        def SLASH_O(self):
            return self.getToken(BatchParser.SLASH_O, 0)

        def SLASH_X(self):
            return self.getToken(BatchParser.SLASH_X, 0)

        def SLASH_Y(self):
            return self.getToken(BatchParser.SLASH_Y, 0)

        def SLASH_Z(self):
            return self.getToken(BatchParser.SLASH_Z, 0)

        def SLASH_B(self):
            return self.getToken(BatchParser.SLASH_B, 0)

        def SLASH_J(self):
            return self.getToken(BatchParser.SLASH_J, 0)

        def SLASH_COMPRESS(self):
            return self.getToken(BatchParser.SLASH_COMPRESS, 0)

        def SLASH_EXCLUDE(self):
            return self.getToken(BatchParser.SLASH_EXCLUDE, 0)

        def fileName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.FileNameContext)
            else:
                return self.getTypedRuleContext(BatchParser.FileNameContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.PLUS)
            else:
                return self.getToken(BatchParser.PLUS, i)

        def SLASH_Q(self):
            return self.getToken(BatchParser.SLASH_Q, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_switch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitch" ):
                listener.enterSwitch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitch" ):
                listener.exitSwitch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitch" ):
                return visitor.visitSwitch(self)
            else:
                return visitor.visitChildren(self)




    def switch(self):

        localctx = BatchParser.SwitchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_switch)
        self._la = 0 # Token type
        try:
            self.state = 584
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 541
                self.match(BatchParser.SLASH_W)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 542
                self.match(BatchParser.SLASH_C)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 543
                self.match(BatchParser.SLASH_V)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 544
                self.match(BatchParser.SLASH_P)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 545
                self.match(BatchParser.SLASH_F)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 546
                self.match(BatchParser.SLASH_L)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 547
                self.match(BatchParser.SLASH_G)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 548
                self.match(BatchParser.SLASH_D)
                self.state = 549
                self.match(BatchParser.COLON)
                self.state = 550
                self.dateFormat()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 551
                self.match(BatchParser.SLASH_U)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 552
                self.match(BatchParser.SLASH_I)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 553
                self.match(BatchParser.SLASH_S)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 554
                self.match(BatchParser.SLASH_E)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 555
                self.match(BatchParser.SLASH_T)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 556
                self.match(BatchParser.SLASH_K)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 557
                self.match(BatchParser.SLASH_R)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 558
                self.match(BatchParser.SLASH_H)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 559
                self.match(BatchParser.SLASH_A)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 560
                self.match(BatchParser.SLASH_M)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 561
                self.match(BatchParser.SLASH_N)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 562
                self.match(BatchParser.SLASH_O)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 563
                self.match(BatchParser.SLASH_X)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 564
                self.match(BatchParser.SLASH_Y)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 565
                self.match(BatchParser.SLASH_Z)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 566
                self.match(BatchParser.SLASH_B)
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 567
                self.match(BatchParser.SLASH_J)
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 568
                self.match(BatchParser.SLASH_COMPRESS)
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 569
                self.match(BatchParser.SLASH_EXCLUDE)
                self.state = 570
                self.fileName()
                self.state = 575
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==97:
                    self.state = 571
                    self.match(BatchParser.PLUS)
                    self.state = 572
                    self.fileName()
                    self.state = 577
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 578
                self.match(BatchParser.SLASH_Y)
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 579
                self.match(BatchParser.SLASH_Z)
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 580
                self.match(BatchParser.SLASH_B)
                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 581
                self.match(BatchParser.SLASH_J)
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 582
                self.match(BatchParser.SLASH_Q)
                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 583
                self.match(BatchParser.SLASH_COMPRESS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateFormatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.INT)
            else:
                return self.getToken(BatchParser.INT, i)

        def DASH(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.DASH)
            else:
                return self.getToken(BatchParser.DASH, i)

        def getRuleIndex(self):
            return BatchParser.RULE_dateFormat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateFormat" ):
                listener.enterDateFormat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateFormat" ):
                listener.exitDateFormat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateFormat" ):
                return visitor.visitDateFormat(self)
            else:
                return visitor.visitChildren(self)




    def dateFormat(self):

        localctx = BatchParser.DateFormatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_dateFormat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 586
            self.match(BatchParser.INT)
            self.state = 587
            self.match(BatchParser.DASH)
            self.state = 588
            self.match(BatchParser.INT)
            self.state = 589
            self.match(BatchParser.DASH)
            self.state = 590
            self.match(BatchParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetLocalOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENABLEDELAYEDEXPANSION(self):
            return self.getToken(BatchParser.ENABLEDELAYEDEXPANSION, 0)

        def DISABLEDELAYEDEXPANSION(self):
            return self.getToken(BatchParser.DISABLEDELAYEDEXPANSION, 0)

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_setLocalOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetLocalOption" ):
                listener.enterSetLocalOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetLocalOption" ):
                listener.exitSetLocalOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetLocalOption" ):
                return visitor.visitSetLocalOption(self)
            else:
                return visitor.visitChildren(self)




    def setLocalOption(self):

        localctx = BatchParser.SetLocalOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_setLocalOption)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 592
            _la = self._input.LA(1)
            if not(_la==6 or _la==7 or _la==101):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(BatchParser.SET, 0)

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def switches(self):
            return self.getTypedRuleContext(BatchParser.SwitchesContext,0)


        def assignmentPart(self):
            return self.getTypedRuleContext(BatchParser.AssignmentPartContext,0)


        def displayFormating(self):
            return self.getTypedRuleContext(BatchParser.DisplayFormatingContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_setStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetStatement" ):
                listener.enterSetStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetStatement" ):
                listener.exitSetStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetStatement" ):
                return visitor.visitSetStatement(self)
            else:
                return visitor.visitChildren(self)




    def setStatement(self):

        localctx = BatchParser.SetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_setStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 594
            self.match(BatchParser.SET)
            self.state = 596
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 9223372002495037440) != 0):
                self.state = 595
                self.switches()


            self.state = 598
            self.variableName()
            self.state = 600
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.state = 599
                self.assignmentPart()


            self.state = 603
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 602
                self.displayFormating()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayFormatingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JP_EQUAL(self):
            return self.getToken(BatchParser.JP_EQUAL, 0)

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_displayFormating

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayFormating" ):
                listener.enterDisplayFormating(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayFormating" ):
                listener.exitDisplayFormating(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayFormating" ):
                return visitor.visitDisplayFormating(self)
            else:
                return visitor.visitChildren(self)




    def displayFormating(self):

        localctx = BatchParser.DisplayFormatingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_displayFormating)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 605
            self.match(BatchParser.JP_EQUAL)
            self.state = 606
            self.value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(BatchParser.EQUAL, 0)

        def value(self):
            return self.getTypedRuleContext(BatchParser.ValueContext,0)


        def STRING_CHARACTERS(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.STRING_CHARACTERS)
            else:
                return self.getToken(BatchParser.STRING_CHARACTERS, i)

        def calcOperator(self):
            return self.getTypedRuleContext(BatchParser.CalcOperatorContext,0)


        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_assignmentPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentPart" ):
                listener.enterAssignmentPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentPart" ):
                listener.exitAssignmentPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentPart" ):
                return visitor.visitAssignmentPart(self)
            else:
                return visitor.visitChildren(self)




    def assignmentPart(self):

        localctx = BatchParser.AssignmentPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_assignmentPart)
        self._la = 0 # Token type
        try:
            self.state = 621
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.enterOuterAlt(localctx, 1)
                self.state = 608
                self.match(BatchParser.EQUAL)
                self.state = 615
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
                if la_ == 1:
                    self.state = 609
                    self.value()

                elif la_ == 2:
                    self.state = 611 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 610
                        self.match(BatchParser.STRING_CHARACTERS)
                        self.state = 613 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==102):
                            break



                pass
            elif token in [22, 91, 97, 98]:
                self.enterOuterAlt(localctx, 2)
                self.state = 617
                self.calcOperator()
                self.state = 618
                self.match(BatchParser.EQUAL)
                self.state = 619
                self.match(BatchParser.INT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PauseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAUSE(self):
            return self.getToken(BatchParser.PAUSE, 0)

        def GREATER_CHAR(self):
            return self.getToken(BatchParser.GREATER_CHAR, 0)

        def NUL(self):
            return self.getToken(BatchParser.NUL, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_pauseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPauseStatement" ):
                listener.enterPauseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPauseStatement" ):
                listener.exitPauseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPauseStatement" ):
                return visitor.visitPauseStatement(self)
            else:
                return visitor.visitChildren(self)




    def pauseStatement(self):

        localctx = BatchParser.PauseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_pauseStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 623
            self.match(BatchParser.PAUSE)
            self.state = 626
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==93:
                self.state = 624
                self.match(BatchParser.GREATER_CHAR)
                self.state = 625
                self.match(BatchParser.NUL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_variableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableName" ):
                listener.enterVariableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableName" ):
                listener.exitVariableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableName" ):
                return visitor.visitVariableName(self)
            else:
                return visitor.visitChildren(self)




    def variableName(self):

        localctx = BatchParser.VariableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_variableName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            self.match(BatchParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(BatchParser.STRING, 0)

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def referencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.ReferencedVariableContext)
            else:
                return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,i)


        def identifierCombinedWithReferencedVariable(self):
            return self.getTypedRuleContext(BatchParser.IdentifierCombinedWithReferencedVariableContext,0)


        def filePath(self):
            return self.getTypedRuleContext(BatchParser.FilePathContext,0)


        def fileName(self):
            return self.getTypedRuleContext(BatchParser.FileNameContext,0)


        def JP_TXT(self):
            return self.getToken(BatchParser.JP_TXT, 0)

        def calcValue(self):
            return self.getTypedRuleContext(BatchParser.CalcValueContext,0)


        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def forVariable(self):
            return self.getTypedRuleContext(BatchParser.ForVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = BatchParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_value)
        try:
            self.state = 644
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 630
                self.match(BatchParser.STRING)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 631
                self.match(BatchParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 633 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 632
                        self.referencedVariable()

                    else:
                        raise NoViableAltException(self)
                    self.state = 635 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,56,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 637
                self.identifierCombinedWithReferencedVariable()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 638
                self.filePath()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 639
                self.fileName()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 640
                self.match(BatchParser.JP_TXT)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 641
                self.calcValue()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 642
                self.match(BatchParser.INT)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 643
                self.forVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalcValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def calcOperator(self):
            return self.getTypedRuleContext(BatchParser.CalcOperatorContext,0)


        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.INT)
            else:
                return self.getToken(BatchParser.INT, i)

        def referencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.ReferencedVariableContext)
            else:
                return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,i)


        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.STRING)
            else:
                return self.getToken(BatchParser.STRING, i)

        def getRuleIndex(self):
            return BatchParser.RULE_calcValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCalcValue" ):
                listener.enterCalcValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCalcValue" ):
                listener.exitCalcValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalcValue" ):
                return visitor.visitCalcValue(self)
            else:
                return visitor.visitChildren(self)




    def calcValue(self):

        localctx = BatchParser.CalcValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_calcValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.state = 646
                self.match(BatchParser.INT)
                pass
            elif token in [85, 86]:
                self.state = 647
                self.referencedVariable()
                pass
            elif token in [2]:
                self.state = 648
                self.match(BatchParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 651
            self.calcOperator()
            self.state = 655
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.state = 652
                self.match(BatchParser.INT)
                pass
            elif token in [85, 86]:
                self.state = 653
                self.referencedVariable()
                pass
            elif token in [2]:
                self.state = 654
                self.match(BatchParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalcOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(BatchParser.PLUS, 0)

        def DASH(self):
            return self.getToken(BatchParser.DASH, 0)

        def STAR(self):
            return self.getToken(BatchParser.STAR, 0)

        def SLASH(self):
            return self.getToken(BatchParser.SLASH, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_calcOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCalcOperator" ):
                listener.enterCalcOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCalcOperator" ):
                listener.exitCalcOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalcOperator" ):
                return visitor.visitCalcOperator(self)
            else:
                return visitor.visitChildren(self)




    def calcOperator(self):

        localctx = BatchParser.CalcOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_calcOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            _la = self._input.LA(1)
            if not(_la==22 or ((((_la - 91)) & ~0x3f) == 0 and ((1 << (_la - 91)) & 193) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilePathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fileName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.FileNameContext)
            else:
                return self.getTypedRuleContext(BatchParser.FileNameContext,i)


        def DISK_ADDRESS(self):
            return self.getToken(BatchParser.DISK_ADDRESS, 0)

        def SSLASH(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.SSLASH)
            else:
                return self.getToken(BatchParser.SSLASH, i)

        def getRuleIndex(self):
            return BatchParser.RULE_filePath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilePath" ):
                listener.enterFilePath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilePath" ):
                listener.exitFilePath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilePath" ):
                return visitor.visitFilePath(self)
            else:
                return visitor.visitChildren(self)




    def filePath(self):

        localctx = BatchParser.FilePathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_filePath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23, 63, 72, 85, 86, 92, 96, 98, 99, 101]:
                self.state = 659
                self.fileName()
                pass
            elif token in [65]:
                self.state = 660
                self.match(BatchParser.DISK_ADDRESS)
                pass
            elif token in [24]:
                pass
            else:
                pass
            self.state = 667 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 663
                    self.match(BatchParser.SSLASH)
                    self.state = 665
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                    if la_ == 1:
                        self.state = 664
                        self.fileName()



                else:
                    raise NoViableAltException(self)
                self.state = 669 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,62,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fileNameChar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.FileNameCharContext)
            else:
                return self.getTypedRuleContext(BatchParser.FileNameCharContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_fileName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileName" ):
                listener.enterFileName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileName" ):
                listener.exitFileName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileName" ):
                return visitor.visitFileName(self)
            else:
                return visitor.visitChildren(self)




    def fileName(self):

        localctx = BatchParser.FileNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_fileName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 671
                    self.fileNameChar()

                else:
                    raise NoViableAltException(self)
                self.state = 674 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileNameCharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def UNDERSCORE(self):
            return self.getToken(BatchParser.UNDERSCORE, 0)

        def DOT(self):
            return self.getToken(BatchParser.DOT, 0)

        def JP_TXT(self):
            return self.getToken(BatchParser.JP_TXT, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def STAR(self):
            return self.getToken(BatchParser.STAR, 0)

        def COMMA(self):
            return self.getToken(BatchParser.COMMA, 0)

        def QUESTION(self):
            return self.getToken(BatchParser.QUESTION, 0)

        def EXE(self):
            return self.getToken(BatchParser.EXE, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_fileNameChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileNameChar" ):
                listener.enterFileNameChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileNameChar" ):
                listener.exitFileNameChar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileNameChar" ):
                return visitor.visitFileNameChar(self)
            else:
                return visitor.visitChildren(self)




    def fileNameChar(self):

        localctx = BatchParser.FileNameCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_fileNameChar)
        try:
            self.state = 685
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [101]:
                self.enterOuterAlt(localctx, 1)
                self.state = 676
                self.match(BatchParser.IDENTIFIER)
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 2)
                self.state = 677
                self.match(BatchParser.UNDERSCORE)
                pass
            elif token in [63]:
                self.enterOuterAlt(localctx, 3)
                self.state = 678
                self.match(BatchParser.DOT)
                pass
            elif token in [99]:
                self.enterOuterAlt(localctx, 4)
                self.state = 679
                self.match(BatchParser.JP_TXT)
                pass
            elif token in [85, 86]:
                self.enterOuterAlt(localctx, 5)
                self.state = 680
                self.referencedVariable()
                pass
            elif token in [98]:
                self.enterOuterAlt(localctx, 6)
                self.state = 681
                self.match(BatchParser.STAR)
                pass
            elif token in [96]:
                self.enterOuterAlt(localctx, 7)
                self.state = 682
                self.match(BatchParser.COMMA)
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 8)
                self.state = 683
                self.match(BatchParser.QUESTION)
                pass
            elif token in [72]:
                self.enterOuterAlt(localctx, 9)
                self.state = 684
                self.match(BatchParser.EXE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierCombinedWithReferencedVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def idetifierOrRerencedVariable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BatchParser.IdetifierOrRerencedVariableContext)
            else:
                return self.getTypedRuleContext(BatchParser.IdetifierOrRerencedVariableContext,i)


        def getRuleIndex(self):
            return BatchParser.RULE_identifierCombinedWithReferencedVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierCombinedWithReferencedVariable" ):
                listener.enterIdentifierCombinedWithReferencedVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierCombinedWithReferencedVariable" ):
                listener.exitIdentifierCombinedWithReferencedVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierCombinedWithReferencedVariable" ):
                return visitor.visitIdentifierCombinedWithReferencedVariable(self)
            else:
                return visitor.visitChildren(self)




    def identifierCombinedWithReferencedVariable(self):

        localctx = BatchParser.IdentifierCombinedWithReferencedVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_identifierCombinedWithReferencedVariable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 688 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 687
                    self.idetifierOrRerencedVariable()

                else:
                    raise NoViableAltException(self)
                self.state = 690 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,65,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdetifierOrRerencedVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def referencedVariable(self):
            return self.getTypedRuleContext(BatchParser.ReferencedVariableContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_idetifierOrRerencedVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdetifierOrRerencedVariable" ):
                listener.enterIdetifierOrRerencedVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdetifierOrRerencedVariable" ):
                listener.exitIdetifierOrRerencedVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdetifierOrRerencedVariable" ):
                return visitor.visitIdetifierOrRerencedVariable(self)
            else:
                return visitor.visitChildren(self)




    def idetifierOrRerencedVariable(self):

        localctx = BatchParser.IdetifierOrRerencedVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_idetifierOrRerencedVariable)
        try:
            self.state = 694
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [101]:
                self.enterOuterAlt(localctx, 1)
                self.state = 692
                self.match(BatchParser.IDENTIFIER)
                pass
            elif token in [85, 86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 693
                self.referencedVariable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReferencedVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENT(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.PERCENT)
            else:
                return self.getToken(BatchParser.PERCENT, i)

        def variableName(self):
            return self.getTypedRuleContext(BatchParser.VariableNameContext,0)


        def variableSubstring(self):
            return self.getTypedRuleContext(BatchParser.VariableSubstringContext,0)


        def EXCLAMATION(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.EXCLAMATION)
            else:
                return self.getToken(BatchParser.EXCLAMATION, i)

        def getRuleIndex(self):
            return BatchParser.RULE_referencedVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferencedVariable" ):
                listener.enterReferencedVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferencedVariable" ):
                listener.exitReferencedVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReferencedVariable" ):
                return visitor.visitReferencedVariable(self)
            else:
                return visitor.visitChildren(self)




    def referencedVariable(self):

        localctx = BatchParser.ReferencedVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_referencedVariable)
        self._la = 0 # Token type
        try:
            self.state = 710
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [85]:
                self.enterOuterAlt(localctx, 1)
                self.state = 696
                self.match(BatchParser.PERCENT)

                self.state = 697
                self.variableName()
                self.state = 699
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==18:
                    self.state = 698
                    self.variableSubstring()


                self.state = 701
                self.match(BatchParser.PERCENT)
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 703
                self.match(BatchParser.EXCLAMATION)

                self.state = 704
                self.variableName()
                self.state = 706
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==18:
                    self.state = 705
                    self.variableSubstring()


                self.state = 708
                self.match(BatchParser.EXCLAMATION)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(BatchParser.COLON, 0)

        def leftSubstring(self):
            return self.getTypedRuleContext(BatchParser.LeftSubstringContext,0)


        def rightSubstring(self):
            return self.getTypedRuleContext(BatchParser.RightSubstringContext,0)


        def removeSubstring(self):
            return self.getTypedRuleContext(BatchParser.RemoveSubstringContext,0)


        def removeSpaces(self):
            return self.getTypedRuleContext(BatchParser.RemoveSpacesContext,0)


        def replaceSubstring(self):
            return self.getTypedRuleContext(BatchParser.ReplaceSubstringContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_variableSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableSubstring" ):
                listener.enterVariableSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableSubstring" ):
                listener.exitVariableSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableSubstring" ):
                return visitor.visitVariableSubstring(self)
            else:
                return visitor.visitChildren(self)




    def variableSubstring(self):

        localctx = BatchParser.VariableSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_variableSubstring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 712
            self.match(BatchParser.COLON)
            self.state = 718
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 713
                self.leftSubstring()
                pass

            elif la_ == 2:
                self.state = 714
                self.rightSubstring()
                pass

            elif la_ == 3:
                self.state = 715
                self.removeSubstring()
                pass

            elif la_ == 4:
                self.state = 716
                self.removeSpaces()
                pass

            elif la_ == 5:
                self.state = 717
                self.replaceSubstring()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeftSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TILDE(self):
            return self.getToken(BatchParser.TILDE, 0)

        def startSub(self):
            return self.getTypedRuleContext(BatchParser.StartSubContext,0)


        def COMMA(self):
            return self.getToken(BatchParser.COMMA, 0)

        def lengthSub(self):
            return self.getTypedRuleContext(BatchParser.LengthSubContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_leftSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftSubstring" ):
                listener.enterLeftSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftSubstring" ):
                listener.exitLeftSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeftSubstring" ):
                return visitor.visitLeftSubstring(self)
            else:
                return visitor.visitChildren(self)




    def leftSubstring(self):

        localctx = BatchParser.LeftSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_leftSubstring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.match(BatchParser.TILDE)
            self.state = 721
            self.startSub()
            self.state = 722
            self.match(BatchParser.COMMA)
            self.state = 723
            self.lengthSub()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TILDE(self):
            return self.getToken(BatchParser.TILDE, 0)

        def DASH(self):
            return self.getToken(BatchParser.DASH, 0)

        def lengthSub(self):
            return self.getTypedRuleContext(BatchParser.LengthSubContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_rightSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightSubstring" ):
                listener.enterRightSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightSubstring" ):
                listener.exitRightSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightSubstring" ):
                return visitor.visitRightSubstring(self)
            else:
                return visitor.visitChildren(self)




    def rightSubstring(self):

        localctx = BatchParser.RightSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_rightSubstring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 725
            self.match(BatchParser.TILDE)
            self.state = 726
            self.match(BatchParser.DASH)
            self.state = 727
            self.lengthSub()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplacedOrRemovedSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self):
            return self.getToken(BatchParser.WS, 0)

        def COLON(self):
            return self.getToken(BatchParser.COLON, 0)

        def IDENTIFIER(self):
            return self.getToken(BatchParser.IDENTIFIER, 0)

        def DOT(self):
            return self.getToken(BatchParser.DOT, 0)

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def STRING_CHARACTERS(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.STRING_CHARACTERS)
            else:
                return self.getToken(BatchParser.STRING_CHARACTERS, i)

        def getRuleIndex(self):
            return BatchParser.RULE_replacedOrRemovedSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplacedOrRemovedSubstring" ):
                listener.enterReplacedOrRemovedSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplacedOrRemovedSubstring" ):
                listener.exitReplacedOrRemovedSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplacedOrRemovedSubstring" ):
                return visitor.visitReplacedOrRemovedSubstring(self)
            else:
                return visitor.visitChildren(self)




    def replacedOrRemovedSubstring(self):

        localctx = BatchParser.ReplacedOrRemovedSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_replacedOrRemovedSubstring)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 739
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [102]:
                self.state = 730 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 729
                    self.match(BatchParser.STRING_CHARACTERS)
                    self.state = 732 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==102):
                        break

                pass
            elif token in [9]:
                self.state = 734
                self.match(BatchParser.WS)
                pass
            elif token in [18]:
                self.state = 735
                self.match(BatchParser.COLON)
                pass
            elif token in [101]:
                self.state = 736
                self.match(BatchParser.IDENTIFIER)
                pass
            elif token in [63]:
                self.state = 737
                self.match(BatchParser.DOT)
                pass
            elif token in [8]:
                self.state = 738
                self.match(BatchParser.INT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemoveSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def removedSubstring(self):
            return self.getTypedRuleContext(BatchParser.RemovedSubstringContext,0)


        def EQUAL(self):
            return self.getToken(BatchParser.EQUAL, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_removeSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveSubstring" ):
                listener.enterRemoveSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveSubstring" ):
                listener.exitRemoveSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemoveSubstring" ):
                return visitor.visitRemoveSubstring(self)
            else:
                return visitor.visitChildren(self)




    def removeSubstring(self):

        localctx = BatchParser.RemoveSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_removeSubstring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 741
            self.removedSubstring()
            self.state = 742
            self.match(BatchParser.EQUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemovedSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def replacedOrRemovedSubstring(self):
            return self.getTypedRuleContext(BatchParser.ReplacedOrRemovedSubstringContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_removedSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemovedSubstring" ):
                listener.enterRemovedSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemovedSubstring" ):
                listener.exitRemovedSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemovedSubstring" ):
                return visitor.visitRemovedSubstring(self)
            else:
                return visitor.visitChildren(self)




    def removedSubstring(self):

        localctx = BatchParser.RemovedSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_removedSubstring)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.replacedOrRemovedSubstring()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RemoveSpacesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(BatchParser.EQUAL, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_removeSpaces

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveSpaces" ):
                listener.enterRemoveSpaces(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveSpaces" ):
                listener.exitRemoveSpaces(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemoveSpaces" ):
                return visitor.visitRemoveSpaces(self)
            else:
                return visitor.visitChildren(self)




    def removeSpaces(self):

        localctx = BatchParser.RemoveSpacesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_removeSpaces)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.match(BatchParser.EQUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplaceSubstringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(BatchParser.EQUAL, 0)

        def subStringReplaced(self):
            return self.getTypedRuleContext(BatchParser.SubStringReplacedContext,0)


        def subtringRemoved(self):
            return self.getTypedRuleContext(BatchParser.SubtringRemovedContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_replaceSubstring

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReplaceSubstring" ):
                listener.enterReplaceSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReplaceSubstring" ):
                listener.exitReplaceSubstring(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceSubstring" ):
                return visitor.visitReplaceSubstring(self)
            else:
                return visitor.visitChildren(self)




    def replaceSubstring(self):

        localctx = BatchParser.ReplaceSubstringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_replaceSubstring)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -9223372036854512896) != 0) or _la==101 or _la==102:
                self.state = 748
                self.subtringRemoved()


            self.state = 751
            self.match(BatchParser.EQUAL)
            self.state = 752
            self.subStringReplaced()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubtringRemovedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def replacedOrRemovedSubstring(self):
            return self.getTypedRuleContext(BatchParser.ReplacedOrRemovedSubstringContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_subtringRemoved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubtringRemoved" ):
                listener.enterSubtringRemoved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubtringRemoved" ):
                listener.exitSubtringRemoved(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubtringRemoved" ):
                return visitor.visitSubtringRemoved(self)
            else:
                return visitor.visitChildren(self)




    def subtringRemoved(self):

        localctx = BatchParser.SubtringRemovedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_subtringRemoved)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self.replacedOrRemovedSubstring()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubStringReplacedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def replacedOrRemovedSubstring(self):
            return self.getTypedRuleContext(BatchParser.ReplacedOrRemovedSubstringContext,0)


        def getRuleIndex(self):
            return BatchParser.RULE_subStringReplaced

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubStringReplaced" ):
                listener.enterSubStringReplaced(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubStringReplaced" ):
                listener.exitSubStringReplaced(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubStringReplaced" ):
                return visitor.visitSubStringReplaced(self)
            else:
                return visitor.visitChildren(self)




    def subStringReplaced(self):

        localctx = BatchParser.SubStringReplacedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_subStringReplaced)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 756
            self.replacedOrRemovedSubstring()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StartSubContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_startSub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStartSub" ):
                listener.enterStartSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStartSub" ):
                listener.exitStartSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStartSub" ):
                return visitor.visitStartSub(self)
            else:
                return visitor.visitChildren(self)




    def startSub(self):

        localctx = BatchParser.StartSubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_startSub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            self.match(BatchParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LengthSubContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def DASH(self):
            return self.getToken(BatchParser.DASH, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_lengthSub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLengthSub" ):
                listener.enterLengthSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLengthSub" ):
                listener.exitLengthSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLengthSub" ):
                return visitor.visitLengthSub(self)
            else:
                return visitor.visitChildren(self)




    def lengthSub(self):

        localctx = BatchParser.LengthSubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_lengthSub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 761
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==91:
                self.state = 760
                self.match(BatchParser.DASH)


            self.state = 763
            self.match(BatchParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableStartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_variableStart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableStart" ):
                listener.enterVariableStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableStart" ):
                listener.exitVariableStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableStart" ):
                return visitor.visitVariableStart(self)
            else:
                return visitor.visitChildren(self)




    def variableStart(self):

        localctx = BatchParser.VariableStartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_variableStart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 765
            self.match(BatchParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableLengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(BatchParser.INT, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_variableLength

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableLength" ):
                listener.enterVariableLength(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableLength" ):
                listener.exitVariableLength(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableLength" ):
                return visitor.visitVariableLength(self)
            else:
                return visitor.visitChildren(self)




    def variableLength(self):

        localctx = BatchParser.VariableLengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_variableLength)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.match(BatchParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConcatenateStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(BatchParser.STRING)
            else:
                return self.getToken(BatchParser.STRING, i)

        def PLUS(self):
            return self.getToken(BatchParser.PLUS, 0)

        def getRuleIndex(self):
            return BatchParser.RULE_concatenateString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenateString" ):
                listener.enterConcatenateString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenateString" ):
                listener.exitConcatenateString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenateString" ):
                return visitor.visitConcatenateString(self)
            else:
                return visitor.visitChildren(self)




    def concatenateString(self):

        localctx = BatchParser.ConcatenateStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_concatenateString)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self.match(BatchParser.STRING)
            self.state = 770
            self.match(BatchParser.PLUS)
            self.state = 771
            self.match(BatchParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





